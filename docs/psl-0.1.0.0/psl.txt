-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package psl
@version 0.1.0.0

module AddToUVMHS
data AddBTD a
BotBTD :: AddBTD a
TopBTD :: AddBTD a
AddBTD :: a -> AddBTD a
logBase :: ğ”» -> ğ”» -> ğ”»
instance GHC.Show.Show a => GHC.Show.Show (AddToUVMHS.AddBTD a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (AddToUVMHS.AddBTD a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (AddToUVMHS.AddBTD a)
instance UVMHS.Core.Classes.Lattice.Bot (AddToUVMHS.AddBTD a)
instance GHC.Classes.Eq a => UVMHS.Core.Classes.Lattice.Join (AddToUVMHS.AddBTD a)
instance UVMHS.Core.Classes.Lattice.Top (AddToUVMHS.AddBTD a)
instance GHC.Classes.Eq a => UVMHS.Core.Classes.Lattice.Meet (AddToUVMHS.AddBTD a)
instance GHC.Classes.Eq a => UVMHS.Core.Classes.Lattice.JoinLattice (AddToUVMHS.AddBTD a)
instance GHC.Classes.Eq a => UVMHS.Core.Classes.Lattice.MeetLattice (AddToUVMHS.AddBTD a)
instance GHC.Classes.Eq a => UVMHS.Core.Classes.Lattice.Lattice (AddToUVMHS.AddBTD a)
instance UVMHS.Core.Classes.Functor.Functor AddToUVMHS.AddBTD
instance UVMHS.Core.Classes.Monad.Return AddToUVMHS.AddBTD
instance UVMHS.Core.Classes.Monad.Bind AddToUVMHS.AddBTD
instance UVMHS.Core.Classes.Monad.Monad AddToUVMHS.AddBTD
instance UVMHS.Core.Classes.FunctorM.FunctorM AddToUVMHS.AddBTD
instance UVMHS.Lib.Pretty.Core.Pretty a => UVMHS.Lib.Pretty.Core.Pretty (AddToUVMHS.AddBTD a)

module PSL.Interpreter.PrettyFuture

module PSL.Syntax
data Kind
TypeK :: Kind
PrinK :: Kind
PrinsK :: Kind
type Prin = ğ•Š
data PrinVal
SinglePV :: Prin -> PrinVal
AccessPV :: Prin -> â„• -> PrinVal
VirtualPV :: Prin -> PrinVal
data PrinExpVal
ValPEV :: PrinVal -> PrinExpVal
PowPEV :: ğ‘ƒ PrinVal -> PrinExpVal
SetPEV :: â„• -> Prin -> PrinExpVal
data PrinExp
VarPE :: ğ• -> PrinExp
AccessPE :: ğ• -> â„• -> PrinExp
StarPE :: ğ• -> PrinExp
ThisPE :: PrinExp
data PrinDecl
SinglePD :: Prin -> PrinDecl
ArrayPD :: Prin -> â„• -> PrinDecl
data PrinKind
SinglePK :: PrinKind
SetPK :: â„• -> PrinKind
VirtualPK :: PrinKind
data Constr
SubsetC :: ğ¿ PrinExp -> ğ¿ PrinExp -> Constr
data Mode
SecM :: ğ‘ƒ PrinVal -> Mode
TopM :: Mode
topML :: (âŒ²) Mode ()
secML :: (âŒ²) Mode (ğ‘ƒ PrinVal)
data EMode
SecEM :: ğ¿ PrinExp -> EMode

-- | SSecEM (ğ¿ PrinExp) -- (ğ‘ƒ PrinVal)
TopEM :: EMode
topEML :: (âŒ²) EMode ()
secEML :: (âŒ²) EMode (ğ¿ PrinExp)
data Effect
Effect :: ğ‘ƒ PrinExp -> ğ‘ƒ PrinExp -> EMode -> Effect
[effectInput] :: Effect -> ğ‘ƒ PrinExp
[effectReveal] :: Effect -> ğ‘ƒ PrinExp
[effectMode] :: Effect -> EMode
effectModeL :: (âŸ¢) Effect EMode
effectRevealL :: (âŸ¢) Effect (ğ‘ƒ PrinExp)
effectInputL :: (âŸ¢) Effect (ğ‘ƒ PrinExp)
type TVar = ğ•
data Prot
YaoP :: Prot
BGWP :: Prot
GMWP :: Prot
BGVP :: Prot
SPDZP :: Prot
AutoP :: Prot
data IPrecision
InfIPr :: IPrecision
FixedIPr :: â„• -> â„• -> IPrecision
iprDefault :: IPrecision
data FPrecision
FixedFPr :: â„• -> â„• -> FPrecision
fprDefault :: FPrecision
data Type
VarT :: TVar -> Type
UnitT :: Type
ğ”¹T :: Type
ğ•ŠT :: Type
â„™T :: Type
â„™sT :: Type
â„•T :: IPrecision -> Type
â„¤T :: IPrecision -> Type
ğ”½T :: FPrecision -> Type
(:+:) :: Type -> Type -> Type
(:Ã—:) :: Type -> Type -> Type
ListT :: Type -> Type
RefT :: Type -> Type
ArrT :: Type -> Type
(:â†’:) :: Type -> (Effect âˆ§ Type) -> Type
(:â†’â€ :) :: ((ğ• âˆ§ Type) âˆ§ ğ¿ Constr) -> (Effect âˆ§ Type) -> Type
ForallT :: ğ¿ (TVar âˆ§ Kind) -> ğ¿ Constr -> Type -> Type
SecT :: ğ¿ PrinExp -> Type -> Type

-- | SSecT (ğ¿ PrinExp) Type -- Ï„{ssec:P} / Ï„{ssec:P}
ISecT :: ğ¿ PrinExp -> Type -> Type
ShareT :: Prot -> ğ¿ PrinExp -> Type -> Type
NizkTestT :: ğ¿ PrinExp -> Type -> Type
NizkVerifyT :: ğ¿ PrinExp -> Type -> Type
type Var = ğ•
data Pat
VarP :: Var -> Pat
BulP :: Pat
LP :: Pat -> Pat
RP :: Pat -> Pat
TupP :: Pat -> Pat -> Pat
NilP :: Pat
ConsP :: Pat -> Pat -> Pat
EmptyP :: Pat
BundleP :: ğ• -> Pat -> Pat -> Pat
EmptySetP :: Pat
SetP :: ğ• -> Pat -> Pat
AscrP :: Pat -> Type -> Pat
WildP :: Pat
wildPL :: (âŒ²) Pat ()
ascrPL :: (âŒ²) Pat ((âˆ§) Pat Type)
setPL :: (âŒ²) Pat ((âˆ§) ğ• Pat)
emptySetPL :: (âŒ²) Pat ()
bundlePL :: (âŒ²) Pat ((âˆ§) ((âˆ§) ğ• Pat) Pat)
emptyPL :: (âŒ²) Pat ()
consPL :: (âŒ²) Pat ((âˆ§) Pat Pat)
nilPL :: (âŒ²) Pat ()
tupPL :: (âŒ²) Pat ((âˆ§) Pat Pat)
rPL :: (âŒ²) Pat Pat
lPL :: (âŒ²) Pat Pat
bulPL :: (âŒ²) Pat ()
varPL :: (âŒ²) Pat Var
data Op
OrO :: Op
AndO :: Op
NotO :: Op
PlusO :: Op
MinusO :: Op
TimesO :: Op
ExpO :: Op
DivO :: Op
ModO :: Op
EqO :: Op
LTO :: Op
GTO :: Op
LTEO :: Op
GTEO :: Op
CondO :: Op
AbsO :: Op
SqrtO :: Op
LogO :: Op
NatO :: IPrecision -> Op
IntO :: IPrecision -> Op
FltO :: FPrecision -> Op
CeilO :: IPrecision -> Op
ceilOL :: (âŒ²) Op IPrecision
fltOL :: (âŒ²) Op FPrecision
intOL :: (âŒ²) Op IPrecision
natOL :: (âŒ²) Op IPrecision
logOL :: (âŒ²) Op ()
sqrtOL :: (âŒ²) Op ()
absOL :: (âŒ²) Op ()
condOL :: (âŒ²) Op ()
gTEOL :: (âŒ²) Op ()
lTEOL :: (âŒ²) Op ()
gTOL :: (âŒ²) Op ()
lTOL :: (âŒ²) Op ()
eqOL :: (âŒ²) Op ()
modOL :: (âŒ²) Op ()
divOL :: (âŒ²) Op ()
expOL :: (âŒ²) Op ()
timesOL :: (âŒ²) Op ()
minusOL :: (âŒ²) Op ()
plusOL :: (âŒ²) Op ()
notOL :: (âŒ²) Op ()
andOL :: (âŒ²) Op ()
orOL :: (âŒ²) Op ()
type Exp = Annotated FullContext ExpR
data ExpR
VarE :: Var -> ExpR
BoolE :: ğ”¹ -> ExpR
StrE :: ğ•Š -> ExpR
NatE :: IPrecision -> â„• -> ExpR
IntE :: IPrecision -> â„¤ -> ExpR
FltE :: FPrecision -> ğ”» -> ExpR
BulE :: ExpR
IfE :: Exp -> Exp -> Exp -> ExpR
MuxIfE :: Exp -> Exp -> Exp -> ExpR
LE :: Exp -> ExpR
RE :: Exp -> ExpR
TupE :: Exp -> Exp -> ExpR
NilE :: ExpR
ConsE :: Exp -> Exp -> ExpR
LetTyE :: Pat -> Exp -> ExpR
LetE :: Pat -> Exp -> Exp -> ExpR
CaseE :: Exp -> ğ¿ (Pat âˆ§ Exp) -> ExpR
MuxCaseE :: Exp -> ğ¿ (Pat âˆ§ Exp) -> ExpR
LamE :: ğ‘‚ Var -> ğ¿ Pat -> Exp -> ExpR
AppE :: Exp -> Exp -> ExpR
TLamE :: TVar -> Exp -> ExpR
TAppE :: Exp -> Type -> ExpR
ParE :: ğ¿ PrinExp -> Exp -> ExpR
ShareE :: Prot -> ğ¿ PrinExp -> ğ¿ PrinExp -> Exp -> ExpR
AccessE :: Exp -> PrinExp -> ExpR
BundleE :: ğ¿ (PrinExp âˆ§ Exp) -> ExpR
BundleUnionE :: Exp -> Exp -> ExpR
RevealE :: ğ¿ PrinExp -> Exp -> ExpR
SendE :: ğ¿ PrinExp -> ğ¿ PrinExp -> Exp -> ExpR
AscrE :: Exp -> Type -> ExpR
ReadE :: Type -> Exp -> ExpR
WriteE :: Exp -> Exp -> ExpR
RandE :: Type -> ExpR
RandRangeE :: Type -> Exp -> ExpR
InferE :: ExpR
HoleE :: ExpR
PrimE :: Op -> ğ¿ Exp -> ExpR
TraceE :: Exp -> Exp -> ExpR
SetE :: ğ¿ PrinExp -> ExpR
RefE :: Exp -> ExpR
RefReadE :: Exp -> ExpR
RefWriteE :: Exp -> Exp -> ExpR
ArrayE :: Exp -> Exp -> ExpR
ArrayReadE :: Exp -> Exp -> ExpR
ArrayWriteE :: Exp -> Exp -> ExpR
SizeE :: Exp -> ExpR
DefaultE :: ExpR
ProcE :: Exp -> ExpR
ReturnE :: Exp -> ExpR
NizkWitnessE :: Prot -> ğ¿ PrinExp -> Exp -> ExpR
NizkCommitE :: Prot -> ğ¿ PrinExp -> Exp -> ExpR
StringConcatE :: Exp -> Exp -> ExpR
ToStringE :: Exp -> ExpR
SignE :: ğ¿ PrinExp -> Exp -> ExpR
UnsignE :: ğ¿ PrinExp -> Exp -> ExpR
IsSignedE :: ğ¿ PrinExp -> Exp -> ExpR
buildLambda :: FullContext -> Var -> ğ¿ Pat -> Exp -> Exp
buildUnfixedLambda :: FullContext -> Var -> ğ¿ Pat -> Exp -> Exp
type TL = Annotated FullContext TLR
data TLR
DeclTL :: ğ”¹ -> Var -> Type -> TLR
DefnTL :: ğ”¹ -> Var -> ğ¿ Pat -> Exp -> TLR
PrinTL :: ğ¿ PrinDecl -> TLR
PrimTL :: Var -> Type -> TLR
ImportTL :: ğ•Š -> ğ¿ (ğ•Š âˆ§ ğ¿ PrinExp) -> TLR
VirtualPartyTL :: ğ¿ ğ•Š -> TLR
instance (UVMHS.Lib.Pretty.Core.Pretty UVMHS.Core.Init.ğ”¹, UVMHS.Lib.Pretty.Core.Pretty PSL.Syntax.Var, UVMHS.Lib.Pretty.Core.Pretty PSL.Syntax.Type, UVMHS.Lib.Pretty.Core.Pretty (UVMHS.Core.Init.ğ¿ PSL.Syntax.Pat), UVMHS.Lib.Pretty.Core.Pretty PSL.Syntax.Exp, UVMHS.Lib.Pretty.Core.Pretty (UVMHS.Core.Init.ğ¿ PSL.Syntax.PrinDecl), UVMHS.Lib.Pretty.Core.Pretty UVMHS.Core.Init.ğ•Š, UVMHS.Lib.Pretty.Core.Pretty (UVMHS.Core.Init.ğ¿ (UVMHS.Core.Init.ğ•Š UVMHS.Core.Init.âˆ§ UVMHS.Core.Init.ğ¿ PSL.Syntax.PrinExp)), UVMHS.Lib.Pretty.Core.Pretty (UVMHS.Core.Init.ğ¿ UVMHS.Core.Init.ğ•Š)) => UVMHS.Lib.Pretty.Core.Pretty PSL.Syntax.TLR
instance GHC.Classes.Ord PSL.Syntax.TLR
instance GHC.Classes.Eq PSL.Syntax.TLR
instance (UVMHS.Lib.Pretty.Core.Pretty PSL.Syntax.Var, UVMHS.Lib.Pretty.Core.Pretty UVMHS.Core.Init.ğ”¹, UVMHS.Lib.Pretty.Core.Pretty UVMHS.Core.Init.ğ•Š, UVMHS.Lib.Pretty.Core.Pretty PSL.Syntax.IPrecision, UVMHS.Lib.Pretty.Core.Pretty UVMHS.Core.Init.â„•, UVMHS.Lib.Pretty.Core.Pretty UVMHS.Core.Init.â„¤, UVMHS.Lib.Pretty.Core.Pretty PSL.Syntax.FPrecision, UVMHS.Lib.Pretty.Core.Pretty UVMHS.Core.Init.ğ”», UVMHS.Lib.Pretty.Core.Pretty PSL.Syntax.Exp, UVMHS.Lib.Pretty.Core.Pretty PSL.Syntax.Pat, UVMHS.Lib.Pretty.Core.Pretty (UVMHS.Core.Init.ğ¿ (PSL.Syntax.Pat UVMHS.Core.Init.âˆ§ PSL.Syntax.Exp)), UVMHS.Lib.Pretty.Core.Pretty (UVMHS.Core.Init.ğ‘‚ PSL.Syntax.Var), UVMHS.Lib.Pretty.Core.Pretty (UVMHS.Core.Init.ğ¿ PSL.Syntax.Pat), UVMHS.Lib.Pretty.Core.Pretty PSL.Syntax.TVar, UVMHS.Lib.Pretty.Core.Pretty PSL.Syntax.Type, UVMHS.Lib.Pretty.Core.Pretty (UVMHS.Core.Init.ğ¿ PSL.Syntax.PrinExp), UVMHS.Lib.Pretty.Core.Pretty PSL.Syntax.Prot, UVMHS.Lib.Pretty.Core.Pretty PSL.Syntax.PrinExp, UVMHS.Lib.Pretty.Core.Pretty (UVMHS.Core.Init.ğ¿ (PSL.Syntax.PrinExp UVMHS.Core.Init.âˆ§ PSL.Syntax.Exp)), UVMHS.Lib.Pretty.Core.Pretty PSL.Syntax.Op, UVMHS.Lib.Pretty.Core.Pretty (UVMHS.Core.Init.ğ¿ PSL.Syntax.Exp)) => UVMHS.Lib.Pretty.Core.Pretty PSL.Syntax.ExpR
instance GHC.Show.Show PSL.Syntax.ExpR
instance GHC.Classes.Ord PSL.Syntax.ExpR
instance GHC.Classes.Eq PSL.Syntax.ExpR
instance (UVMHS.Lib.Pretty.Core.Pretty PSL.Syntax.IPrecision, UVMHS.Lib.Pretty.Core.Pretty PSL.Syntax.FPrecision) => UVMHS.Lib.Pretty.Core.Pretty PSL.Syntax.Op
instance GHC.Show.Show PSL.Syntax.Op
instance GHC.Classes.Ord PSL.Syntax.Op
instance GHC.Classes.Eq PSL.Syntax.Op
instance (UVMHS.Lib.Pretty.Core.Pretty PSL.Syntax.Var, UVMHS.Lib.Pretty.Core.Pretty PSL.Syntax.Pat, UVMHS.Lib.Pretty.Core.Pretty UVMHS.Lib.Binders.ğ•, UVMHS.Lib.Pretty.Core.Pretty PSL.Syntax.Type) => UVMHS.Lib.Pretty.Core.Pretty PSL.Syntax.Pat
instance GHC.Show.Show PSL.Syntax.Pat
instance GHC.Classes.Ord PSL.Syntax.Pat
instance GHC.Classes.Eq PSL.Syntax.Pat
instance (UVMHS.Lib.Pretty.Core.Pretty PSL.Syntax.TVar, UVMHS.Lib.Pretty.Core.Pretty PSL.Syntax.IPrecision, UVMHS.Lib.Pretty.Core.Pretty PSL.Syntax.FPrecision, UVMHS.Lib.Pretty.Core.Pretty PSL.Syntax.Type, UVMHS.Lib.Pretty.Core.Pretty (PSL.Syntax.Effect UVMHS.Core.Init.âˆ§ PSL.Syntax.Type), UVMHS.Lib.Pretty.Core.Pretty ((UVMHS.Lib.Binders.ğ• UVMHS.Core.Init.âˆ§ PSL.Syntax.Type) UVMHS.Core.Init.âˆ§ UVMHS.Core.Init.ğ¿ PSL.Syntax.Constr), UVMHS.Lib.Pretty.Core.Pretty (UVMHS.Core.Init.ğ¿ (PSL.Syntax.TVar UVMHS.Core.Init.âˆ§ PSL.Syntax.Kind)), UVMHS.Lib.Pretty.Core.Pretty (UVMHS.Core.Init.ğ¿ PSL.Syntax.Constr), UVMHS.Lib.Pretty.Core.Pretty (UVMHS.Core.Init.ğ¿ PSL.Syntax.PrinExp), UVMHS.Lib.Pretty.Core.Pretty PSL.Syntax.Prot) => UVMHS.Lib.Pretty.Core.Pretty PSL.Syntax.Type
instance GHC.Show.Show PSL.Syntax.Type
instance GHC.Classes.Ord PSL.Syntax.Type
instance GHC.Classes.Eq PSL.Syntax.Type
instance GHC.Show.Show PSL.Syntax.FPrecision
instance GHC.Classes.Ord PSL.Syntax.FPrecision
instance GHC.Classes.Eq PSL.Syntax.FPrecision
instance GHC.Show.Show PSL.Syntax.IPrecision
instance GHC.Classes.Ord PSL.Syntax.IPrecision
instance GHC.Classes.Eq PSL.Syntax.IPrecision
instance GHC.Show.Show PSL.Syntax.Prot
instance GHC.Classes.Ord PSL.Syntax.Prot
instance GHC.Classes.Eq PSL.Syntax.Prot
instance (UVMHS.Lib.Pretty.Core.Pretty (UVMHS.Core.Init.ğ‘ƒ PSL.Syntax.PrinExp), UVMHS.Lib.Pretty.Core.Pretty PSL.Syntax.EMode) => UVMHS.Lib.Pretty.Core.Pretty PSL.Syntax.Effect
instance GHC.Show.Show PSL.Syntax.Effect
instance GHC.Classes.Ord PSL.Syntax.Effect
instance GHC.Classes.Eq PSL.Syntax.Effect
instance UVMHS.Lib.Pretty.Core.Pretty (UVMHS.Core.Init.ğ¿ PSL.Syntax.PrinExp) => UVMHS.Lib.Pretty.Core.Pretty PSL.Syntax.EMode
instance GHC.Show.Show PSL.Syntax.EMode
instance GHC.Classes.Ord PSL.Syntax.EMode
instance GHC.Classes.Eq PSL.Syntax.EMode
instance UVMHS.Core.Classes.Lattice.POrd PSL.Syntax.Mode
instance GHC.Show.Show PSL.Syntax.Mode
instance GHC.Classes.Ord PSL.Syntax.Mode
instance GHC.Classes.Eq PSL.Syntax.Mode
instance UVMHS.Lib.Pretty.Core.Pretty (UVMHS.Core.Init.ğ¿ PSL.Syntax.PrinExp) => UVMHS.Lib.Pretty.Core.Pretty PSL.Syntax.Constr
instance GHC.Show.Show PSL.Syntax.Constr
instance GHC.Classes.Ord PSL.Syntax.Constr
instance GHC.Classes.Eq PSL.Syntax.Constr
instance UVMHS.Lib.Pretty.Core.Pretty UVMHS.Core.Init.â„• => UVMHS.Lib.Pretty.Core.Pretty PSL.Syntax.PrinKind
instance GHC.Show.Show PSL.Syntax.PrinKind
instance GHC.Classes.Ord PSL.Syntax.PrinKind
instance GHC.Classes.Eq PSL.Syntax.PrinKind
instance (UVMHS.Lib.Pretty.Core.Pretty PSL.Syntax.Prin, UVMHS.Lib.Pretty.Core.Pretty UVMHS.Core.Init.â„•) => UVMHS.Lib.Pretty.Core.Pretty PSL.Syntax.PrinDecl
instance GHC.Show.Show PSL.Syntax.PrinDecl
instance GHC.Classes.Ord PSL.Syntax.PrinDecl
instance GHC.Classes.Eq PSL.Syntax.PrinDecl
instance (UVMHS.Lib.Pretty.Core.Pretty UVMHS.Lib.Binders.ğ•, UVMHS.Lib.Pretty.Core.Pretty UVMHS.Core.Init.â„•) => UVMHS.Lib.Pretty.Core.Pretty PSL.Syntax.PrinExp
instance GHC.Show.Show PSL.Syntax.PrinExp
instance GHC.Classes.Ord PSL.Syntax.PrinExp
instance GHC.Classes.Eq PSL.Syntax.PrinExp
instance GHC.Show.Show PSL.Syntax.PrinExpVal
instance GHC.Classes.Ord PSL.Syntax.PrinExpVal
instance GHC.Classes.Eq PSL.Syntax.PrinExpVal
instance GHC.Show.Show PSL.Syntax.PrinVal
instance GHC.Classes.Ord PSL.Syntax.PrinVal
instance GHC.Classes.Eq PSL.Syntax.PrinVal
instance UVMHS.Lib.Pretty.Core.Pretty PSL.Syntax.Kind
instance GHC.Show.Show PSL.Syntax.Kind
instance GHC.Classes.Ord PSL.Syntax.Kind
instance GHC.Classes.Eq PSL.Syntax.Kind

module PSL.Interpreter.Types
data Val
BoolV :: ğ”¹ -> Val
StrV :: ğ•Š -> Val
NatV :: IPrecision -> â„• -> Val
IntV :: IPrecision -> â„¤ -> Val
FltV :: FPrecision -> ğ”» -> Val
BulV :: Val
PairV :: ValP -> ValP -> Val
LV :: ValP -> Val
RV :: ValP -> Val
NilV :: Val
ConsV :: ValP -> ValP -> Val
CloV :: ğ‘‚ Var -> Pat -> Exp -> Env -> Val
TCloV :: TVar -> Exp -> Env -> Val
PrinV :: PrinExpVal -> Val
PrinSetV :: ğ‘ƒ PrinVal -> Val
LocV :: Mode -> â„¤64 -> Val
ArrayV :: ğ• ValP -> Val
DefaultV :: Val
NizkVerifyV :: ğ‘ƒ PrinVal -> ValP -> Val
data ValP
SSecVP :: ğ‘ƒ PrinVal -> Val -> ValP
ISecVP :: (PrinVal â‡° Val) -> ValP
ShareVP :: ğ”¹ -> Prot -> ğ‘ƒ PrinVal -> ValMPC -> ValP
AllVP :: Val -> ValP
UnknownVP :: ValP
PairVP :: ValP -> ValP -> ValP
data ValMPC
BaseMV :: â„• -> BaseValMPC -> ValMPC
PairMV :: ValMPC -> ValMPC -> ValMPC
SumMV :: â„• -> ğ”¹ -> ValMPC -> ValMPC -> ValMPC
NilMV :: ValMPC
ConsMV :: ValMPC -> ValMPC -> ValMPC
BulMV :: ValMPC
DefaultMV :: ValMPC
data BaseValMPC
BoolMV :: ğ”¹ -> BaseValMPC
NatMV :: IPrecision -> â„• -> BaseValMPC
IntMV :: IPrecision -> â„¤ -> BaseValMPC
FltMV :: FPrecision -> ğ”» -> BaseValMPC
PrinMV :: AddBTD PrinVal -> BaseValMPC
type Env = ğ• â‡° ValP
nizkVerifyVL :: (âŒ²) Val ((âˆ§) (ğ‘ƒ PrinVal) ValP)
defaultVL :: (âŒ²) Val ()
arrayVL :: (âŒ²) Val (ğ• ValP)
locVL :: (âŒ²) Val ((âˆ§) Mode â„¤64)
prinSetVL :: (âŒ²) Val (ğ‘ƒ PrinVal)
prinVL :: (âŒ²) Val PrinExpVal
tCloVL :: (âŒ²) Val ((âˆ§) ((âˆ§) TVar Exp) Env)
cloVL :: (âŒ²) Val ((âˆ§) ((âˆ§) ((âˆ§) (ğ‘‚ Var) Pat) Exp) Env)
consVL :: (âŒ²) Val ((âˆ§) ValP ValP)
nilVL :: (âŒ²) Val ()
rVL :: (âŒ²) Val ValP
lVL :: (âŒ²) Val ValP
pairVL :: (âŒ²) Val ((âˆ§) ValP ValP)
bulVL :: (âŒ²) Val ()
fltVL :: (âŒ²) Val ((âˆ§) FPrecision ğ”»)
intVL :: (âŒ²) Val ((âˆ§) IPrecision â„¤)
natVL :: (âŒ²) Val ((âˆ§) IPrecision â„•)
strVL :: (âŒ²) Val ğ•Š
boolVL :: (âŒ²) Val ğ”¹
pairVPL :: (âŒ²) ValP ((âˆ§) ValP ValP)
unknownVPL :: (âŒ²) ValP ()
allVPL :: (âŒ²) ValP Val
shareVPL :: (âŒ²) ValP ((âˆ§) ((âˆ§) ((âˆ§) ğ”¹ Prot) (ğ‘ƒ PrinVal)) ValMPC)
iSecVPL :: (âŒ²) ValP ((â‡°) PrinVal Val)
sSecVPL :: (âŒ²) ValP ((âˆ§) (ğ‘ƒ PrinVal) Val)
defaultMVL :: (âŒ²) ValMPC ()
bulMVL :: (âŒ²) ValMPC ()
consMVL :: (âŒ²) ValMPC ((âˆ§) ValMPC ValMPC)
nilMVL :: (âŒ²) ValMPC ()
sumMVL :: (âŒ²) ValMPC ((âˆ§) ((âˆ§) ((âˆ§) â„• ğ”¹) ValMPC) ValMPC)
pairMVL :: (âŒ²) ValMPC ((âˆ§) ValMPC ValMPC)
baseMVL :: (âŒ²) ValMPC ((âˆ§) â„• BaseValMPC)
prinMVL :: (âŒ²) BaseValMPC (AddBTD PrinVal)
fltMVL :: (âŒ²) BaseValMPC ((âˆ§) FPrecision ğ”»)
intMVL :: (âŒ²) BaseValMPC ((âˆ§) IPrecision â„¤)
natMVL :: (âŒ²) BaseValMPC ((âˆ§) IPrecision â„•)
boolMVL :: (âŒ²) BaseValMPC ğ”¹
data ShareInfo
NotShared :: ShareInfo
Shared :: ğ”¹ -> Prot -> ğ‘ƒ PrinVal -> ShareInfo
type Store = ğ‘Š ValP
data IParams
IParams :: ğ”¹ -> ğ”¹ -> (ğ•Š â‡° ğ‘ƒ PrinVal) -> IParams
[iParamsDoResources] :: IParams -> ğ”¹
[iParamsIsExample] :: IParams -> ğ”¹
[iParamsVirtualPartyArgs] :: IParams -> ğ•Š â‡° ğ‘ƒ PrinVal
iParamsVirtualPartyArgsL :: (âŸ¢) IParams ((â‡°) ğ•Š (ğ‘ƒ PrinVal))
iParamsIsExampleL :: (âŸ¢) IParams ğ”¹
iParamsDoResourcesL :: (âŸ¢) IParams ğ”¹
Î¸â‚€ :: IParams
data ICxt
ICxt :: IParams -> ğ‘‚ FullContext -> (Prin â‡° PrinKind) -> Env -> Mode -> ğ¿ ((â„• âˆ§ ğ”¹) âˆ§ ShareInfo) -> ICxt
[iCxtParams] :: ICxt -> IParams
[iCxtSource] :: ICxt -> ğ‘‚ FullContext
[iCxtDeclPrins] :: ICxt -> Prin â‡° PrinKind
[iCxtEnv] :: ICxt -> Env
[iCxtMode] :: ICxt -> Mode
[iCxtMPCPathCondition] :: ICxt -> ğ¿ ((â„• âˆ§ ğ”¹) âˆ§ ShareInfo)
iCxtMPCPathConditionL :: (âŸ¢) ICxt (ğ¿ ((âˆ§) ((âˆ§) â„• ğ”¹) ShareInfo))
iCxtModeL :: (âŸ¢) ICxt Mode
iCxtEnvL :: (âŸ¢) ICxt Env
iCxtDeclPrinsL :: (âŸ¢) ICxt ((â‡°) Prin PrinKind)
iCxtSourceL :: (âŸ¢) ICxt (ğ‘‚ FullContext)
iCxtParamsL :: (âŸ¢) ICxt IParams
iCxtDoResourcesL :: ICxt âŸ¢ ğ”¹
iCxtIsExampleL :: ICxt âŸ¢ ğ”¹
Î¾â‚€ :: ICxt
data IState
IState :: Store -> â„¤64 -> ğ¿ ((ğ¿ ((â„• âˆ§ ğ”¹) âˆ§ ShareInfo) âˆ§ ShareInfo) âˆ§ ValMPC) -> IState
[iStateStore] :: IState -> Store
[iStateNextLoc] :: IState -> â„¤64
[iStateMPCCont] :: IState -> ğ¿ ((ğ¿ ((â„• âˆ§ ğ”¹) âˆ§ ShareInfo) âˆ§ ShareInfo) âˆ§ ValMPC)
iStateMPCContL :: (âŸ¢) IState (ğ¿ ((âˆ§) ((âˆ§) (ğ¿ ((âˆ§) ((âˆ§) â„• ğ”¹) ShareInfo)) ShareInfo) ValMPC))
iStateNextLocL :: (âŸ¢) IState â„¤64
iStateStoreL :: (âŸ¢) IState Store
Ï‰â‚€ :: IState
data ResEv
ResEv :: ğ”¹ -> Prot -> ğ‘ƒ PrinVal -> ğ‘ƒ PrinVal -> ğ‘ƒ PrinVal -> ğ•Š -> ğ•Š -> ğ•Š -> ğ•Š -> â„• -> ResEv
[resEvZK] :: ResEv -> ğ”¹
[resEvProt] :: ResEv -> Prot
[resEvPrins] :: ResEv -> ğ‘ƒ PrinVal
[resEvPrinsFrom] :: ResEv -> ğ‘ƒ PrinVal
[resEvPrinsTo] :: ResEv -> ğ‘ƒ PrinVal
[resEvType] :: ResEv -> ğ•Š
[resEvTypeFrom] :: ResEv -> ğ•Š
[resEvTypeTo] :: ResEv -> ğ•Š
[resEvOp] :: ResEv -> ğ•Š
[resEvMd] :: ResEv -> â„•
resEvMdL :: (âŸ¢) ResEv â„•
resEvOpL :: (âŸ¢) ResEv ğ•Š
resEvTypeToL :: (âŸ¢) ResEv ğ•Š
resEvTypeFromL :: (âŸ¢) ResEv ğ•Š
resEvTypeL :: (âŸ¢) ResEv ğ•Š
resEvPrinsToL :: (âŸ¢) ResEv (ğ‘ƒ PrinVal)
resEvPrinsFromL :: (âŸ¢) ResEv (ğ‘ƒ PrinVal)
resEvPrinsL :: (âŸ¢) ResEv (ğ‘ƒ PrinVal)
resEvProtL :: (âŸ¢) ResEv Prot
resEvZKL :: (âŸ¢) ResEv ğ”¹
data IOut
IOut :: (ResEv â‡° â„•) -> IOut
[iOutResEvs] :: IOut -> ResEv â‡° â„•
iOutResEvsL :: (âŸ¢) IOut ((â‡°) ResEv â„•)
data IErrorClass
SyntaxIError :: IErrorClass
TypeIError :: IErrorClass
NotImplementedIError :: IErrorClass
InternalIError :: IErrorClass
data IError
IError :: ğ‘‚ FullContext -> CallStack -> IErrorClass -> Doc -> IError
[iErrorSource] :: IError -> ğ‘‚ FullContext
[iErrorCallStack] :: IError -> CallStack
[iErrorClass] :: IError -> IErrorClass
[iErrorMsg] :: IError -> Doc
throwIErrorCxt :: (Monad m, MonadReader ICxt m, MonadError IError m, STACK) => IErrorClass -> ğ•Š -> ğ¿ (ğ•Š âˆ§ Doc) -> m a
throwIError :: (Monad m, MonadError IError m, STACK) => ğ‘‚ FullContext -> IErrorClass -> ğ•Š -> ğ¿ (ğ•Š âˆ§ Doc) -> m a
guardErr :: (Monad m, MonadError IError m) => Bool -> m () -> m ()
errorğ‘‚ :: (Monad m, MonadError IError m) => ğ‘‚ a -> m a -> m a
data ITLState
ITLState :: (Prin â‡° PrinKind) -> Env -> IState -> ITLState
[itlStateDeclPrins] :: ITLState -> Prin â‡° PrinKind
[itlStateEnv] :: ITLState -> Env
[itlStateExp] :: ITLState -> IState
itlStateExpL :: (âŸ¢) ITLState IState
itlStateEnvL :: (âŸ¢) ITLState Env
itlStateDeclPrinsL :: (âŸ¢) ITLState ((â‡°) Prin PrinKind)
Ï‰tlâ‚€ :: ITLState
newtype IM a
IM :: RWST ICxt IOut IState (ErrorT IError IO) a -> IM a
[unIM] :: IM a -> RWST ICxt IOut IState (ErrorT IError IO) a
mkIM :: (ICxt -> IState -> IO (IError âˆ¨ ((IState âˆ§ IOut) âˆ§ a))) -> IM a
runIM :: ICxt -> IState -> IM a -> IO (IError âˆ¨ ((IState âˆ§ IOut) âˆ§ a))
newtype ITLM a
ITLM :: RWST IParams IOut ITLState (ErrorT IError IO) a -> ITLM a
[unITLM] :: ITLM a -> RWST IParams IOut ITLState (ErrorT IError IO) a
printError :: IError -> IO ()
mkITLM :: (IParams -> ITLState -> IO (IError âˆ¨ ((ITLState âˆ§ IOut) âˆ§ a))) -> ITLM a
runITLM :: IParams -> ITLState -> ITLM a -> IO (IError âˆ¨ ((ITLState âˆ§ IOut) âˆ§ a))
runITLMIO :: IParams -> ITLState -> ğ•Š -> ITLM a -> IO ((ITLState âˆ§ IOut) âˆ§ a)
evalITLM :: IParams -> ITLState -> ITLM a -> IO (IError âˆ¨ a)
evalITLMIO :: IParams -> ITLState -> ğ•Š -> ITLM a -> IO a
asTLM :: IM a -> ITLM a
instance UVMHS.Core.Effects.MonadIO PSL.Interpreter.Types.ITLM
instance UVMHS.Core.Effects.MonadError PSL.Interpreter.Types.IError PSL.Interpreter.Types.ITLM
instance UVMHS.Core.Effects.MonadState PSL.Interpreter.Types.ITLState PSL.Interpreter.Types.ITLM
instance UVMHS.Core.Effects.MonadWriter PSL.Interpreter.Types.IOut PSL.Interpreter.Types.ITLM
instance UVMHS.Core.Effects.MonadReader PSL.Interpreter.Types.IParams PSL.Interpreter.Types.ITLM
instance UVMHS.Core.Classes.Monad.Monad PSL.Interpreter.Types.ITLM
instance UVMHS.Core.Classes.Monad.Bind PSL.Interpreter.Types.ITLM
instance UVMHS.Core.Classes.Monad.Return PSL.Interpreter.Types.ITLM
instance UVMHS.Core.Classes.Functor.Functor PSL.Interpreter.Types.ITLM
instance UVMHS.Core.Effects.MonadIO PSL.Interpreter.Types.IM
instance UVMHS.Core.Effects.MonadError PSL.Interpreter.Types.IError PSL.Interpreter.Types.IM
instance UVMHS.Core.Effects.MonadState PSL.Interpreter.Types.IState PSL.Interpreter.Types.IM
instance UVMHS.Core.Effects.MonadWriter PSL.Interpreter.Types.IOut PSL.Interpreter.Types.IM
instance UVMHS.Core.Effects.MonadReader PSL.Interpreter.Types.ICxt PSL.Interpreter.Types.IM
instance UVMHS.Core.Classes.Monad.Monad PSL.Interpreter.Types.IM
instance UVMHS.Core.Classes.Monad.Bind PSL.Interpreter.Types.IM
instance UVMHS.Core.Classes.Monad.Return PSL.Interpreter.Types.IM
instance UVMHS.Core.Classes.Functor.Functor PSL.Interpreter.Types.IM
instance (UVMHS.Lib.Pretty.Core.Pretty (PSL.Syntax.Prin UVMHS.Core.Init.â‡° PSL.Syntax.PrinKind), UVMHS.Lib.Pretty.Core.Pretty PSL.Interpreter.Types.Env, UVMHS.Lib.Pretty.Core.Pretty PSL.Interpreter.Types.IState) => UVMHS.Lib.Pretty.Core.Pretty PSL.Interpreter.Types.ITLState
instance GHC.Show.Show PSL.Interpreter.Types.ITLState
instance GHC.Classes.Ord PSL.Interpreter.Types.ITLState
instance GHC.Classes.Eq PSL.Interpreter.Types.ITLState
instance UVMHS.Lib.Pretty.Core.Pretty PSL.Interpreter.Types.IErrorClass
instance GHC.Show.Show PSL.Interpreter.Types.IErrorClass
instance GHC.Classes.Ord PSL.Interpreter.Types.IErrorClass
instance GHC.Classes.Eq PSL.Interpreter.Types.IErrorClass
instance UVMHS.Core.Classes.Monoid.Null PSL.Interpreter.Types.IOut
instance UVMHS.Core.Classes.Monoid.Append PSL.Interpreter.Types.IOut
instance UVMHS.Core.Classes.Monoid.Monoid PSL.Interpreter.Types.IOut
instance UVMHS.Lib.Pretty.Core.Pretty (PSL.Interpreter.Types.ResEv UVMHS.Core.Init.â‡° UVMHS.Core.Init.â„•) => UVMHS.Lib.Pretty.Core.Pretty PSL.Interpreter.Types.IOut
instance GHC.Show.Show PSL.Interpreter.Types.IOut
instance (UVMHS.Lib.Pretty.Core.Pretty UVMHS.Core.Init.ğ”¹, UVMHS.Lib.Pretty.Core.Pretty PSL.Syntax.Prot, UVMHS.Lib.Pretty.Core.Pretty (UVMHS.Core.Init.ğ‘ƒ PSL.Syntax.PrinVal), UVMHS.Lib.Pretty.Core.Pretty UVMHS.Core.Init.ğ•Š, UVMHS.Lib.Pretty.Core.Pretty UVMHS.Core.Init.â„•) => UVMHS.Lib.Pretty.Core.Pretty PSL.Interpreter.Types.ResEv
instance GHC.Show.Show PSL.Interpreter.Types.ResEv
instance GHC.Classes.Ord PSL.Interpreter.Types.ResEv
instance GHC.Classes.Eq PSL.Interpreter.Types.ResEv
instance (UVMHS.Lib.Pretty.Core.Pretty PSL.Interpreter.Types.Store, UVMHS.Lib.Pretty.Core.Pretty UVMHS.Core.Init.â„¤64, UVMHS.Lib.Pretty.Core.Pretty (UVMHS.Core.Init.ğ¿ ((UVMHS.Core.Init.ğ¿ ((UVMHS.Core.Init.â„• UVMHS.Core.Init.âˆ§ UVMHS.Core.Init.ğ”¹) UVMHS.Core.Init.âˆ§ PSL.Interpreter.Types.ShareInfo) UVMHS.Core.Init.âˆ§ PSL.Interpreter.Types.ShareInfo) UVMHS.Core.Init.âˆ§ PSL.Interpreter.Types.ValMPC))) => UVMHS.Lib.Pretty.Core.Pretty PSL.Interpreter.Types.IState
instance GHC.Show.Show PSL.Interpreter.Types.IState
instance GHC.Classes.Ord PSL.Interpreter.Types.IState
instance GHC.Classes.Eq PSL.Interpreter.Types.IState
instance (UVMHS.Lib.Pretty.Core.Pretty PSL.Interpreter.Types.IParams, UVMHS.Lib.Pretty.Core.Pretty (UVMHS.Core.Init.ğ‘‚ UVMHS.Lib.Parser.ParserContext.FullContext), UVMHS.Lib.Pretty.Core.Pretty (PSL.Syntax.Prin UVMHS.Core.Init.â‡° PSL.Syntax.PrinKind), UVMHS.Lib.Pretty.Core.Pretty PSL.Interpreter.Types.Env, UVMHS.Lib.Pretty.Core.Pretty PSL.Syntax.Mode, UVMHS.Lib.Pretty.Core.Pretty (UVMHS.Core.Init.ğ¿ ((UVMHS.Core.Init.â„• UVMHS.Core.Init.âˆ§ UVMHS.Core.Init.ğ”¹) UVMHS.Core.Init.âˆ§ PSL.Interpreter.Types.ShareInfo))) => UVMHS.Lib.Pretty.Core.Pretty PSL.Interpreter.Types.ICxt
instance GHC.Show.Show PSL.Interpreter.Types.ICxt
instance (UVMHS.Lib.Pretty.Core.Pretty UVMHS.Core.Init.ğ”¹, UVMHS.Lib.Pretty.Core.Pretty (UVMHS.Core.Init.ğ•Š UVMHS.Core.Init.â‡° UVMHS.Core.Init.ğ‘ƒ PSL.Syntax.PrinVal)) => UVMHS.Lib.Pretty.Core.Pretty PSL.Interpreter.Types.IParams
instance GHC.Show.Show PSL.Interpreter.Types.IParams
instance GHC.Classes.Ord PSL.Interpreter.Types.IParams
instance GHC.Classes.Eq PSL.Interpreter.Types.IParams
instance (UVMHS.Lib.Pretty.Core.Pretty UVMHS.Core.Init.ğ”¹, UVMHS.Lib.Pretty.Core.Pretty PSL.Syntax.Prot, UVMHS.Lib.Pretty.Core.Pretty (UVMHS.Core.Init.ğ‘ƒ PSL.Syntax.PrinVal)) => UVMHS.Lib.Pretty.Core.Pretty PSL.Interpreter.Types.ShareInfo
instance GHC.Show.Show PSL.Interpreter.Types.ShareInfo
instance GHC.Classes.Ord PSL.Interpreter.Types.ShareInfo
instance GHC.Classes.Eq PSL.Interpreter.Types.ShareInfo
instance GHC.Show.Show PSL.Interpreter.Types.Val
instance GHC.Classes.Ord PSL.Interpreter.Types.Val
instance GHC.Classes.Eq PSL.Interpreter.Types.Val
instance GHC.Show.Show PSL.Interpreter.Types.ValP
instance GHC.Classes.Ord PSL.Interpreter.Types.ValP
instance GHC.Classes.Eq PSL.Interpreter.Types.ValP
instance GHC.Show.Show PSL.Interpreter.Types.ValMPC
instance GHC.Classes.Ord PSL.Interpreter.Types.ValMPC
instance GHC.Classes.Eq PSL.Interpreter.Types.ValMPC
instance GHC.Show.Show PSL.Interpreter.Types.BaseValMPC
instance GHC.Classes.Ord PSL.Interpreter.Types.BaseValMPC
instance GHC.Classes.Eq PSL.Interpreter.Types.BaseValMPC

module PSL.Interpreter.Truncating
trNat :: â„• -> â„• -> â„•
trPrNat :: IPrecision -> â„• -> â„•
buNat :: â„• -> â„• -> â„•
buPrNat :: IPrecision -> â„• -> â„•
trInt :: â„• -> â„¤ -> â„¤
trPrInt :: IPrecision -> â„¤ -> â„¤

module PSL.Interpreter.Pretty
levelIF :: â„•64
levelLAM :: â„•64
levelLET :: â„•64
levelPAR :: â„•64
levelUPDATE :: â„•64
levelCOMMA :: â„•64
levelASCR :: â„•64
levelCONS :: â„•64
levelREVEAL :: â„•64
levelCOND :: â„•64
levelCOMPARE :: â„•64
levelARROW :: â„•64
levelPLUS :: â„•64
levelTIMES :: â„•64
levelEXP :: â„•64
levelAPP :: â„•64
levelDEREF :: â„•64
levelACCESS :: â„•64
levelMODE :: â„•64
ppBoolPSL :: ğ”¹ -> Doc
ppNatPSL :: IPrecision -> â„• -> Doc
ppIntPSL :: IPrecision -> â„¤ -> Doc
ppFltPSL :: FPrecision -> ğ”» -> Doc
ppListPSL :: ğ¿ ValP -> Doc
ppArrayPSL :: ğ• ValP -> Doc
ppISecPSL :: (PrinVal â‡° Val) -> Doc
asListVP :: ValP -> ğ‘‚ (ğ¿ ValP âˆ§ Mode)
asListV :: Val -> ğ‘‚ (ğ¿ ValP âˆ§ ğ‘‚ Mode)
asNtupVP :: ValP -> ğ¼ ValP
ppPreF :: (ğ¼ Doc -> Doc) -> â„•64 -> Doc -> Doc -> Doc
ppPostF :: (ğ¼ Doc -> Doc) -> â„•64 -> Doc -> Doc -> Doc
ppInflF :: (ğ¼ Doc -> Doc) -> â„•64 -> Doc -> Doc -> Doc -> Doc
ppTight :: ToIter Doc t => t -> Doc
instance UVMHS.Lib.Pretty.Core.Pretty PSL.Syntax.Prot
instance UVMHS.Lib.Pretty.Core.Pretty PSL.Syntax.IPrecision
instance UVMHS.Lib.Pretty.Core.Pretty PSL.Syntax.FPrecision
instance UVMHS.Lib.Pretty.Core.Pretty PSL.Syntax.Mode
instance UVMHS.Lib.Pretty.Core.Pretty PSL.Interpreter.Types.Val
instance UVMHS.Lib.Pretty.Core.Pretty PSL.Syntax.PrinVal
instance UVMHS.Lib.Pretty.Core.Pretty PSL.Syntax.PrinExpVal
instance UVMHS.Lib.Pretty.Core.Pretty PSL.Interpreter.Types.ValP
instance UVMHS.Lib.Pretty.Core.Pretty PSL.Interpreter.Types.ValMPC
instance UVMHS.Lib.Pretty.Core.Pretty PSL.Interpreter.Types.BaseValMPC

module PSL.Parser
lexer :: Lexer CharClass â„‚ TokenClassBasic â„•64 TokenBasic
pKind :: CParser TokenBasic Kind
pPrin :: CParser TokenBasic ğ•
pPrinExp :: CParser TokenBasic PrinExp
pPrins :: CParser TokenBasic (ğ¿ PrinExp)
pPrinExps :: CParser TokenBasic (ğ¿ PrinExp)
pConstr :: CParser TokenBasic Constr
pEMode :: CParser TokenBasic EMode
pEffect :: CParser TokenBasic Effect
pTVar :: CParser TokenBasic TVar
pIPrecision :: CParser TokenBasic IPrecision
pFPrecision :: CParser TokenBasic FPrecision
pType :: CParser TokenBasic Type
pBool :: CParser TokenBasic ğ”¹
pProt :: CParser TokenBasic Prot
pVar :: CParser TokenBasic Var
pPat :: CParser TokenBasic Pat
pExp :: CParser TokenBasic Exp
pTL :: CParser TokenBasic TL
cpTLs :: CParser TokenBasic (ğ¿ TL)
testParserExample :: ğ•Š -> IO ()
testParser :: IO ()

module PSL.Interpreter.Json
iprecisionSuffix :: IPrecision -> ğ•Š
fprecisionSuffix :: FPrecision -> ğ•Š
getType :: Val -> ğ•Š
getTypeMPC :: ValMPC -> ğ•Š
getTypeBaseMPC :: BaseValMPC -> ğ•Š
stringProtocol :: Prot -> ğ•Š
jsonPrinVal :: PrinVal -> ğ•Š
jsonPrins :: ğ‘ƒ PrinVal -> Value
jsonEvent :: ResEv -> â„• -> Value
jsonEvents :: ToIter (ResEv âˆ§ â„•) t => t -> Value

module PSL.Interpreter.Primitives
valWithType :: Val -> Val âˆ§ ğ•Š
tnat :: IPrecision -> ğ•Š
tint :: IPrecision -> ğ•Š
tflt :: FPrecision -> ğ•Š
tboo :: ğ•Š
tprn :: ğ•Š
interpPrim :: STACK => Op -> ğ¿ BaseValMPC -> IM ((ğ•Š âˆ§ ğ•Š) âˆ§ BaseValMPC)
opName :: Op -> ğ•Š
multDepth :: Prot -> Op -> â„•
multDepthShareInfo :: Op -> ShareInfo -> â„•

module PSL.Interpreter.Access
restrictMode :: STACK => Mode -> IM a -> IM a
introValP :: STACK => Val -> IM ValP
locValP :: STACK => â„¤64 -> IM ValP
elimLocV :: STACK => Val -> IM â„¤64
elimValP :: STACK => ValP -> IM Val
restrictValP :: STACK => ValP -> IM ValP
restrictValPRecVal :: STACK => Val -> IM Val
joinShareInfo :: STACK => ShareInfo -> ShareInfo -> IM ShareInfo
joinShareInfos :: (STACK, ToIter ShareInfo t) => t -> IM ShareInfo
unShareValP :: STACK => ValP -> IM (ShareInfo âˆ§ ValMPC)
unShareValPMode :: STACK => Mode -> ValP -> IM (ShareInfo âˆ§ ValMPC)
unShareValMode :: STACK => Mode -> Val -> IM (ShareInfo âˆ§ ValMPC)
unShareValPs :: STACK => ğ¿ ValP -> IM (ShareInfo âˆ§ ğ¿ ValMPC)
reShareValP :: STACK => ValMPC -> ShareInfo -> IM ValP
reShareValPShared :: STACK => ğ”¹ -> Prot -> ğ‘ƒ PrinVal -> ValMPC -> IM ValP
mpcFrValP :: STACK => ValP -> IM ValMPC
mpcFrValPBaseVals :: STACK => ValP -> (BaseValMPC -> IM ()) -> IM ValMPC
mpcFrValPFWith :: STACK => (BaseValMPC -> IM ()) -> (ğ”¹ -> Prot -> ğ‘ƒ PrinVal -> ValMPC -> IM ()) -> ValP -> IM ValMPC
mpcFrValFWith :: STACK => (BaseValMPC -> IM ()) -> (ğ”¹ -> Prot -> ğ‘ƒ PrinVal -> ValMPC -> IM ()) -> Val -> IM ValMPC
eachBaseValWith :: (â„• -> BaseValMPC -> IM ()) -> ValMPC -> IM ()
eachBaseVal :: ValMPC -> (â„• -> BaseValMPC -> IM ()) -> IM ()
valFrMPC :: STACK => ValMPC -> IM ValP
valFrMPCF :: STACK => ValMPC -> (â„• -> BaseValMPC -> IM ()) -> IM ValP
valFrMPCFWith :: STACK => (â„• -> BaseValMPC -> IM ()) -> ValMPC -> IM ValP
valFrBaseMPC :: STACK => BaseValMPC -> IM ValP
revealValP :: STACK => ğ”¹ -> ğ‘ƒ PrinVal -> ValP -> IM ValP
revealVal :: STACK => ğ”¹ -> ğ‘ƒ PrinVal -> Val -> IM ValP

module PSL.Interpreter.PrinExp
interpPrinVar :: STACK => ğ• -> IM PrinExpVal
interpPrinExp :: STACK => PrinExp -> IM PrinExpVal
interpPrinExpSingle :: STACK => PrinExp -> IM PrinVal
prinExpVals :: STACK => PrinExpVal -> IM (ğ‘ƒ PrinVal)
prinExpValss :: (STACK, ToIter PrinExpVal t) => t -> IM (ğ‘ƒ PrinVal)

module PSL.TypeChecker
type CTyEnv = TVar â‡° Kind
type CTmDec = Var â‡° Type
type CTmEnv = Var â‡° Type
type CTLTmEnv = Var â‡° Exp âˆ§ Type
type CTLDefns = Var â‡° Exp
data CTLState
CTLState :: (PrinExp â‡° PrinKind) -> CTyEnv -> CTyEnv -> CTmDec -> CTLTmEnv -> CTLDefns -> CTLState
[ctlStatePrins] :: CTLState -> PrinExp â‡° PrinKind
[ctlStateTyDec] :: CTLState -> CTyEnv
[ctlStateTyEnv] :: CTLState -> CTyEnv
[ctlStateTmDec] :: CTLState -> CTmDec
[ctlStateTmEnv] :: CTLState -> CTLTmEnv
[ctlStateDefns] :: CTLState -> CTLDefns
ctlStateDefnsL :: (âŸ¢) CTLState CTLDefns
ctlStateTmEnvL :: (âŸ¢) CTLState CTLTmEnv
ctlStateTmDecL :: (âŸ¢) CTLState CTmDec
ctlStateTyEnvL :: (âŸ¢) CTLState CTyEnv
ctlStateTyDecL :: (âŸ¢) CTLState CTyEnv
ctlStatePrinsL :: (âŸ¢) CTLState ((â‡°) PrinExp PrinKind)
Ïƒtlâ‚€ :: CTLState
data CCxt
CCxt :: ğ‘‚ FullContext -> (PrinExp â‡° PrinKind) -> CTyEnv -> CTyEnv -> CTmDec -> CTmEnv -> Mode -> CCxt
[cCxtSource] :: CCxt -> ğ‘‚ FullContext
[cCxtPrins] :: CCxt -> PrinExp â‡° PrinKind
[cCxtTyDec] :: CCxt -> CTyEnv
[cCxtTyEnv] :: CCxt -> CTyEnv
[cCxtTmDec] :: CCxt -> CTmDec
[cCxtTmEnv] :: CCxt -> CTmEnv
[cCxtMode] :: CCxt -> Mode
cCxtModeL :: (âŸ¢) CCxt Mode
cCxtTmEnvL :: (âŸ¢) CCxt CTmEnv
cCxtTmDecL :: (âŸ¢) CCxt CTmDec
cCxtTyEnvL :: (âŸ¢) CCxt CTyEnv
cCxtTyDecL :: (âŸ¢) CCxt CTyEnv
cCxtPrinsL :: (âŸ¢) CCxt ((â‡°) PrinExp PrinKind)
cCxtSourceL :: (âŸ¢) CCxt (ğ‘‚ FullContext)
Î¾â‚€ :: CCxt
data COut
COut :: Effect -> COut
[cOutEff] :: COut -> Effect
cOutEffL :: (âŸ¢) COut Effect
data CErrorClass
SyntaxCError :: CErrorClass
TypeCError :: CErrorClass
NotImplementedCError :: CErrorClass
InternalCError :: CErrorClass
data CError
CError :: ğ‘‚ FullContext -> CallStack -> CErrorClass -> Doc -> CError
[cErrorSource] :: CError -> ğ‘‚ FullContext
[cErrorCallStack] :: CError -> CallStack
[cErrorClass] :: CError -> CErrorClass
[cErrorMsg] :: CError -> Doc
throwCErrorCxt :: (Monad m, MonadReader CCxt m, MonadError CError m, STACK) => CErrorClass -> ğ•Š -> ğ¿ (ğ•Š âˆ§ Doc) -> m a
throwCError :: (Monad m, MonadError CError m, STACK) => ğ‘‚ FullContext -> CErrorClass -> ğ•Š -> ğ¿ (ğ•Š âˆ§ Doc) -> m a
newtype CTLM a
CTLM :: RWST () () CTLState (ErrorT CError ID) a -> CTLM a
[unCTLM] :: CTLM a -> RWST () () CTLState (ErrorT CError ID) a
mkCTLM :: (CTLState -> CError âˆ¨ (CTLState âˆ§ a)) -> CTLM a
runCTLM :: CTLState -> CTLM a -> CError âˆ¨ (CTLState âˆ§ a)
evalCTLM :: CTLState -> CTLM a -> CError âˆ¨ a
evalCTLMIO :: CTLState -> CTLM a -> IO a
instance UVMHS.Lib.Pretty.Core.Pretty (UVMHS.Core.Monads.RWST () () PSL.TypeChecker.CTLState (UVMHS.Core.Monads.ErrorT PSL.TypeChecker.CError UVMHS.Core.Monads.ID) a) => UVMHS.Lib.Pretty.Core.Pretty (PSL.TypeChecker.CTLM a)
instance UVMHS.Core.Effects.MonadError PSL.TypeChecker.CError PSL.TypeChecker.CTLM
instance UVMHS.Core.Effects.MonadState PSL.TypeChecker.CTLState PSL.TypeChecker.CTLM
instance UVMHS.Core.Effects.MonadWriter () PSL.TypeChecker.CTLM
instance UVMHS.Core.Effects.MonadReader () PSL.TypeChecker.CTLM
instance UVMHS.Core.Classes.Monad.Monad PSL.TypeChecker.CTLM
instance UVMHS.Core.Classes.Monad.Bind PSL.TypeChecker.CTLM
instance UVMHS.Core.Classes.Monad.Return PSL.TypeChecker.CTLM
instance UVMHS.Core.Classes.Functor.Functor PSL.TypeChecker.CTLM
instance UVMHS.Lib.Pretty.Core.Pretty PSL.TypeChecker.CErrorClass
instance GHC.Show.Show PSL.TypeChecker.CErrorClass
instance GHC.Classes.Ord PSL.TypeChecker.CErrorClass
instance GHC.Classes.Eq PSL.TypeChecker.CErrorClass
instance UVMHS.Lib.Pretty.Core.Pretty PSL.Syntax.Effect => UVMHS.Lib.Pretty.Core.Pretty PSL.TypeChecker.COut
instance GHC.Show.Show PSL.TypeChecker.COut
instance GHC.Classes.Ord PSL.TypeChecker.COut
instance GHC.Classes.Eq PSL.TypeChecker.COut
instance (UVMHS.Lib.Pretty.Core.Pretty (PSL.Syntax.PrinExp UVMHS.Core.Init.â‡° PSL.Syntax.PrinKind), UVMHS.Lib.Pretty.Core.Pretty PSL.TypeChecker.CTyEnv, UVMHS.Lib.Pretty.Core.Pretty PSL.TypeChecker.CTmDec, UVMHS.Lib.Pretty.Core.Pretty PSL.TypeChecker.CTLTmEnv, UVMHS.Lib.Pretty.Core.Pretty PSL.TypeChecker.CTLDefns) => UVMHS.Lib.Pretty.Core.Pretty PSL.TypeChecker.CTLState
instance GHC.Show.Show PSL.TypeChecker.CTLState
instance GHC.Classes.Ord PSL.TypeChecker.CTLState
instance GHC.Classes.Eq PSL.TypeChecker.CTLState

module PSL.Config
psl_VERSION :: ğ•Š
datapath :: ğ•Š -> IO ğ•Š

module PSL.Interpreter.ReadType
primRead :: Read a => ğ•Š -> ğ‘‚ (ğ•Š âˆ§ a)
prinDataPath :: PrinVal -> IM ğ•Š
parseInputType :: STACK => PrinVal -> Type -> ğ•Š -> IM (ğ•Š âˆ§ Val)
readType :: STACK => PrinVal -> Type -> ğ•Š -> IM Val
serializeVal :: Val -> IM (ğ¼ ğ•Š)
writeVal :: STACK => PrinVal -> Val -> ğ•Š -> IM ()

module PSL.Interpreter
interpVar :: STACK => Var -> IM ValP
bindVar :: STACK => Var -> ValP -> IM a -> IM a
bindPat :: STACK => Pat -> ValP -> IM a -> IM a
bindPatO :: STACK => Pat -> ValP -> FailT IM (IM a -> IM a)
data MatchState
NoMatch :: MatchState
LeftMatch :: MatchState
RightMatch :: MatchState
bindPatMPC :: STACK => ShareInfo -> Pat -> ValMPC -> ğ‘‚ (IM (ShareInfo âˆ§ ValMPC) -> IM (ShareInfo âˆ§ ValMPC))
interpCase :: STACK => ValP -> ğ¿ (Pat âˆ§ Exp) -> IM ValP
interpCaseO :: STACK => ValP -> ğ¿ (Pat âˆ§ Exp) -> FailT IM ValP
interpApp :: STACK => ValP -> ValP -> IM ValP
wrapInterp :: STACK => (ExpR -> IM ValP) -> Exp -> IM ValP
reportPrimop :: STACK => ğ•Š -> ğ•Š -> ğ•Š -> â„• -> ShareInfo -> IM ()
interpReportPrim :: Op -> â„• -> ShareInfo -> ğ¿ BaseValMPC -> IM (â„• âˆ§ BaseValMPC)
defaultBaseVal :: STACK => BaseValMPC -> BaseValMPC
sumMPCVal :: STACK => ShareInfo -> ValMPC -> ValMPC -> IM ValMPC
muxMPCVal :: STACK => â„• -> ShareInfo -> ğ”¹ -> ValMPC -> ValMPC -> IM ValMPC
interpExp :: STACK => Exp -> IM ValP
interpTL :: TL -> ITLM ()
interpTLs :: ğ¿ TL -> ITLM ()
data Options
Options :: ğ”¹ -> ğ”¹ -> ğ”¹ -> ğ”¹ -> ğ‘‚ â„• -> ğ•Š -> ğ•Š -> Options
[optVersion] :: Options -> ğ”¹
[optHelp] :: Options -> ğ”¹
[optDoResources] :: Options -> ğ”¹
[optJustPrint] :: Options -> ğ”¹
[optRandomSeed] :: Options -> ğ‘‚ â„•
[optTestsPath] :: Options -> ğ•Š
[optLibPath] :: Options -> ğ•Š
optLibPathL :: (âŸ¢) Options ğ•Š
optTestsPathL :: (âŸ¢) Options ğ•Š
optRandomSeedL :: (âŸ¢) Options (ğ‘‚ â„•)
optJustPrintL :: (âŸ¢) Options ğ”¹
optDoResourcesL :: (âŸ¢) Options ğ”¹
optHelpL :: (âŸ¢) Options ğ”¹
optVersionL :: (âŸ¢) Options ğ”¹
optionsâ‚€ :: IO Options
usageInfoTop :: [OptDescr (Options -> Options)]
usageInfoRun :: [OptDescr (Options -> Options)]
usageInfoExample :: [OptDescr (Options -> Options)]
usageInfoTest :: [OptDescr (Options -> Options)]
initializeIO :: Options -> IO ()
initializeEnv :: Options -> IParams
interpretFile :: IParams -> ITLState -> ğ•Š -> ğ•Š -> IO (ITLState âˆ§ IOut)
interpretFileMain :: IParams -> ITLState -> ğ•Š -> ğ•Š -> IO (ValP âˆ§ ğ‘‚ ValP)
printFileMain :: ğ•Š -> IO ()
parseOptions :: IO (Options âˆ§ [ğ•Š])
pslMainRun :: IO ()
pslMainExample :: IO ()
pslMainTest :: IO ()
pslMainInfo :: IO ()
interpreterMain :: IO ()
instance GHC.Show.Show PSL.Interpreter.Options
instance GHC.Classes.Ord PSL.Interpreter.Options
instance GHC.Classes.Eq PSL.Interpreter.Options

module PSL
mainDefaultArgs :: ğ¿ ğ•Š
main :: IO ()
mainDefault :: IO ()
