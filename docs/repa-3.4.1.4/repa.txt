-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | High performance, regular, shape polymorphic parallel arrays.
--   
--   Repa provides high performance, regular, multi-dimensional, shape
--   polymorphic parallel arrays. All numeric data is stored unboxed.
--   Functions written with the Repa combinators are automatically parallel
--   provided you supply +RTS -Nwhatever on the command line when running
--   the program.
@package repa
@version 3.4.1.4


-- | Gang Primitives.
module Data.Array.Repa.Eval.Gang

-- | This globally shared gang is auto-initialised at startup and shared by
--   all Repa computations.
--   
--   In a data parallel setting, it does not help to have multiple gangs
--   running at the same time. This is because a single data parallel
--   computation should already be able to keep all threads busy. If we had
--   multiple gangs running at the same time, then the system as a whole
--   would run slower as the gangs would contend for cache and thrash the
--   scheduler.
--   
--   If, due to laziness or otherwise, you try to start multiple parallel
--   Repa computations at the same time, then you will get the following
--   warning on stderr at runtime:
--   
--   <pre>
--   Data.Array.Repa: Performing nested parallel computation sequentially.
--       You've probably called the <tt>compute</tt> or <tt>copy</tt> function while another
--       instance was already running. This can happen if the second version
--       was suspended due to lazy evaluation. Use <tt>deepSeqArray</tt> to ensure that
--       each array is fully evaluated before you <tt>compute</tt> the next one.
--   </pre>
theGang :: Gang

-- | A <a>Gang</a> is a group of threads that execute arbitrary work
--   requests.
data Gang

-- | Fork a <a>Gang</a> with the given number of threads (at least 1).
forkGang :: Int -> IO Gang

-- | O(1). Yield the number of threads in the <a>Gang</a>.
gangSize :: Gang -> Int

-- | Issue work requests for the <a>Gang</a> and wait until they complete.
--   
--   If the gang is already busy then print a warning to <a>stderr</a> and
--   just run the actions sequentially in the requesting thread.
gangIO :: Gang -> (Int -> IO ()) -> IO ()

-- | Same as <a>gangIO</a> but in the <a>ST</a> monad.
gangST :: Gang -> (Int -> ST s ()) -> ST s ()
instance GHC.Show.Show Data.Array.Repa.Eval.Gang.Gang


-- | Class of types that can be used as array shapes and indices.
module Data.Array.Repa.Shape

-- | Class of types that can be used as array shapes and indices.
class Eq sh => Shape sh

-- | Get the number of dimensions in a shape.
rank :: Shape sh => sh -> Int

-- | The shape of an array of size zero, with a particular dimensionality.
zeroDim :: Shape sh => sh

-- | The shape of an array with size one, with a particular dimensionality.
unitDim :: Shape sh => sh

-- | Compute the intersection of two shapes.
intersectDim :: Shape sh => sh -> sh -> sh

-- | Add the coordinates of two shapes componentwise
addDim :: Shape sh => sh -> sh -> sh

-- | Get the total number of elements in an array with this shape.
size :: Shape sh => sh -> Int

-- | Check whether this shape is small enough so that its flat indices an
--   be represented as <a>Int</a>. If this returns <a>False</a> then your
--   array is too big. Mostly used for writing QuickCheck tests.
sizeIsValid :: Shape sh => sh -> Bool

-- | Convert an index into its equivalent flat, linear, row-major version.
toIndex :: Shape sh => sh -> sh -> Int

-- | Inverse of <a>toIndex</a>.
fromIndex :: Shape sh => sh -> Int -> sh

-- | Check whether an index is within a given shape.
inShapeRange :: Shape sh => sh -> sh -> sh -> Bool

-- | Convert a shape into its list of dimensions.
listOfShape :: Shape sh => sh -> [Int]

-- | Convert a list of dimensions to a shape
shapeOfList :: Shape sh => [Int] -> sh

-- | Ensure that a shape is completely evaluated.
deepSeq :: Shape sh => sh -> a -> a
infixr 0 `deepSeq`

-- | Check whether an index is a part of a given shape.
inShape :: forall sh. Shape sh => sh -> sh -> Bool

-- | Nicely format a shape as a string
showShape :: Shape sh => sh -> String


-- | Index types.
module Data.Array.Repa.Index

-- | An index of dimension zero
data Z
Z :: Z

-- | Our index type, used for both shapes and indices.
data tail :. head
(:.) :: !tail -> !head -> (:.) tail head
infixl 3 :.
infixl 3 :.
type DIM0 = Z
type DIM1 = DIM0 :. Int
type DIM2 = DIM1 :. Int
type DIM3 = DIM2 :. Int
type DIM4 = DIM3 :. Int
type DIM5 = DIM4 :. Int

-- | Helper for index construction.
--   
--   Use this instead of explicit constructors like <tt>(Z :. (x ::
--   Int))</tt>. The this is sometimes needed to ensure that <tt>x</tt> is
--   constrained to be in <tt>Int</tt>.
ix1 :: Int -> DIM1
ix2 :: Int -> Int -> DIM2
ix3 :: Int -> Int -> Int -> DIM3
ix4 :: Int -> Int -> Int -> Int -> DIM4
ix5 :: Int -> Int -> Int -> Int -> Int -> DIM5
instance (GHC.Classes.Ord tail, GHC.Classes.Ord head) => GHC.Classes.Ord (tail Data.Array.Repa.Index.:. head)
instance (GHC.Classes.Eq tail, GHC.Classes.Eq head) => GHC.Classes.Eq (tail Data.Array.Repa.Index.:. head)
instance (GHC.Read.Read tail, GHC.Read.Read head) => GHC.Read.Read (tail Data.Array.Repa.Index.:. head)
instance (GHC.Show.Show tail, GHC.Show.Show head) => GHC.Show.Show (tail Data.Array.Repa.Index.:. head)
instance GHC.Classes.Ord Data.Array.Repa.Index.Z
instance GHC.Classes.Eq Data.Array.Repa.Index.Z
instance GHC.Read.Read Data.Array.Repa.Index.Z
instance GHC.Show.Show Data.Array.Repa.Index.Z
instance Data.Array.Repa.Shape.Shape sh => Data.Array.Repa.Shape.Shape (sh Data.Array.Repa.Index.:. GHC.Types.Int)
instance Data.Array.Repa.Shape.Shape Data.Array.Repa.Index.Z

module Data.Array.Repa.Repr.HintSmall

-- | Hints that evaluating this array is only a small amount of work. It
--   will be evaluated sequentially in the main thread, instead of in
--   parallel on the gang. This avoids the associated scheduling overhead.
data S r1
data family Array r sh e

-- | Wrap an array with a smallness hint.
hintSmall :: Array r1 sh e -> Array (S r1) sh e
instance GHC.Show.Show (Data.Array.Repa.Base.Array r1 sh e) => GHC.Show.Show (Data.Array.Repa.Base.Array (Data.Array.Repa.Repr.HintSmall.S r1) sh e)
instance GHC.Read.Read (Data.Array.Repa.Base.Array r1 sh e) => GHC.Read.Read (Data.Array.Repa.Base.Array (Data.Array.Repa.Repr.HintSmall.S r1) sh e)
instance Data.Array.Repa.Base.Source r1 a => Data.Array.Repa.Base.Source (Data.Array.Repa.Repr.HintSmall.S r1) a
instance (Data.Array.Repa.Shape.Shape sh, Data.Array.Repa.Eval.Load.Load r1 sh e) => Data.Array.Repa.Eval.Load.Load (Data.Array.Repa.Repr.HintSmall.S r1) sh e
instance (Data.Array.Repa.Shape.Shape sh, Data.Array.Repa.Eval.Load.LoadRange r1 sh e) => Data.Array.Repa.Eval.Load.LoadRange (Data.Array.Repa.Repr.HintSmall.S r1) sh e

module Data.Array.Repa.Repr.Delayed

-- | Delayed arrays are represented as functions from the index to element
--   value.
--   
--   Every time you index into a delayed array the element at that position
--   is recomputed.
data D
data family Array r sh e

-- | O(1). Wrap a function as a delayed array.
fromFunction :: sh -> (sh -> a) -> Array D sh a

-- | O(1). Produce the extent of an array, and a function to retrieve an
--   arbitrary element.
toFunction :: (Shape sh, Source r1 a) => Array r1 sh a -> (sh, sh -> a)

-- | O(1). Delay an array. This wraps the internal representation to be a
--   function from indices to elements, so consumers don't need to worry
--   about what the previous representation was.
delay :: Shape sh => Source r e => Array r sh e -> Array D sh e
instance Data.Array.Repa.Base.Source Data.Array.Repa.Repr.Delayed.D a
instance Data.Array.Repa.Shape.Shape sh => Data.Array.Repa.Eval.Load.Load Data.Array.Repa.Repr.Delayed.D sh e
instance Data.Array.Repa.Eval.Elt.Elt e => Data.Array.Repa.Eval.Load.LoadRange Data.Array.Repa.Repr.Delayed.D Data.Array.Repa.Index.DIM2 e

module Data.Array.Repa.Repr.HintInterleave

-- | Hints that computing this array will be an unbalanced workload and
--   evaluation should be interleaved between the processors.
data I r1
data family Array r sh e

-- | Wrap an array with a unbalanced-ness hint.
hintInterleave :: Array r1 sh e -> Array (I r1) sh e
instance GHC.Show.Show (Data.Array.Repa.Base.Array r1 sh e) => GHC.Show.Show (Data.Array.Repa.Base.Array (Data.Array.Repa.Repr.HintInterleave.I r1) sh e)
instance GHC.Read.Read (Data.Array.Repa.Base.Array r1 sh e) => GHC.Read.Read (Data.Array.Repa.Base.Array (Data.Array.Repa.Repr.HintInterleave.I r1) sh e)
instance Data.Array.Repa.Base.Source r1 a => Data.Array.Repa.Base.Source (Data.Array.Repa.Repr.HintInterleave.I r1) a
instance (Data.Array.Repa.Shape.Shape sh, Data.Array.Repa.Eval.Load.Load Data.Array.Repa.Repr.Delayed.D sh e) => Data.Array.Repa.Eval.Load.Load (Data.Array.Repa.Repr.HintInterleave.I Data.Array.Repa.Repr.Delayed.D) sh e

module Data.Array.Repa.Repr.ForeignPtr

-- | Arrays represented as foreign buffers in the C heap.
data F
data family Array r sh e

-- | O(1). Wrap a <a>ForeignPtr</a> as an array.
fromForeignPtr :: Shape sh => sh -> ForeignPtr e -> Array F sh e

-- | O(1). Unpack a <a>ForeignPtr</a> from an array.
toForeignPtr :: Array F sh e -> ForeignPtr e

-- | Compute an array sequentially and write the elements into a foreign
--   buffer without intermediate copying. If you want to copy a
--   pre-existing manifest array to a foreign buffer then <a>delay</a> it
--   first.
computeIntoS :: (Load r1 sh e, Storable e) => ForeignPtr e -> Array r1 sh e -> IO ()

-- | Compute an array in parallel and write the elements into a foreign
--   buffer without intermediate copying. If you want to copy a
--   pre-existing manifest array to a foreign buffer then <a>delay</a> it
--   first.
computeIntoP :: (Load r1 sh e, Storable e) => ForeignPtr e -> Array r1 sh e -> IO ()
instance Foreign.Storable.Storable a => Data.Array.Repa.Base.Source Data.Array.Repa.Repr.ForeignPtr.F a
instance Foreign.Storable.Storable e => Data.Array.Repa.Eval.Target.Target Data.Array.Repa.Repr.ForeignPtr.F e

module Data.Array.Repa.Repr.ByteString

-- | Strict ByteStrings arrays are represented as ForeignPtr buffers of
--   Word8
data B
data family Array r sh e

-- | O(1). Wrap a <a>ByteString</a> as an array.
fromByteString :: sh -> ByteString -> Array B sh Word8

-- | O(1). Unpack a <a>ByteString</a> from an array.
toByteString :: Array B sh Word8 -> ByteString
instance GHC.Show.Show sh => GHC.Show.Show (Data.Array.Repa.Base.Array Data.Array.Repa.Repr.ByteString.B sh GHC.Word.Word8)
instance GHC.Read.Read sh => GHC.Read.Read (Data.Array.Repa.Base.Array Data.Array.Repa.Repr.ByteString.B sh GHC.Word.Word8)
instance Data.Array.Repa.Base.Source Data.Array.Repa.Repr.ByteString.B GHC.Word.Word8

module Data.Array.Repa.Operators.Traversal

-- | Unstructured traversal.
traverse :: forall r sh sh' a b. (Source r a, Shape sh) => Array r sh a -> (sh -> sh') -> ((sh -> a) -> sh' -> b) -> Array D sh' b

-- | Unstructured traversal.
unsafeTraverse :: forall r sh sh' a b. (Source r a, Shape sh) => Array r sh a -> (sh -> sh') -> ((sh -> a) -> sh' -> b) -> Array D sh' b

-- | Unstructured traversal over two arrays at once.
traverse2 :: forall r1 r2 sh sh' sh'' a b c. (Source r1 a, Source r2 b, Shape sh, Shape sh') => Array r1 sh a -> Array r2 sh' b -> (sh -> sh' -> sh'') -> ((sh -> a) -> (sh' -> b) -> sh'' -> c) -> Array D sh'' c

-- | Unstructured traversal over two arrays at once.
unsafeTraverse2 :: forall r1 r2 sh sh' sh'' a b c. (Source r1 a, Source r2 b, Shape sh, Shape sh') => Array r1 sh a -> Array r2 sh' b -> (sh -> sh' -> sh'') -> ((sh -> a) -> (sh' -> b) -> sh'' -> c) -> Array D sh'' c

-- | Unstructured traversal over three arrays at once.
traverse3 :: forall r1 r2 r3 sh1 sh2 sh3 sh4 a b c d. (Source r1 a, Source r2 b, Source r3 c, Shape sh1, Shape sh2, Shape sh3) => Array r1 sh1 a -> Array r2 sh2 b -> Array r3 sh3 c -> (sh1 -> sh2 -> sh3 -> sh4) -> ((sh1 -> a) -> (sh2 -> b) -> (sh3 -> c) -> sh4 -> d) -> Array D sh4 d

-- | Unstructured traversal over three arrays at once.
unsafeTraverse3 :: forall r1 r2 r3 sh1 sh2 sh3 sh4 a b c d. (Source r1 a, Source r2 b, Source r3 c, Shape sh1, Shape sh2, Shape sh3) => Array r1 sh1 a -> Array r2 sh2 b -> Array r3 sh3 c -> (sh1 -> sh2 -> sh3 -> sh4) -> ((sh1 -> a) -> (sh2 -> b) -> (sh3 -> c) -> sh4 -> d) -> Array D sh4 d

-- | Unstructured traversal over four arrays at once.
traverse4 :: forall r1 r2 r3 r4 sh1 sh2 sh3 sh4 sh5 a b c d e. (Source r1 a, Source r2 b, Source r3 c, Source r4 d, Shape sh1, Shape sh2, Shape sh3, Shape sh4) => Array r1 sh1 a -> Array r2 sh2 b -> Array r3 sh3 c -> Array r4 sh4 d -> (sh1 -> sh2 -> sh3 -> sh4 -> sh5) -> ((sh1 -> a) -> (sh2 -> b) -> (sh3 -> c) -> (sh4 -> d) -> sh5 -> e) -> Array D sh5 e

-- | Unstructured traversal over four arrays at once.
unsafeTraverse4 :: forall r1 r2 r3 r4 sh1 sh2 sh3 sh4 sh5 a b c d e. (Source r1 a, Source r2 b, Source r3 c, Source r4 d, Shape sh1, Shape sh2, Shape sh3, Shape sh4) => Array r1 sh1 a -> Array r2 sh2 b -> Array r3 sh3 c -> Array r4 sh4 d -> (sh1 -> sh2 -> sh3 -> sh4 -> sh5) -> ((sh1 -> a) -> (sh2 -> b) -> (sh3 -> c) -> (sh4 -> d) -> sh5 -> e) -> Array D sh5 e

module Data.Array.Repa.Operators.Interleave

-- | Interleave the elements of two arrays. All the input arrays must have
--   the same extent, else <a>error</a>. The lowest dimension of the result
--   array is twice the size of the inputs.
--   
--   <pre>
--   interleave2 a1 a2   b1 b2  =&gt;  a1 b1 a2 b2
--               a3 a4   b3 b4      a3 b3 a4 b4
--   </pre>
interleave2 :: (Shape sh, Source r1 a, Source r2 a) => Array r1 (sh :. Int) a -> Array r2 (sh :. Int) a -> Array D (sh :. Int) a

-- | Interleave the elements of three arrays.
interleave3 :: (Shape sh, Source r1 a, Source r2 a, Source r3 a) => Array r1 (sh :. Int) a -> Array r2 (sh :. Int) a -> Array r3 (sh :. Int) a -> Array D (sh :. Int) a

-- | Interleave the elements of four arrays.
interleave4 :: (Shape sh, Source r1 a, Source r2 a, Source r3 a, Source r4 a) => Array r1 (sh :. Int) a -> Array r2 (sh :. Int) a -> Array r3 (sh :. Int) a -> Array r4 (sh :. Int) a -> Array D (sh :. Int) a


-- | Low level interface to parallel array filling operators.
module Data.Array.Repa.Eval

-- | Element types that can be used with the blockwise filling functions.
--   
--   This class is mainly used to define the <a>touch</a> method. This is
--   used internally in the imeplementation of Repa to prevent let-binding
--   from being floated inappropriately by the GHC simplifier. Doing a
--   <a>seq</a> sometimes isn't enough, because the GHC simplifier can
--   erase these, and still move around the bindings.
class Elt a

-- | Place a demand on a value at a particular point in an IO computation.
touch :: Elt a => a -> IO ()

-- | Place a demand on a value at a particular point in an IO computation.
touch :: (Elt a, Generic a, GElt (Rep a)) => a -> IO ()

-- | Generic zero value, helpful for debugging.
zero :: Elt a => a

-- | Generic zero value, helpful for debugging.
zero :: (Elt a, Generic a, GElt (Rep a)) => a

-- | Generic one value, helpful for debugging.
one :: Elt a => a

-- | Generic one value, helpful for debugging.
one :: (Elt a, Generic a, GElt (Rep a)) => a

-- | Class of manifest array representations that can be constructed in
--   parallel.
class Target r e where {
    
    -- | Mutable version of the representation.
    data family MVec r e;
}

-- | Allocate a new mutable array of the given size.
newMVec :: Target r e => Int -> IO (MVec r e)

-- | Write an element into the mutable array.
unsafeWriteMVec :: Target r e => MVec r e -> Int -> e -> IO ()

-- | Freeze the mutable array into an immutable Repa array.
unsafeFreezeMVec :: Target r e => sh -> MVec r e -> IO (Array r sh e)

-- | Ensure the strucure of a mutable array is fully evaluated.
deepSeqMVec :: Target r e => MVec r e -> a -> a

-- | Ensure the array is still live at this point. Needed when the mutable
--   array is a ForeignPtr with a finalizer.
touchMVec :: Target r e => MVec r e -> IO ()

-- | Compute all elements defined by an array and write them to a manifest
--   target representation.
--   
--   Note that instances require that the source array to have a delayed
--   representation such as <tt>D</tt> or <tt>C</tt>. If you want to use a
--   pre-existing manifest array as the source then <tt>delay</tt> it
--   first.
class (Source r1 e, Shape sh) => Load r1 sh e

-- | Fill an entire array sequentially.
loadS :: (Load r1 sh e, Target r2 e) => Array r1 sh e -> MVec r2 e -> IO ()

-- | Fill an entire array in parallel.
loadP :: (Load r1 sh e, Target r2 e) => Array r1 sh e -> MVec r2 e -> IO ()

-- | Compute a range of elements defined by an array and write them to a
--   fillable representation.
class (Source r1 e, Shape sh) => LoadRange r1 sh e

-- | Fill a range of an array sequentially.
loadRangeS :: (LoadRange r1 sh e, Target r2 e) => Array r1 sh e -> MVec r2 e -> sh -> sh -> IO ()

-- | Fill a range of an array in parallel.
loadRangeP :: (LoadRange r1 sh e, Target r2 e) => Array r1 sh e -> MVec r2 e -> sh -> sh -> IO ()

-- | O(n). Construct a manifest array from a list.
fromList :: (Shape sh, Target r e) => sh -> [e] -> Array r sh e

-- | Sequential computation of array elements.
computeS :: (Load r1 sh e, Target r2 e) => Array r1 sh e -> Array r2 sh e

-- | Parallel computation of array elements.
--   
--   <ul>
--   <li>The source array must have a delayed representation like <a>D</a>,
--   <tt>C</tt> or <tt>P</tt>, and the result a manifest representation
--   like <tt>U</tt> or <tt>F</tt>.</li>
--   <li>If you want to copy data between manifest representations then use
--   <a>copyP</a> instead.</li>
--   <li>If you want to convert a manifest array back to a delayed
--   representation then use <a>delay</a> instead.</li>
--   </ul>
computeP :: (Load r1 sh e, Target r2 e, Source r2 e, Monad m) => Array r1 sh e -> m (Array r2 sh e)

-- | Suspended parallel computation of array elements.
--   
--   This version creates a thunk that will evaluate the array on demand.
--   If you force it when another parallel computation is already running
--   then you will get a runtime warning and evaluation will be sequential.
--   Use <a>deepSeqArray</a> and <a>now</a> to ensure that each array is
--   evaluated before proceeding to the next one.
--   
--   If unsure then just use the monadic version <a>computeP</a>. This one
--   ensures that each array is fully evaluated before continuing.
suspendedComputeP :: (Load r1 sh e, Target r2 e) => Array r1 sh e -> Array r2 sh e

-- | Sequential copying of arrays.
copyS :: (Source r1 e, Load D sh e, Target r2 e) => Array r1 sh e -> Array r2 sh e

-- | Parallel copying of arrays.
--   
--   <ul>
--   <li>This is a wrapper that delays an array before calling
--   <a>computeP</a>.</li>
--   <li>You can use it to copy manifest arrays between
--   representations.</li>
--   </ul>
copyP :: (Source r1 e, Source r2 e, Load D sh e, Target r2 e, Monad m) => Array r1 sh e -> m (Array r2 sh e)

-- | Suspended parallel copy of array elements.
suspendedCopyP :: (Source r1 e, Load D sh e, Target r2 e) => Array r1 sh e -> Array r2 sh e

-- | Monadic version of <a>deepSeqArray</a>.
--   
--   Forces an suspended array computation to be completed at this point in
--   a monadic computation.
--   
--   <pre>
--   do  let arr2 = suspendedComputeP arr1
--       ...
--       arr3 &lt;- now $ arr2
--       ...
--   </pre>
now :: (Shape sh, Source r e, Monad m) => Array r sh e -> m (Array r sh e)

-- | Fill something sequentially.
--   
--   <ul>
--   <li>The array is filled linearly from start to finish.</li>
--   </ul>
fillLinearS :: Int -> (Int -> a -> IO ()) -> (Int -> a) -> IO ()

-- | Fill something in parallel.
--   
--   <ul>
--   <li>The array is split into linear chunks, and each thread linearly
--   fills one chunk.</li>
--   </ul>
fillChunkedP :: Int -> (Int -> a -> IO ()) -> (Int -> a) -> IO ()

-- | Fill something in parallel, using a separate IO action for each
--   thread.
--   
--   <ul>
--   <li>The array is split into linear chunks, and each thread linearly
--   fills one chunk.</li>
--   </ul>
fillChunkedIOP :: Int -> (Int -> a -> IO ()) -> (Int -> IO (Int -> IO a)) -> IO ()

-- | Fill something in parallel.
--   
--   <ul>
--   <li>The array is split into linear chunks and each thread fills one
--   chunk.</li>
--   </ul>
fillInterleavedP :: Int -> (Int -> a -> IO ()) -> (Int -> a) -> IO ()

-- | Fill a block in a rank-2 array in parallel.
--   
--   <ul>
--   <li>Blockwise filling can be more cache-efficient than linear filling
--   for rank-2 arrays.</li>
--   <li>Coordinates given are of the filled edges of the block.</li>
--   <li>We divide the block into columns, and give one column to each
--   thread.</li>
--   <li>Each column is filled in row major order from top to bottom.</li>
--   </ul>
fillBlock2P :: Elt a => (Int -> a -> IO ()) -> (DIM2 -> a) -> Int# -> Int# -> Int# -> Int# -> Int# -> IO ()

-- | Fill a block in a rank-2 array, sequentially.
--   
--   <ul>
--   <li>Blockwise filling can be more cache-efficient than linear filling
--   for rank-2 arrays.</li>
--   <li>The block is filled in row major order from top to bottom.</li>
--   </ul>
fillBlock2S :: (Int -> a -> IO ()) -> (DIM2 -> a) -> Int# -> Int# -> Int# -> Int# -> Int# -> IO ()

-- | Fill a block in a rank-2 array, sequentially.
--   
--   <ul>
--   <li>Blockwise filling can be more cache-efficient than linear filling
--   for rank-2 arrays.</li>
--   <li>Using cursor functions can help to expose inter-element indexing
--   computations to the GHC and LLVM optimisers.</li>
--   <li>Coordinates given are of the filled edges of the block.</li>
--   <li>The block is filled in row major order from top to bottom.</li>
--   </ul>
fillCursoredBlock2S :: Elt a => (Int -> a -> IO ()) -> (DIM2 -> cursor) -> (DIM2 -> cursor -> cursor) -> (cursor -> a) -> Int# -> Int# -> Int# -> Int# -> Int# -> IO ()

-- | Fill a block in a rank-2 array in parallel.
--   
--   <ul>
--   <li>Blockwise filling can be more cache-efficient than linear filling
--   for rank-2 arrays.</li>
--   <li>Using cursor functions can help to expose inter-element indexing
--   computations to the GHC and LLVM optimisers.</li>
--   <li>Coordinates given are of the filled edges of the block.</li>
--   <li>We divide the block into columns, and give one column to each
--   thread.</li>
--   <li>Each column is filled in row major order from top to bottom.</li>
--   </ul>
fillCursoredBlock2P :: Elt a => (Int -> a -> IO ()) -> (DIM2 -> cursor) -> (DIM2 -> cursor -> cursor) -> (cursor -> a) -> Int# -> Int# -> Int# -> Int# -> Int# -> IO ()

-- | Select indices matching a predicate.
--   
--   <ul>
--   <li>This primitive can be useful for writing filtering functions.</li>
--   </ul>
selectChunkedS :: Shape sh => (sh -> a -> IO ()) -> (sh -> Bool) -> (sh -> a) -> sh -> IO Int

-- | Select indices matching a predicate, in parallel.
--   
--   <ul>
--   <li>This primitive can be useful for writing filtering functions.</li>
--   <li>The array is split into linear chunks, with one chunk being given
--   to each thread.</li>
--   <li>The number of elements in the result array depends on how many
--   threads you're running the program with.</li>
--   </ul>
selectChunkedP :: forall a. Unbox a => (Int -> Bool) -> (Int -> a) -> Int -> IO [IOVector a]

module Data.Array.Repa.Repr.Vector

-- | Arrays represented as boxed vectors.
--   
--   This representation should only be used when your element type doesn't
--   have an <tt>Unbox</tt> instsance. If it does, then use the Unboxed
--   <tt>U</tt> representation will be faster.
data V
data family Array r sh e

-- | Sequential computation of array elements.
--   
--   <ul>
--   <li>This is an alias for <tt>compute</tt> with a more specific
--   type.</li>
--   </ul>
computeVectorS :: Load r1 sh e => Array r1 sh e -> Array V sh e

-- | Parallel computation of array elements.
computeVectorP :: (Load r1 sh e, Monad m) => Array r1 sh e -> m (Array V sh e)

-- | O(n). Convert a list to a boxed vector array.
--   
--   <ul>
--   <li>This is an alias for <a>fromList</a> with a more specific
--   type.</li>
--   </ul>
fromListVector :: Shape sh => sh -> [a] -> Array V sh a

-- | O(1). Wrap a boxed vector as an array.
fromVector :: sh -> Vector e -> Array V sh e

-- | O(1). Unpack a boxed vector from an array.
toVector :: Array V sh e -> Vector e
instance (GHC.Show.Show sh, GHC.Show.Show e) => GHC.Show.Show (Data.Array.Repa.Base.Array Data.Array.Repa.Repr.Vector.V sh e)
instance (GHC.Read.Read sh, GHC.Read.Read e) => GHC.Read.Read (Data.Array.Repa.Base.Array Data.Array.Repa.Repr.Vector.V sh e)
instance Data.Array.Repa.Base.Source Data.Array.Repa.Repr.Vector.V a
instance Data.Array.Repa.Eval.Target.Target Data.Array.Repa.Repr.Vector.V e

module Data.Array.Repa.Repr.Undefined

-- | An array with undefined elements.
--   
--   <ul>
--   <li>This is normally used as the last representation in a partitioned
--   array, as the previous partitions are expected to provide full
--   coverage.</li>
--   </ul>
data X
data family Array r sh e
instance GHC.Show.Show sh => GHC.Show.Show (Data.Array.Repa.Base.Array Data.Array.Repa.Repr.Undefined.X sh e)
instance GHC.Read.Read sh => GHC.Read.Read (Data.Array.Repa.Base.Array Data.Array.Repa.Repr.Undefined.X sh e)
instance Data.Array.Repa.Base.Source Data.Array.Repa.Repr.Undefined.X e
instance Data.Array.Repa.Shape.Shape sh => Data.Array.Repa.Eval.Load.Load Data.Array.Repa.Repr.Undefined.X sh e

module Data.Array.Repa.Repr.Cursored

-- | Cursored Arrays. These are produced by Repa's stencil functions, and
--   help the fusion framework to share index compuations between array
--   elements.
--   
--   The basic idea is described in ``Efficient Parallel Stencil
--   Convolution'', Ben Lippmeier and Gabriele Keller, Haskell 2011 --
--   though the underlying array representation has changed since this
--   paper was published.
data C
data family Array r sh e

-- | Define a new cursored array.
makeCursored :: sh -> (sh -> cursor) -> (sh -> cursor -> cursor) -> (cursor -> e) -> Array C sh e
instance Data.Array.Repa.Base.Source Data.Array.Repa.Repr.Cursored.C a
instance Data.Array.Repa.Eval.Elt.Elt e => Data.Array.Repa.Eval.Load.Load Data.Array.Repa.Repr.Cursored.C Data.Array.Repa.Index.DIM2 e
instance Data.Array.Repa.Eval.Elt.Elt e => Data.Array.Repa.Eval.Load.LoadRange Data.Array.Repa.Repr.Cursored.C Data.Array.Repa.Index.DIM2 e

module Data.Array.Repa.Repr.Unboxed

-- | Unboxed arrays are represented as unboxed vectors.
--   
--   The implementation uses <tt>Data.Vector.Unboxed</tt> which is based on
--   type families and picks an efficient, specialised representation for
--   every element type. In particular, unboxed vectors of pairs are
--   represented as pairs of unboxed vectors. This is the most efficient
--   representation for numerical data.
data U
class (Vector Vector a, MVector MVector a) => Unbox a
data family Array r sh e

-- | Sequential computation of array elements..
--   
--   <ul>
--   <li>This is an alias for <a>computeS</a> with a more specific
--   type.</li>
--   </ul>
computeUnboxedS :: (Load r1 sh e, Unbox e) => Array r1 sh e -> Array U sh e

-- | Parallel computation of array elements.
--   
--   <ul>
--   <li>This is an alias for <a>computeP</a> with a more specific
--   type.</li>
--   </ul>
computeUnboxedP :: (Load r1 sh e, Monad m, Unbox e) => Array r1 sh e -> m (Array U sh e)

-- | O(n). Convert a list to an unboxed vector array.
--   
--   <ul>
--   <li>This is an alias for <a>fromList</a> with a more specific
--   type.</li>
--   </ul>
fromListUnboxed :: (Shape sh, Unbox a) => sh -> [a] -> Array U sh a

-- | O(1). Wrap an unboxed vector as an array.
fromUnboxed :: sh -> Vector e -> Array U sh e

-- | O(1). Unpack an unboxed vector from an array.
toUnboxed :: Array U sh e -> Vector e

-- | O(1). Zip some unboxed arrays. The shapes must be identical else
--   <a>error</a>.
zip :: (Shape sh, Unbox a, Unbox b) => Array U sh a -> Array U sh b -> Array U sh (a, b)

-- | O(1). Zip some unboxed arrays. The shapes must be identical else
--   <a>error</a>.
zip3 :: (Shape sh, Unbox a, Unbox b, Unbox c) => Array U sh a -> Array U sh b -> Array U sh c -> Array U sh (a, b, c)

-- | O(1). Zip some unboxed arrays. The shapes must be identical else
--   <a>error</a>.
zip4 :: (Shape sh, Unbox a, Unbox b, Unbox c, Unbox d) => Array U sh a -> Array U sh b -> Array U sh c -> Array U sh d -> Array U sh (a, b, c, d)

-- | O(1). Zip some unboxed arrays. The shapes must be identical else
--   <a>error</a>.
zip5 :: (Shape sh, Unbox a, Unbox b, Unbox c, Unbox d, Unbox e) => Array U sh a -> Array U sh b -> Array U sh c -> Array U sh d -> Array U sh e -> Array U sh (a, b, c, d, e)

-- | O(1). Zip some unboxed arrays. The shapes must be identical else
--   <a>error</a>.
zip6 :: (Shape sh, Unbox a, Unbox b, Unbox c, Unbox d, Unbox e, Unbox f) => Array U sh a -> Array U sh b -> Array U sh c -> Array U sh d -> Array U sh e -> Array U sh f -> Array U sh (a, b, c, d, e, f)

-- | O(1). Unzip an unboxed array.
unzip :: (Unbox a, Unbox b) => Array U sh (a, b) -> (Array U sh a, Array U sh b)

-- | O(1). Unzip an unboxed array.
unzip3 :: (Unbox a, Unbox b, Unbox c) => Array U sh (a, b, c) -> (Array U sh a, Array U sh b, Array U sh c)

-- | O(1). Unzip an unboxed array.
unzip4 :: (Unbox a, Unbox b, Unbox c, Unbox d) => Array U sh (a, b, c, d) -> (Array U sh a, Array U sh b, Array U sh c, Array U sh d)

-- | O(1). Unzip an unboxed array.
unzip5 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e) => Array U sh (a, b, c, d, e) -> (Array U sh a, Array U sh b, Array U sh c, Array U sh d, Array U sh e)

-- | O(1). Unzip an unboxed array.
unzip6 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e, Unbox f) => Array U sh (a, b, c, d, e, f) -> (Array U sh a, Array U sh b, Array U sh c, Array U sh d, Array U sh e, Array U sh f)
instance (GHC.Show.Show sh, GHC.Show.Show e, Data.Vector.Unboxed.Base.Unbox e) => GHC.Show.Show (Data.Array.Repa.Base.Array Data.Array.Repa.Repr.Unboxed.U sh e)
instance (GHC.Read.Read sh, GHC.Read.Read e, Data.Vector.Unboxed.Base.Unbox e) => GHC.Read.Read (Data.Array.Repa.Base.Array Data.Array.Repa.Repr.Unboxed.U sh e)
instance Data.Vector.Unboxed.Base.Unbox a => Data.Array.Repa.Base.Source Data.Array.Repa.Repr.Unboxed.U a
instance Data.Vector.Unboxed.Base.Unbox e => Data.Array.Repa.Eval.Target.Target Data.Array.Repa.Repr.Unboxed.U e

module Data.Array.Repa.Operators.Selection

-- | Produce an array by applying a predicate to a range of integers. If
--   the predicate matches, then use the second function to generate the
--   element.
--   
--   <ul>
--   <li>This is a low-level function helpful for writing filtering
--   operations on arrays.</li>
--   <li>Use the integer as the index into the array you're filtering.</li>
--   </ul>
selectP :: (Unbox a, Monad m) => (Int -> Bool) -> (Int -> a) -> Int -> m (Array U DIM1 a)

module Data.Array.Repa.Repr.Partitioned

-- | Partitioned arrays. The last partition takes priority
--   
--   These are produced by Repa's support functions and allow arrays to be
--   defined using a different element function for each partition.
--   
--   The basic idea is described in ``Efficient Parallel Stencil
--   Convolution'', Ben Lippmeier and Gabriele Keller, Haskell 2011 --
--   though the underlying array representation has changed since this
--   paper was published.
data P r1 r2
data family Array r sh e
data Range sh
Range :: !sh -> !sh -> (sh -> Bool) -> Range sh

-- | Check whether an index is within the given range.
inRange :: Range sh -> sh -> Bool
instance (Data.Array.Repa.Base.Source r1 e, Data.Array.Repa.Base.Source r2 e) => Data.Array.Repa.Base.Source (Data.Array.Repa.Repr.Partitioned.P r1 r2) e
instance (Data.Array.Repa.Eval.Load.LoadRange r1 sh e, Data.Array.Repa.Eval.Load.Load r2 sh e) => Data.Array.Repa.Eval.Load.Load (Data.Array.Repa.Repr.Partitioned.P r1 r2) sh e

module Data.Array.Repa.Operators.Mapping

-- | Apply a worker function to each element of an array, yielding a new
--   array with the same extent.
map :: (Shape sh, Source r a) => (a -> b) -> Array r sh a -> Array D sh b

-- | Combine two arrays, element-wise, with a binary operator. If the
--   extent of the two array arguments differ, then the resulting array's
--   extent is their intersection.
zipWith :: (Shape sh, Source r1 a, Source r2 b) => (a -> b -> c) -> Array r1 sh a -> Array r2 sh b -> Array D sh c
(+^) :: (Shape sh, Source r1 c, Source r2 c, Num c) => Array r1 sh c -> Array r2 sh c -> Array D sh c
infixl 6 +^
(-^) :: (Shape sh, Source r1 c, Source r2 c, Num c) => Array r1 sh c -> Array r2 sh c -> Array D sh c
infixl 6 -^
(*^) :: (Shape sh, Source r1 c, Source r2 c, Num c) => Array r1 sh c -> Array r2 sh c -> Array D sh c
infixl 7 *^
(/^) :: (Shape sh, Source r1 c, Source r2 c, Fractional c) => Array r1 sh c -> Array r2 sh c -> Array D sh c
infixl 7 /^

-- | Structured versions of <tt>map</tt> and <tt>zipWith</tt> that preserve
--   the representation of cursored and partitioned arrays.
--   
--   For cursored (<tt>C</tt>) arrays, the cursoring of the source array is
--   preserved.
--   
--   For partitioned (<tt>P</tt>) arrays, the worker function is fused with
--   each array partition separately, instead of treating the whole array
--   as a single bulk object.
--   
--   Preserving the cursored and/or paritioned representation of an array
--   is will make follow-on computation more efficient than if the array
--   was converted to a vanilla Delayed (<tt>D</tt>) array as with plain
--   <a>map</a> and <a>zipWith</a>.
--   
--   If the source array is not cursored or partitioned then <a>smap</a>
--   and <a>szipWith</a> are identical to the plain functions.
class Structured r1 a b where {
    
    -- | The target result representation.
    type family TR r1;
}

-- | Structured <tt>map</tt>.
smap :: (Structured r1 a b, Shape sh) => (a -> b) -> Array r1 sh a -> Array (TR r1) sh b

-- | Structured <tt>zipWith</tt>. If you have a cursored or partitioned
--   source array then use that as the third argument (corresponding to
--   <tt>r1</tt> here)
szipWith :: (Structured r1 a b, Shape sh, Source r c) => (c -> a -> b) -> Array r sh c -> Array r1 sh a -> Array (TR r1) sh b
instance Data.Array.Repa.Operators.Mapping.Structured Data.Array.Repa.Repr.ByteString.B GHC.Word.Word8 b
instance Data.Array.Repa.Operators.Mapping.Structured Data.Array.Repa.Repr.Cursored.C a b
instance Data.Array.Repa.Operators.Mapping.Structured Data.Array.Repa.Repr.Delayed.D a b
instance Foreign.Storable.Storable a => Data.Array.Repa.Operators.Mapping.Structured Data.Array.Repa.Repr.ForeignPtr.F a b
instance (Data.Array.Repa.Operators.Mapping.Structured r1 a b, Data.Array.Repa.Operators.Mapping.Structured r2 a b) => Data.Array.Repa.Operators.Mapping.Structured (Data.Array.Repa.Repr.Partitioned.P r1 r2) a b
instance Data.Array.Repa.Operators.Mapping.Structured r1 a b => Data.Array.Repa.Operators.Mapping.Structured (Data.Array.Repa.Repr.HintSmall.S r1) a b
instance Data.Array.Repa.Operators.Mapping.Structured r1 a b => Data.Array.Repa.Operators.Mapping.Structured (Data.Array.Repa.Repr.HintInterleave.I r1) a b
instance Data.Vector.Unboxed.Base.Unbox a => Data.Array.Repa.Operators.Mapping.Structured Data.Array.Repa.Repr.Unboxed.U a b
instance Data.Array.Repa.Operators.Mapping.Structured Data.Array.Repa.Repr.Undefined.X a b

module Data.Array.Repa.Operators.Reduction

-- | Sequential reduction of the innermost dimension of an arbitrary rank
--   array.
--   
--   Combine this with <tt>transpose</tt> to fold any other dimension.
--   
--   Elements are reduced in the order of their indices, from lowest to
--   highest. Applications of the operator are associatied arbitrarily.
--   
--   <pre>
--   &gt;&gt;&gt; let c 0 x = x; c x 0 = x; c x y = y
--   
--   &gt;&gt;&gt; let a = fromListUnboxed (Z :. 2 :. 2) [1,2,3,4] :: Array U (Z :. Int :. Int) Int
--   
--   &gt;&gt;&gt; foldS c 0 a
--   AUnboxed (Z :. 2) (fromList [2,4])
--   </pre>
foldS :: (Shape sh, Source r a, Unbox a) => (a -> a -> a) -> a -> Array r (sh :. Int) a -> Array U sh a

-- | Parallel reduction of the innermost dimension of an arbitray rank
--   array.
--   
--   The first argument needs to be an associative sequential operator. The
--   starting element must be neutral with respect to the operator, for
--   example <tt>0</tt> is neutral with respect to <tt>(+)</tt> as <tt>0 +
--   a = a</tt>. These restrictions are required to support parallel
--   evaluation, as the starting element may be used multiple times
--   depending on the number of threads.
--   
--   Elements are reduced in the order of their indices, from lowest to
--   highest. Applications of the operator are associatied arbitrarily.
--   
--   <pre>
--   &gt;&gt;&gt; let c 0 x = x; c x 0 = x; c x y = y
--   
--   &gt;&gt;&gt; let a = fromListUnboxed (Z :. 2 :. 2) [1,2,3,4] :: Array U (Z :. Int :. Int) Int
--   
--   &gt;&gt;&gt; foldP c 0 a
--   AUnboxed (Z :. 2) (fromList [2,4])
--   </pre>
foldP :: (Shape sh, Source r a, Unbox a, Monad m) => (a -> a -> a) -> a -> Array r (sh :. Int) a -> m (Array U sh a)

-- | Sequential reduction of an array of arbitrary rank to a single scalar
--   value.
--   
--   Elements are reduced in row-major order. Applications of the operator
--   are associated arbitrarily.
foldAllS :: (Shape sh, Source r a) => (a -> a -> a) -> a -> Array r sh a -> a

-- | Parallel reduction of an array of arbitrary rank to a single scalar
--   value.
--   
--   The first argument needs to be an associative sequential operator. The
--   starting element must be neutral with respect to the operator, for
--   example <tt>0</tt> is neutral with respect to <tt>(+)</tt> as <tt>0 +
--   a = a</tt>. These restrictions are required to support parallel
--   evaluation, as the starting element may be used multiple times
--   depending on the number of threads.
--   
--   Elements are reduced in row-major order. Applications of the operator
--   are associated arbitrarily.
foldAllP :: (Shape sh, Source r a, Unbox a, Monad m) => (a -> a -> a) -> a -> Array r sh a -> m a

-- | Sequential sum the innermost dimension of an array.
sumS :: (Shape sh, Source r a, Num a, Unbox a) => Array r (sh :. Int) a -> Array U sh a

-- | Parallel sum the innermost dimension of an array.
sumP :: (Shape sh, Source r a, Num a, Unbox a, Monad m) => Array r (sh :. Int) a -> m (Array U sh a)

-- | Sequential sum of all the elements of an array.
sumAllS :: (Shape sh, Source r a, Num a) => Array r sh a -> a

-- | Parallel sum all the elements of an array.
sumAllP :: (Shape sh, Source r a, Unbox a, Num a, Monad m) => Array r sh a -> m a

-- | Check whether two arrays have the same shape and contain equal
--   elements, sequentially.
equalsS :: (Shape sh, Source r1 a, Source r2 a, Eq a) => Array r1 sh a -> Array r2 sh a -> Bool

-- | Check whether two arrays have the same shape and contain equal
--   elements, in parallel.
equalsP :: (Shape sh, Source r1 a, Source r2 a, Eq a, Monad m) => Array r1 sh a -> Array r2 sh a -> m Bool
instance (Data.Array.Repa.Shape.Shape sh, GHC.Classes.Eq sh, Data.Array.Repa.Base.Source r a, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.Array.Repa.Base.Array r sh a)

module Data.Array.Repa.Arbitrary

-- | Generates a random unboxed array of a given shape
arbitraryUShaped :: (Shape sh, Unbox a, Arbitrary a) => sh -> Gen (Array U sh a)

-- | Property tested for unboxed random arrays with a given shape.
forAllUShaped :: (Show sh, Show a, Unbox a, Testable prop, Shape sh, Arbitrary a) => sh -> (Array U sh a -> prop) -> Property

-- | Property tested for pair of unboxed random arrays with a given shape.
forAll2UShaped :: (Show sh, Show a, Unbox a, Testable prop, Shape sh, Arbitrary a) => sh -> ((Array U sh a, Array U sh a) -> prop) -> Property

-- | Property tested for triple of unboxed random arrays with a given
--   shape.
forAll3UShaped :: (Show sh, Show a, Unbox a, Testable prop, Shape sh, Arbitrary a) => sh -> ((Array U sh a, Array U sh a, Array U sh a) -> prop) -> Property

-- | Property tested for quadruple of unboxed random arrays with a given
--   shape.
forAll4UShaped :: (Show sh, Show a, Unbox a, Testable prop, Shape sh, Arbitrary a) => sh -> ((Array U sh a, Array U sh a, Array U sh a, Array U sh a) -> prop) -> Property

-- | Property tested for 5-tuple of unboxed random arrays with a given
--   shape.
forAll5UShaped :: (Show sh, Show a, Unbox a, Testable prop, Shape sh, Arbitrary a) => sh -> ((Array U sh a, Array U sh a, Array U sh a, Array U sh a, Array U sh a) -> prop) -> Property

-- | Generates a random boxed array of a given shape
arbitraryVShaped :: (Shape sh, Arbitrary a) => sh -> Gen (Array V sh a)

-- | Property tested for unboxed random arrays with a given shape.
forAllVShaped :: (Show sh, Show a, Testable prop, Shape sh, Arbitrary a) => sh -> (Array V sh a -> prop) -> Property

-- | Property tested for pair of unboxed random arrays with a given shape.
forAll2VShaped :: (Show sh, Show a, Testable prop, Shape sh, Arbitrary a) => sh -> ((Array V sh a, Array V sh a) -> prop) -> Property

-- | Property tested for triple of unboxed random arrays with a given
--   shape.
forAll3VShaped :: (Show sh, Show a, Testable prop, Shape sh, Arbitrary a) => sh -> ((Array V sh a, Array V sh a, Array V sh a) -> prop) -> Property

-- | Property tested for quadruple of unboxed random arrays with a given
--   shape.
forAll4VShaped :: (Show sh, Show a, Testable prop, Shape sh, Arbitrary a) => sh -> ((Array V sh a, Array V sh a, Array V sh a, Array V sh a) -> prop) -> Property

-- | Property tested for 5-tuple of unboxed random arrays with a given
--   shape.
forAll5VShaped :: (Show sh, Show a, Testable prop, Shape sh, Arbitrary a) => sh -> ((Array V sh a, Array V sh a, Array V sh a, Array V sh a, Array V sh a) -> prop) -> Property
instance Test.QuickCheck.Arbitrary.Arbitrary Data.Array.Repa.Index.Z
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (a Data.Array.Repa.Index.:. GHC.Types.Int)
instance (Test.QuickCheck.Arbitrary.Arbitrary sh, Test.QuickCheck.Arbitrary.Arbitrary a, Data.Vector.Unboxed.Base.Unbox a, Data.Array.Repa.Shape.Shape sh) => Test.QuickCheck.Arbitrary.Arbitrary (Data.Array.Repa.Base.Array Data.Array.Repa.Repr.Unboxed.U sh a)
instance (Test.QuickCheck.Arbitrary.Arbitrary sh, Test.QuickCheck.Arbitrary.Arbitrary a, Data.Array.Repa.Shape.Shape sh) => Test.QuickCheck.Arbitrary.Arbitrary (Data.Array.Repa.Base.Array Data.Array.Repa.Repr.Vector.V sh a)
instance Test.QuickCheck.Arbitrary.CoArbitrary Data.Array.Repa.Index.Z
instance Test.QuickCheck.Arbitrary.CoArbitrary a => Test.QuickCheck.Arbitrary.CoArbitrary (a Data.Array.Repa.Index.:. GHC.Types.Int)
instance (Test.QuickCheck.Arbitrary.CoArbitrary sh, Test.QuickCheck.Arbitrary.CoArbitrary a, Data.Array.Repa.Base.Source r a, Data.Array.Repa.Shape.Shape sh) => Test.QuickCheck.Arbitrary.CoArbitrary (Data.Array.Repa.Base.Array r sh a)


-- | Index space transformation between arrays and slices.
module Data.Array.Repa.Slice

-- | Select all indices at a certain position.
data All
All :: All

-- | Place holder for any possible shape.
data Any sh
Any :: Any sh

-- | Map a type of the index in the full shape, to the type of the index in
--   the slice.
type family FullShape ss

-- | Map the type of an index in the slice, to the type of the index in the
--   full shape.
type family SliceShape ss

-- | Class of index types that can map to slices.
class Slice ss

-- | Map an index of a full shape onto an index of some slice.
sliceOfFull :: Slice ss => ss -> FullShape ss -> SliceShape ss

-- | Map an index of a slice onto an index of the full shape.
fullOfSlice :: Slice ss => ss -> SliceShape ss -> FullShape ss
instance Data.Array.Repa.Slice.Slice Data.Array.Repa.Index.Z
instance Data.Array.Repa.Slice.Slice (Data.Array.Repa.Slice.Any sh)
instance Data.Array.Repa.Slice.Slice sl => Data.Array.Repa.Slice.Slice (sl Data.Array.Repa.Index.:. GHC.Types.Int)
instance Data.Array.Repa.Slice.Slice sl => Data.Array.Repa.Slice.Slice (sl Data.Array.Repa.Index.:. Data.Array.Repa.Slice.All)

module Data.Array.Repa.Operators.IndexSpace

-- | Impose a new shape on the elements of an array. The new extent must be
--   the same size as the original, else <a>error</a>.
reshape :: (Shape sh1, Shape sh2, Source r1 e) => sh2 -> Array r1 sh1 e -> Array D sh2 e

-- | Append two arrays.
append :: (Shape sh, Source r1 e, Source r2 e) => Array r1 (sh :. Int) e -> Array r2 (sh :. Int) e -> Array D (sh :. Int) e

-- | Append two arrays.
(++) :: (Shape sh, Source r1 e, Source r2 e) => Array r1 (sh :. Int) e -> Array r2 (sh :. Int) e -> Array D (sh :. Int) e

-- | Transpose the lowest two dimensions of an array. Transposing an array
--   twice yields the original.
transpose :: (Shape sh, Source r e) => Array r ((sh :. Int) :. Int) e -> Array D ((sh :. Int) :. Int) e

-- | Extract a sub-range of elements from an array.
extract :: (Shape sh, Source r e) => sh -> sh -> Array r sh e -> Array D sh e

-- | Backwards permutation of an array's elements.
backpermute :: forall r sh1 sh2 e. (Shape sh1, Source r e) => sh2 -> (sh2 -> sh1) -> Array r sh1 e -> Array D sh2 e

-- | Backwards permutation of an array's elements.
unsafeBackpermute :: forall r sh1 sh2 e. (Shape sh1, Source r e) => sh2 -> (sh2 -> sh1) -> Array r sh1 e -> Array D sh2 e

-- | Default backwards permutation of an array's elements. If the function
--   returns <a>Nothing</a> then the value at that index is taken from the
--   default array (<tt>arrDft</tt>)
backpermuteDft :: forall r1 r2 sh1 sh2 e. (Shape sh1, Shape sh2, Source r1 e, Source r2 e) => Array r2 sh2 e -> (sh2 -> Maybe sh1) -> Array r1 sh1 e -> Array D sh2 e

-- | Default backwards permutation of an array's elements. If the function
--   returns <a>Nothing</a> then the value at that index is taken from the
--   default array (<tt>arrDft</tt>)
unsafeBackpermuteDft :: forall r1 r2 sh1 sh2 e. (Shape sh1, Shape sh2, Source r1 e, Source r2 e) => Array r2 sh2 e -> (sh2 -> Maybe sh1) -> Array r1 sh1 e -> Array D sh2 e

-- | Extend an array, according to a given slice specification.
--   
--   For example, to replicate the rows of an array use the following:
--   
--   <pre>
--   extend (Any :. (5::Int) :. All) arr
--   </pre>
extend :: (Slice sl, Shape (SliceShape sl), Source r e) => sl -> Array r (SliceShape sl) e -> Array D (FullShape sl) e

-- | Extend an array, according to a given slice specification.
--   
--   For example, to replicate the rows of an array use the following:
--   
--   <pre>
--   extend (Any :. (5::Int) :. All) arr
--   </pre>
unsafeExtend :: (Slice sl, Shape (SliceShape sl), Source r e) => sl -> Array r (SliceShape sl) e -> Array D (FullShape sl) e

-- | Take a slice from an array, according to a given specification.
--   
--   For example, to take a row from a matrix use the following:
--   
--   <pre>
--   slice arr (Any :. (5::Int) :. All)
--   </pre>
--   
--   To take a column use:
--   
--   <pre>
--   slice arr (Any :. (5::Int))
--   </pre>
slice :: (Slice sl, Shape (FullShape sl), Source r e) => Array r (FullShape sl) e -> sl -> Array D (SliceShape sl) e

-- | Take a slice from an array, according to a given specification.
--   
--   For example, to take a row from a matrix use the following:
--   
--   <pre>
--   slice arr (Any :. (5::Int) :. All)
--   </pre>
--   
--   To take a column use:
--   
--   <pre>
--   slice arr (Any :. (5::Int))
--   </pre>
unsafeSlice :: (Slice sl, Shape (FullShape sl), Source r e) => Array r (FullShape sl) e -> sl -> Array D (SliceShape sl) e


-- | Repa arrays are wrappers around a linear structure that holds the
--   element data.
--   
--   The representation tag determines what structure holds the data.
--   
--   Delayed Representations (functions that compute elements)
--   
--   <ul>
--   <li><a>D</a> -- Functions from indices to elements.</li>
--   <li><a>C</a> -- Cursor functions.</li>
--   </ul>
--   
--   Manifest Representations (real data)
--   
--   <ul>
--   <li><a>U</a> -- Adaptive unboxed vectors.</li>
--   <li><a>V</a> -- Boxed vectors.</li>
--   <li><a>B</a> -- Strict ByteStrings.</li>
--   <li><a>F</a> -- Foreign memory buffers.</li>
--   </ul>
--   
--   Meta Representations
--   
--   <ul>
--   <li><a>P</a> -- Arrays that are partitioned into several
--   representations.</li>
--   <li><a>S</a> -- Hints that computing this array is a small amount of
--   work, so computation should be sequential rather than parallel to
--   avoid scheduling overheads.</li>
--   <li><a>I</a> -- Hints that computing this array will be an unbalanced
--   workload, so computation of successive elements should be interleaved
--   between the processors</li>
--   <li><tt>X</tt> -- Arrays whose elements are all undefined.</li>
--   </ul>
--   
--   Array fusion is achieved via the delayed (<a>D</a>) and cursored
--   (<a>C</a>) representations. At compile time, the GHC simplifier
--   combines the functions contained within <a>D</a> and <a>C</a> arrays
--   without needing to create manifest intermediate arrays.
--   
--   <i>Advice for writing fast code:</i>
--   
--   <ol>
--   <li>Repa does not support nested parallellism. This means that you
--   cannot <a>map</a> a parallel worker function across an array and then
--   call <a>computeP</a> to evaluate it, or pass a parallel worker to
--   parallel reductions such as <a>foldP</a>. If you do then you will get
--   a run-time warning and the code will run very slowly.</li>
--   <li>Arrays of type <tt>(Array D sh a)</tt> or <tt>(Array C sh a)</tt>
--   are <i>not real arrays</i>. They are represented as functions that
--   compute each element on demand. You need to use <a>computeS</a>,
--   <a>computeP</a>, <a>computeUnboxedP</a> and so on to actually evaluate
--   the elements.</li>
--   <li>Add <tt>INLINE</tt> pragmas to all leaf-functions in your code,
--   expecially ones that compute numeric results. Non-inlined lazy
--   function calls can cost upwards of 50 cycles each, while each numeric
--   operator only costs one (or less). Inlining leaf functions also
--   ensures they are specialised at the appropriate numeric types.</li>
--   <li>Add bang patterns to all function arguments, and all fields of
--   your data types. In a high-performance Haskell program, the cost of
--   lazy evaluation can easily dominate the run time if not handled
--   correctly. You don't want to rely on the strictness analyser in
--   numeric code because if it does not return a perfect result then the
--   performance of your program will be awful. This is less of a problem
--   for general Haskell code, and in a different context relying on
--   strictness analysis is fine.</li>
--   <li>Scheduling an 8-thread parallel computation can take 50us on a
--   Linux machine. You should switch to sequential evaluation functions
--   like <a>computeS</a> and <a>foldS</a> for small arrays in inner loops,
--   and at the bottom of a divide-and-conquer algorithm. Consider using a
--   <a>computeP</a> that evaluates an array defined using <a>computeS</a>
--   or <a>foldS</a> for each element.</li>
--   <li>Compile the modules that use Repa with the following flags:
--   <tt>-Odph -rtsopts -threaded</tt> <tt>-fno-liberate-case
--   -funfolding-use-threshold1000 -funfolding-keeness-factor1000</tt>
--   <tt>-fllvm -optlo-O3</tt> You don't want the liberate-case transform
--   because it tends to duplicate too much intermediate code, and is not
--   needed if you use bang patterns as per point 4. The unfolding flags
--   tell the inliner to not to fool around with heuristics, and just
--   inline everything. If the binaries become too big then split the array
--   part of your program into separate modules and only compile those with
--   the unfolding flags.</li>
--   <li>Repa writes to the GHC eventlog at the start and end of each
--   parallel computation. Use threadscope to see what your program is
--   doing.</li>
--   <li>When you're sure your program works, switch to the unsafe versions
--   of functions like <a>traverse</a>. These don't do bounds checks.</li>
--   </ol>
--   
--   <i>Changes for Repa 3.2:</i>
--   
--   <ol>
--   <li>Renamed some Repa 3.1 type classes to have more intuitive names:
--   <tt>Repr</tt> -&gt; <a>Source</a>, <tt>Fill</tt> -&gt; <a>Load</a>,
--   <tt>Fillable</tt> -&gt; <a>Target</a>, <tt>Combine</tt> -&gt;
--   <a>Structured</a>.</li>
--   <li>Also renamed <tt>MArray</tt> -&gt; <a>MVec</a> to emphasise its
--   linear structure.</li>
--   <li>Made <a>Array</a> and <a>MVec</a> associated types of
--   <a>Source</a> and <a>Target</a> respectively.</li>
--   <li>Added the <a>S</a> (Smallness) and <a>I</a> (Interleave)
--   hints.</li>
--   </ol>
module Data.Array.Repa

-- | Class of array representations that we can read elements from.
class Source r e where {
    data family Array r sh e;
}

-- | O(1). Take the extent (size) of an array.
extent :: (Source r e, Shape sh) => Array r sh e -> sh

-- | O(1). Shape polymorphic indexing.
index :: (Source r e, Shape sh) => Array r sh e -> sh -> e

-- | O(1). Shape polymorphic indexing.
unsafeIndex :: (Source r e, Shape sh) => Array r sh e -> sh -> e

-- | O(1). Linear indexing into underlying, row-major, array
--   representation.
linearIndex :: (Source r e, Shape sh) => Array r sh e -> Int -> e

-- | O(1). Linear indexing into underlying, row-major, array
--   representation.
unsafeLinearIndex :: (Source r e, Shape sh) => Array r sh e -> Int -> e

-- | Ensure an array's data structure is fully evaluated.
deepSeqArray :: (Source r e, Shape sh) => Array r sh e -> b -> b

-- | O(1). Alias for <a>index</a>
(!) :: Shape sh => Source r e => Array r sh e -> sh -> e

-- | O(n). Convert an array to a list.
toList :: Shape sh => Source r e => Array r sh e -> [e]

-- | Apply <a>deepSeqArray</a> to up to four arrays.
deepSeqArrays :: Shape sh => Source r e => [Array r sh e] -> b -> b

-- | Parallel computation of array elements.
--   
--   <ul>
--   <li>The source array must have a delayed representation like <a>D</a>,
--   <tt>C</tt> or <tt>P</tt>, and the result a manifest representation
--   like <tt>U</tt> or <tt>F</tt>.</li>
--   <li>If you want to copy data between manifest representations then use
--   <a>copyP</a> instead.</li>
--   <li>If you want to convert a manifest array back to a delayed
--   representation then use <a>delay</a> instead.</li>
--   </ul>
computeP :: (Load r1 sh e, Target r2 e, Source r2 e, Monad m) => Array r1 sh e -> m (Array r2 sh e)

-- | Sequential computation of array elements.
computeS :: (Load r1 sh e, Target r2 e) => Array r1 sh e -> Array r2 sh e

-- | Parallel copying of arrays.
--   
--   <ul>
--   <li>This is a wrapper that delays an array before calling
--   <a>computeP</a>.</li>
--   <li>You can use it to copy manifest arrays between
--   representations.</li>
--   </ul>
copyP :: (Source r1 e, Source r2 e, Load D sh e, Target r2 e, Monad m) => Array r1 sh e -> m (Array r2 sh e)

-- | Sequential copying of arrays.
copyS :: (Source r1 e, Load D sh e, Target r2 e) => Array r1 sh e -> Array r2 sh e

-- | Delayed arrays are represented as functions from the index to element
--   value.
--   
--   Every time you index into a delayed array the element at that position
--   is recomputed.
data D

-- | O(1). Wrap a function as a delayed array.
fromFunction :: sh -> (sh -> a) -> Array D sh a

-- | O(1). Produce the extent of an array, and a function to retrieve an
--   arbitrary element.
toFunction :: (Shape sh, Source r1 a) => Array r1 sh a -> (sh, sh -> a)

-- | O(1). Delay an array. This wraps the internal representation to be a
--   function from indices to elements, so consumers don't need to worry
--   about what the previous representation was.
delay :: Shape sh => Source r e => Array r sh e -> Array D sh e

-- | Unboxed arrays are represented as unboxed vectors.
--   
--   The implementation uses <tt>Data.Vector.Unboxed</tt> which is based on
--   type families and picks an efficient, specialised representation for
--   every element type. In particular, unboxed vectors of pairs are
--   represented as pairs of unboxed vectors. This is the most efficient
--   representation for numerical data.
data U

-- | Parallel computation of array elements.
--   
--   <ul>
--   <li>This is an alias for <a>computeP</a> with a more specific
--   type.</li>
--   </ul>
computeUnboxedP :: (Load r1 sh e, Monad m, Unbox e) => Array r1 sh e -> m (Array U sh e)

-- | Sequential computation of array elements..
--   
--   <ul>
--   <li>This is an alias for <a>computeS</a> with a more specific
--   type.</li>
--   </ul>
computeUnboxedS :: (Load r1 sh e, Unbox e) => Array r1 sh e -> Array U sh e

-- | O(n). Convert a list to an unboxed vector array.
--   
--   <ul>
--   <li>This is an alias for <a>fromList</a> with a more specific
--   type.</li>
--   </ul>
fromListUnboxed :: (Shape sh, Unbox a) => sh -> [a] -> Array U sh a

-- | O(1). Wrap an unboxed vector as an array.
fromUnboxed :: sh -> Vector e -> Array U sh e

-- | O(1). Unpack an unboxed vector from an array.
toUnboxed :: Array U sh e -> Vector e

-- | Impose a new shape on the elements of an array. The new extent must be
--   the same size as the original, else <a>error</a>.
reshape :: (Shape sh1, Shape sh2, Source r1 e) => sh2 -> Array r1 sh1 e -> Array D sh2 e

-- | Append two arrays.
append :: (Shape sh, Source r1 e, Source r2 e) => Array r1 (sh :. Int) e -> Array r2 (sh :. Int) e -> Array D (sh :. Int) e

-- | Append two arrays.
(++) :: (Shape sh, Source r1 e, Source r2 e) => Array r1 (sh :. Int) e -> Array r2 (sh :. Int) e -> Array D (sh :. Int) e

-- | Extract a sub-range of elements from an array.
extract :: (Shape sh, Source r e) => sh -> sh -> Array r sh e -> Array D sh e

-- | Transpose the lowest two dimensions of an array. Transposing an array
--   twice yields the original.
transpose :: (Shape sh, Source r e) => Array r ((sh :. Int) :. Int) e -> Array D ((sh :. Int) :. Int) e

-- | Backwards permutation of an array's elements.
backpermute :: forall r sh1 sh2 e. (Shape sh1, Source r e) => sh2 -> (sh2 -> sh1) -> Array r sh1 e -> Array D sh2 e

-- | Default backwards permutation of an array's elements. If the function
--   returns <a>Nothing</a> then the value at that index is taken from the
--   default array (<tt>arrDft</tt>)
backpermuteDft :: forall r1 r2 sh1 sh2 e. (Shape sh1, Shape sh2, Source r1 e, Source r2 e) => Array r2 sh2 e -> (sh2 -> Maybe sh1) -> Array r1 sh1 e -> Array D sh2 e

-- | Take a slice from an array, according to a given specification.
--   
--   For example, to take a row from a matrix use the following:
--   
--   <pre>
--   slice arr (Any :. (5::Int) :. All)
--   </pre>
--   
--   To take a column use:
--   
--   <pre>
--   slice arr (Any :. (5::Int))
--   </pre>
slice :: (Slice sl, Shape (FullShape sl), Source r e) => Array r (FullShape sl) e -> sl -> Array D (SliceShape sl) e

-- | Extend an array, according to a given slice specification.
--   
--   For example, to replicate the rows of an array use the following:
--   
--   <pre>
--   extend (Any :. (5::Int) :. All) arr
--   </pre>
extend :: (Slice sl, Shape (SliceShape sl), Source r e) => sl -> Array r (SliceShape sl) e -> Array D (FullShape sl) e

-- | Apply a worker function to each element of an array, yielding a new
--   array with the same extent.
map :: (Shape sh, Source r a) => (a -> b) -> Array r sh a -> Array D sh b

-- | Combine two arrays, element-wise, with a binary operator. If the
--   extent of the two array arguments differ, then the resulting array's
--   extent is their intersection.
zipWith :: (Shape sh, Source r1 a, Source r2 b) => (a -> b -> c) -> Array r1 sh a -> Array r2 sh b -> Array D sh c
(+^) :: (Shape sh, Source r1 c, Source r2 c, Num c) => Array r1 sh c -> Array r2 sh c -> Array D sh c
infixl 6 +^
(-^) :: (Shape sh, Source r1 c, Source r2 c, Num c) => Array r1 sh c -> Array r2 sh c -> Array D sh c
infixl 6 -^
(*^) :: (Shape sh, Source r1 c, Source r2 c, Num c) => Array r1 sh c -> Array r2 sh c -> Array D sh c
infixl 7 *^
(/^) :: (Shape sh, Source r1 c, Source r2 c, Fractional c) => Array r1 sh c -> Array r2 sh c -> Array D sh c
infixl 7 /^

-- | Structured versions of <tt>map</tt> and <tt>zipWith</tt> that preserve
--   the representation of cursored and partitioned arrays.
--   
--   For cursored (<tt>C</tt>) arrays, the cursoring of the source array is
--   preserved.
--   
--   For partitioned (<tt>P</tt>) arrays, the worker function is fused with
--   each array partition separately, instead of treating the whole array
--   as a single bulk object.
--   
--   Preserving the cursored and/or paritioned representation of an array
--   is will make follow-on computation more efficient than if the array
--   was converted to a vanilla Delayed (<tt>D</tt>) array as with plain
--   <a>map</a> and <a>zipWith</a>.
--   
--   If the source array is not cursored or partitioned then <a>smap</a>
--   and <a>szipWith</a> are identical to the plain functions.
class Structured r1 a b where {
    
    -- | The target result representation.
    type family TR r1;
}

-- | Structured <tt>map</tt>.
smap :: (Structured r1 a b, Shape sh) => (a -> b) -> Array r1 sh a -> Array (TR r1) sh b

-- | Structured <tt>zipWith</tt>. If you have a cursored or partitioned
--   source array then use that as the third argument (corresponding to
--   <tt>r1</tt> here)
szipWith :: (Structured r1 a b, Shape sh, Source r c) => (c -> a -> b) -> Array r sh c -> Array r1 sh a -> Array (TR r1) sh b

-- | Unstructured traversal.
traverse :: forall r sh sh' a b. (Source r a, Shape sh) => Array r sh a -> (sh -> sh') -> ((sh -> a) -> sh' -> b) -> Array D sh' b

-- | Unstructured traversal over two arrays at once.
traverse2 :: forall r1 r2 sh sh' sh'' a b c. (Source r1 a, Source r2 b, Shape sh, Shape sh') => Array r1 sh a -> Array r2 sh' b -> (sh -> sh' -> sh'') -> ((sh -> a) -> (sh' -> b) -> sh'' -> c) -> Array D sh'' c

-- | Unstructured traversal over three arrays at once.
traverse3 :: forall r1 r2 r3 sh1 sh2 sh3 sh4 a b c d. (Source r1 a, Source r2 b, Source r3 c, Shape sh1, Shape sh2, Shape sh3) => Array r1 sh1 a -> Array r2 sh2 b -> Array r3 sh3 c -> (sh1 -> sh2 -> sh3 -> sh4) -> ((sh1 -> a) -> (sh2 -> b) -> (sh3 -> c) -> sh4 -> d) -> Array D sh4 d

-- | Unstructured traversal over four arrays at once.
traverse4 :: forall r1 r2 r3 r4 sh1 sh2 sh3 sh4 sh5 a b c d e. (Source r1 a, Source r2 b, Source r3 c, Source r4 d, Shape sh1, Shape sh2, Shape sh3, Shape sh4) => Array r1 sh1 a -> Array r2 sh2 b -> Array r3 sh3 c -> Array r4 sh4 d -> (sh1 -> sh2 -> sh3 -> sh4 -> sh5) -> ((sh1 -> a) -> (sh2 -> b) -> (sh3 -> c) -> (sh4 -> d) -> sh5 -> e) -> Array D sh5 e

-- | Interleave the elements of two arrays. All the input arrays must have
--   the same extent, else <a>error</a>. The lowest dimension of the result
--   array is twice the size of the inputs.
--   
--   <pre>
--   interleave2 a1 a2   b1 b2  =&gt;  a1 b1 a2 b2
--               a3 a4   b3 b4      a3 b3 a4 b4
--   </pre>
interleave2 :: (Shape sh, Source r1 a, Source r2 a) => Array r1 (sh :. Int) a -> Array r2 (sh :. Int) a -> Array D (sh :. Int) a

-- | Interleave the elements of three arrays.
interleave3 :: (Shape sh, Source r1 a, Source r2 a, Source r3 a) => Array r1 (sh :. Int) a -> Array r2 (sh :. Int) a -> Array r3 (sh :. Int) a -> Array D (sh :. Int) a

-- | Interleave the elements of four arrays.
interleave4 :: (Shape sh, Source r1 a, Source r2 a, Source r3 a, Source r4 a) => Array r1 (sh :. Int) a -> Array r2 (sh :. Int) a -> Array r3 (sh :. Int) a -> Array r4 (sh :. Int) a -> Array D (sh :. Int) a

-- | Parallel reduction of the innermost dimension of an arbitray rank
--   array.
--   
--   The first argument needs to be an associative sequential operator. The
--   starting element must be neutral with respect to the operator, for
--   example <tt>0</tt> is neutral with respect to <tt>(+)</tt> as <tt>0 +
--   a = a</tt>. These restrictions are required to support parallel
--   evaluation, as the starting element may be used multiple times
--   depending on the number of threads.
--   
--   Elements are reduced in the order of their indices, from lowest to
--   highest. Applications of the operator are associatied arbitrarily.
--   
--   <pre>
--   &gt;&gt;&gt; let c 0 x = x; c x 0 = x; c x y = y
--   
--   &gt;&gt;&gt; let a = fromListUnboxed (Z :. 2 :. 2) [1,2,3,4] :: Array U (Z :. Int :. Int) Int
--   
--   &gt;&gt;&gt; foldP c 0 a
--   AUnboxed (Z :. 2) (fromList [2,4])
--   </pre>
foldP :: (Shape sh, Source r a, Unbox a, Monad m) => (a -> a -> a) -> a -> Array r (sh :. Int) a -> m (Array U sh a)

-- | Sequential reduction of the innermost dimension of an arbitrary rank
--   array.
--   
--   Combine this with <tt>transpose</tt> to fold any other dimension.
--   
--   Elements are reduced in the order of their indices, from lowest to
--   highest. Applications of the operator are associatied arbitrarily.
--   
--   <pre>
--   &gt;&gt;&gt; let c 0 x = x; c x 0 = x; c x y = y
--   
--   &gt;&gt;&gt; let a = fromListUnboxed (Z :. 2 :. 2) [1,2,3,4] :: Array U (Z :. Int :. Int) Int
--   
--   &gt;&gt;&gt; foldS c 0 a
--   AUnboxed (Z :. 2) (fromList [2,4])
--   </pre>
foldS :: (Shape sh, Source r a, Unbox a) => (a -> a -> a) -> a -> Array r (sh :. Int) a -> Array U sh a

-- | Parallel reduction of an array of arbitrary rank to a single scalar
--   value.
--   
--   The first argument needs to be an associative sequential operator. The
--   starting element must be neutral with respect to the operator, for
--   example <tt>0</tt> is neutral with respect to <tt>(+)</tt> as <tt>0 +
--   a = a</tt>. These restrictions are required to support parallel
--   evaluation, as the starting element may be used multiple times
--   depending on the number of threads.
--   
--   Elements are reduced in row-major order. Applications of the operator
--   are associated arbitrarily.
foldAllP :: (Shape sh, Source r a, Unbox a, Monad m) => (a -> a -> a) -> a -> Array r sh a -> m a

-- | Sequential reduction of an array of arbitrary rank to a single scalar
--   value.
--   
--   Elements are reduced in row-major order. Applications of the operator
--   are associated arbitrarily.
foldAllS :: (Shape sh, Source r a) => (a -> a -> a) -> a -> Array r sh a -> a

-- | Parallel sum the innermost dimension of an array.
sumP :: (Shape sh, Source r a, Num a, Unbox a, Monad m) => Array r (sh :. Int) a -> m (Array U sh a)

-- | Sequential sum the innermost dimension of an array.
sumS :: (Shape sh, Source r a, Num a, Unbox a) => Array r (sh :. Int) a -> Array U sh a

-- | Parallel sum all the elements of an array.
sumAllP :: (Shape sh, Source r a, Unbox a, Num a, Monad m) => Array r sh a -> m a

-- | Sequential sum of all the elements of an array.
sumAllS :: (Shape sh, Source r a, Num a) => Array r sh a -> a

-- | Check whether two arrays have the same shape and contain equal
--   elements, in parallel.
equalsP :: (Shape sh, Source r1 a, Source r2 a, Eq a, Monad m) => Array r1 sh a -> Array r2 sh a -> m Bool

-- | Check whether two arrays have the same shape and contain equal
--   elements, sequentially.
equalsS :: (Shape sh, Source r1 a, Source r2 a, Eq a) => Array r1 sh a -> Array r2 sh a -> Bool

-- | Produce an array by applying a predicate to a range of integers. If
--   the predicate matches, then use the second function to generate the
--   element.
--   
--   <ul>
--   <li>This is a low-level function helpful for writing filtering
--   operations on arrays.</li>
--   <li>Use the integer as the index into the array you're filtering.</li>
--   </ul>
selectP :: (Unbox a, Monad m) => (Int -> Bool) -> (Int -> a) -> Int -> m (Array U DIM1 a)


-- | Functions specialised for arrays of dimension 2.
module Data.Array.Repa.Specialised.Dim2

-- | Check if an index lies inside the given extent. As opposed to
--   <a>inRange</a> from <a>Data.Array.Repa.Index</a>, this is a
--   short-circuited test that checks that lowest dimension first.
isInside2 :: DIM2 -> DIM2 -> Bool

-- | Check if an index lies outside the given extent. As opposed to
--   <a>inRange</a> from <a>Data.Array.Repa.Index</a>, this is a
--   short-circuited test that checks the lowest dimension first.
isOutside2 :: DIM2 -> DIM2 -> Bool

-- | Given the extent of an array, clamp the components of an index so they
--   lie within the given array. Outlying indices are clamped to the index
--   of the nearest border element.
clampToBorder2 :: DIM2 -> DIM2 -> DIM2

-- | Make a 2D partitioned array from two others, one to produce the
--   elements in the internal region, and one to produce elements in the
--   border region. The two arrays must have the same extent. The border
--   must be the same width on all sides.
makeBordered2 :: (Source r1 a, Source r2 a) => DIM2 -> Int -> Array r1 DIM2 a -> Array r2 DIM2 a -> Array (P r1 (P r2 (P r2 (P r2 (P r2 X))))) DIM2 a

module Data.Array.Repa.Stencil.Dim2

-- | Wrapper for <a>makeStencil</a> that requires a DIM2 stencil.
makeStencil2 :: Num a => Int -> Int -> (DIM2 -> Maybe a) -> Stencil DIM2 a

-- | QuasiQuoter for producing a static stencil defintion.
--   
--   A definition like
--   
--   <pre>
--   [stencil2|  0 1 0
--               1 0 1
--               0 1 0 |]
--   
--   </pre>
--   
--   Is converted to:
--   
--   <pre>
--   makeStencil2 (Z:.3:.3)
--      (\ix -&gt; case ix of
--                Z :. -1 :.  0  -&gt; Just 1
--                Z :.  0 :. -1  -&gt; Just 1
--                Z :.  0 :.  1  -&gt; Just 1
--                Z :.  1 :.  0  -&gt; Just 1
--                _              -&gt; Nothing)
--   
--   </pre>
stencil2 :: QuasiQuoter
type PC5 = P C (P (S D) (P (S D) (P (S D) (P (S D) X))))

-- | Apply a stencil to every element of a 2D array.
mapStencil2 :: Source r a => Boundary a -> Stencil DIM2 a -> Array r DIM2 a -> Array PC5 DIM2 a

-- | Like <a>mapStencil2</a> but with the parameters flipped.
forStencil2 :: Source r a => Boundary a -> Array r DIM2 a -> Stencil DIM2 a -> Array PC5 DIM2 a


-- | Efficient computation of stencil based convolutions.
module Data.Array.Repa.Stencil

-- | Represents a convolution stencil that we can apply to array. Only
--   statically known stencils are supported right now.
data Stencil sh a

-- | Static stencils are used when the coefficients are fixed, and known at
--   compile time.
StencilStatic :: !sh -> !a -> !sh -> a -> a -> a -> Stencil sh a
[stencilExtent] :: Stencil sh a -> !sh
[stencilZero] :: Stencil sh a -> !a
[stencilAcc] :: Stencil sh a -> !sh -> a -> a -> a

-- | How to handle the case when the stencil lies partly outside the array.
data Boundary a

-- | Use a fixed value for border regions.
BoundFixed :: !a -> Boundary a

-- | Treat points outside the array as having a constant value.
BoundConst :: !a -> Boundary a

-- | Clamp points outside to the same value as the edge pixel.
BoundClamp :: Boundary a

-- | Make a stencil from a function yielding coefficients at each index.
makeStencil :: Num a => sh -> (sh -> Maybe a) -> Stencil sh a


-- | Functions without sanity or bounds checks.
module Data.Array.Repa.Unsafe

-- | Backwards permutation of an array's elements.
unsafeBackpermute :: forall r sh1 sh2 e. (Shape sh1, Source r e) => sh2 -> (sh2 -> sh1) -> Array r sh1 e -> Array D sh2 e

-- | Default backwards permutation of an array's elements. If the function
--   returns <a>Nothing</a> then the value at that index is taken from the
--   default array (<tt>arrDft</tt>)
unsafeBackpermuteDft :: forall r1 r2 sh1 sh2 e. (Shape sh1, Shape sh2, Source r1 e, Source r2 e) => Array r2 sh2 e -> (sh2 -> Maybe sh1) -> Array r1 sh1 e -> Array D sh2 e

-- | Take a slice from an array, according to a given specification.
--   
--   For example, to take a row from a matrix use the following:
--   
--   <pre>
--   slice arr (Any :. (5::Int) :. All)
--   </pre>
--   
--   To take a column use:
--   
--   <pre>
--   slice arr (Any :. (5::Int))
--   </pre>
unsafeSlice :: (Slice sl, Shape (FullShape sl), Source r e) => Array r (FullShape sl) e -> sl -> Array D (SliceShape sl) e

-- | Extend an array, according to a given slice specification.
--   
--   For example, to replicate the rows of an array use the following:
--   
--   <pre>
--   extend (Any :. (5::Int) :. All) arr
--   </pre>
unsafeExtend :: (Slice sl, Shape (SliceShape sl), Source r e) => sl -> Array r (SliceShape sl) e -> Array D (FullShape sl) e

-- | Unstructured traversal.
unsafeTraverse :: forall r sh sh' a b. (Source r a, Shape sh) => Array r sh a -> (sh -> sh') -> ((sh -> a) -> sh' -> b) -> Array D sh' b

-- | Unstructured traversal over two arrays at once.
unsafeTraverse2 :: forall r1 r2 sh sh' sh'' a b c. (Source r1 a, Source r2 b, Shape sh, Shape sh') => Array r1 sh a -> Array r2 sh' b -> (sh -> sh' -> sh'') -> ((sh -> a) -> (sh' -> b) -> sh'' -> c) -> Array D sh'' c

-- | Unstructured traversal over three arrays at once.
unsafeTraverse3 :: forall r1 r2 r3 sh1 sh2 sh3 sh4 a b c d. (Source r1 a, Source r2 b, Source r3 c, Shape sh1, Shape sh2, Shape sh3) => Array r1 sh1 a -> Array r2 sh2 b -> Array r3 sh3 c -> (sh1 -> sh2 -> sh3 -> sh4) -> ((sh1 -> a) -> (sh2 -> b) -> (sh3 -> c) -> sh4 -> d) -> Array D sh4 d

-- | Unstructured traversal over four arrays at once.
unsafeTraverse4 :: forall r1 r2 r3 r4 sh1 sh2 sh3 sh4 sh5 a b c d e. (Source r1 a, Source r2 b, Source r3 c, Source r4 d, Shape sh1, Shape sh2, Shape sh3, Shape sh4) => Array r1 sh1 a -> Array r2 sh2 b -> Array r3 sh3 c -> Array r4 sh4 d -> (sh1 -> sh2 -> sh3 -> sh4 -> sh5) -> ((sh1 -> a) -> (sh2 -> b) -> (sh3 -> c) -> (sh4 -> d) -> sh5 -> e) -> Array D sh5 e
