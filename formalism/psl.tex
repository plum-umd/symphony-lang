\documentclass[10pt]{article}

\usepackage{times}
\usepackage{fullpage}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathpartir}
\usepackage{color}
\usepackage{xspace}

%%%%% DEFS %%%%%%

\newcommand{\rulelab}[1]{{\small \textsc{#1}}}
\newcommand{\kw}[1]{\ensuremath{\mathtt{#1}}}

% Types
\newcommand{\tnat}{\ensuremath{\mathtt{nat}}}
\newcommand{\tfun}[3]{\ensuremath{{#1} ~^{#3}\!\rightarrow {#2}}}
\newcommand{\tprod}[2]{\ensuremath{{#1} \times {#2}}}
%\newcommand{\tsum}[4]{\ensuremath{{#1} +^{#3}_{#4} {#2}}}
\newcommand{\tsum}[3]{\ensuremath{{#1} +^{#3} {#2}}}
\newcommand{\trec}[2]{\ensuremath{\mu {#1}.{#2}}}
% \newcommand{\ssec}{\ensuremath{\mathtt{\cdot}}}
% \newcommand{\isec}{\ensuremath{\mathtt{pmap}}}
% \newcommand{\sshare}[1]{\ensuremath{\mathtt{shr}~{#1}}}
% \newcommand{\sectyp}[3]{\ensuremath{{#1} \{~{#2}:{#3}~\}}}
  
% Terms
\newcommand{\ebinop}[2]{\ensuremath{{#1}~\oplus~{#2}}}
\newcommand{\elet}[3]{\ensuremath{\kw{let}~#1\, =\, #2~\kw{in}\;{#3}}}
\newcommand{\epar}[2]{\ensuremath{\kw{par}~{#1}~{#2}}}
\newcommand{\esec}[2]{\ensuremath{\kw{sec}~{#1}~{#2}}}
\newcommand{\ereveal}[4]{\ensuremath{\kw{reveal}^{#1}_{#4}~{#2}~{#3}}}
\newcommand{\econd}[3]{\ensuremath{\kw{match}~{#1}~\kw{with}~x.{#2} \diamond {#3}}}
%\newcommand{\emux}[3]{\ensuremath{\kw{mux}~{#1}~\kw{?}~x.{#2}~\kw{:}~x.{#3}}}
\newcommand{\emux}[3]{\ensuremath{\kw{mux}~{#1}~\kw{?}~{#2}~\kw{:}~{#3}}}
\newcommand{\eshare}[4]{\ensuremath{\kw{share}^{#2}_{#1}~{#3}~{#4}}}
%\newcommand{\esharesum}[4]{\ensuremath{\kw{sharesum}^{#2}_{#1}~{#3}~{#4}}}
\newcommand{\einj}[2]{\ensuremath{\kw{inj}_{#1}~{#2}}}
\newcommand{\eread}{\ensuremath{\kw{read}}}
\newcommand{\ewrite}[1]{\ensuremath{\kw{write}~{#1}}}
\newcommand{\epair}[2]{\ensuremath{\langle {#1}, {#2} \rangle}}
\newcommand{\eproj}[2]{\ensuremath{\kw{\#}}_{#1}~{#2}}
\newcommand{\elam}[2]{\ensuremath{\lambda {#1}.{#2}}}
\newcommand{\eapp}[2]{\ensuremath{{#1}~{#2}}}
\newcommand{\efix}[3]{\ensuremath{\kw{fix}~{#1}.\elam{#2}{#3}}}
\newcommand{\efold}[2]{\ensuremath{\kw{fold}_{#1}~{#2}}}
\newcommand{\eunfold}[1]{\ensuremath{\kw{unfold}~{#1}}}
\newcommand{\vshare}[3]{\ensuremath{\{{#3}\}^{#1}_{#2}}}
\newcommand{\vloc}[2]{\ensuremath{{#1}\kw{@}{#2}}}
\newcommand{\vclos}[2]{\ensuremath{\mathbf{clos}~({#1},{#2})}}

% Judgments
\newcommand{\hastyp}[4]{\ensuremath{{#1} \vdash_{#2} {#3} : {#4}}}
%\newcommand{\canshare}[1]{\ensuremath{\text{isFlat } {#1}}}
\newcommand{\subtype}{\ensuremath{<:}}
\newcommand{\issub}[2]{{#1} \subtype {#2}}
\newcommand{\eval}[4]{\ensuremath{\config{#1}{#3} \longrightarrow_{#2} {#4}}}

% Aux
\newcommand{\env}{\ensuremath{\sigma}}
\newcommand{\config}[2]{\ensuremath{\langle{#1},{#2}\rangle}}
\newcommand{\locof}[2]{\ensuremath{\mathit{loc}_{#1}~{#2}}}
\newcommand{\getat}[2]{\ensuremath{\mathit{on}_{#1}~{#2}}}
% \newcommand{\ctxt}{\ensuremath{\mathcal{E}}}
% \newcommand{\pctxt}{\ensuremath{\mathcal{P}}}

\newcommand{\lang}{\textsc{corePSL}\xspace}

%%%%%%%%%%

\newcommand{\mwh}[1]{\textcolor{red}{Mike: #1}}

\title{\lang: A core formalism for the PANTHEON Source Language}
\author{Michael Hicks and the PANTHEON Team}

\begin{document}

\maketitle

\section{Introduction}

This document defines \lang, a core calculus modeling PSL, the
\emph{Pantheon Source Language} for programming secure multiparty
computations (MPCs). The \lang core calculus consists of the key features of PSL,
leaving out features that can be encoded in terms of the core. 

PSL (and \lang) was inspired by the MPC programming language
Wysteria. Like Wysteria, MPCs are written as a single program to be
executed by multiple parties. Like Wysteria, PSL programs have
\emph{par blocks} that define code to be executed at (a subset of)
each of the principals' local hosts. Wysteria also defined \emph{sec
  blocks} to be executed by a set of parties, jointly, as an
MPC\@. PSL generalizes Wysteria's notion of sec blocks by separating
the notions of secret sharing, circuit construction (over shares), and
computation of the final result, all of which were combined to define
the essence of a sec block. This decomposition adds important
flexibility, particularly when computations can vary with input size,
and/or need to be carried out in multiple rounds and/or at multiple
parties' hosts. As a formalism, \lang is also somewhat better
engineered, and is pleasantly simple.

The rest of this document is organized as follows. In
Section~\ref{sec:syntax} we present the syntax of \lang, along
discussion of how other features available in PSL can be encoded in
terms of the core syntax. Section~\ref{sec:examples} presents a series
of example programs written \lang. Section~\ref{sec:STsemantics}
presents the single-threaded semantics of \lang, while
Section~\ref{sec:MTsemantics} presents the distributed
semantics. Section~\ref{sec:typing} presents the \lang type system and
states our core theoretical result, which is that for type-correct
programs, the single-threaded semantics simulates the distributed
semantics. 

\begin{figure}[h]
  \centering
  \[\begin{array}{rlcll}
      \text{Principal} & p, q \\
      \text{Principal set} & P, Q \\
    \text{Execution modes} & m  & ::=  & $P$ & \text{par mode with principal set $P$ (could be $\emptyset$)} \\
      \text{Protocol} & \psi & ::= & \cdot & \text{cleartext} \\
                       && \mid & \phi & \text{encryption format} \\
      \text{Types} & \tau & ::=  & \tnat^m_\psi & \text{a base type} \\
                       && \mid & \tprod{\tau}{\tau} & \text{pairs} \\
%                       && \mid & \tsum{\tau}{\tau}{m}{\psi} & \text{sums} \\
                       && \mid & \tsum{\tau}{\tau}{m} & \text{sums} \\
                       && \mid & \trec{\alpha}{\tau} & \text{(iso)recursive types} \\
                       && \mid & \alpha & \text{type variables (for recursive types)} \\
                       && \mid & \tfun{\tau}{\tau}{m} & \text{functions} \\
      \text{Protocol} & \psi & ::= & ... & \text{MPC type} \\
      \text{Expressions} & e & ::= & n & \text{naturals} \\
                       && \mid & x & \text{variables} \\
                       && \mid & \eread & \text{read from terminal}\\
                       && \mid & \ewrite{e} & \text{write to terminal}\\
                       && \mid & \epair{e_1}{e_2} & \text{pair construction}\\
                       && \mid & \eproj{i}{e} & \text{pair elem, }i \in \{1,2\}\\
                       && \mid & \eshare{\psi}{P}{Q}{e} & \text{$\psi$ shares of {\tnat} at $P$ to $Q$} \\
                       % && \mid & \esharesum{\psi}{P}{Q}{e} & \text{$\psi$ shares of sum $P$ to $Q$} \\
                       && \mid & \ereveal{P}{Q}{e}{\psi} & \text{distribute result in $\psi$ at $Q$ to $P$}\\
                       && \mid & \ebinop{e_1}{e_2}  & \text{binary operation} \\
                       && \mid & \emux{e}{e_1}{e_2}  & \text{MPC conditional} \\
                       && \mid & \einj{i}{e} & \text{sum elem, }i \in \{1,2\}\\
                       && \mid & \econd{e}{e_1}{e_2}  & \text{sum elimination} \\
                       && \mid & \efold{\trec{\alpha}{\tau}}{e} & \text{rectype intro}\\
                       && \mid & \eunfold{e} & \text{rectype elim}\\
                       && \mid & \epar{P}{e} & \text{parallel evaluation}\\
                       && \mid & \elam{x}{e}  & \text{abstraction} \\
                       && \mid & \efix{f}{x}{e} & \text{recursive abstraction} \\
                       && \mid & \eapp{e_1}{e_2}  & \text{application} \\
                       && \mid & \elet{x}{e_1}{e_2}  & \text{sequencing} \\
  \end{array}
  \]
  \caption{Syntax of \lang}
  \label{fig:syntax}
\end{figure}

\newpage

\section{Syntax}
\label{sec:syntax}

The syntax of \lang is in Figure~\ref{fig:syntax}. Some derived
constructs (syntactic sugar) are given in Section~\ref{sec:derived}.

\subsection{Types}

There are two key concepts in types. First is their \emph{location},
designated $m$. Natural numbers, sums, and functions are located at
particular places; only here can they be computed on. Second (and in
addition), natural numbers can be \emph{encrypted} as secret
shares (with a different share at each party among the locations
$m$). We annotate the sharing protocol (GMW, Yao, etc.) as $\psi$; the
``cleartext'' protocol is $\cdot$ (or simply elided, to reduce
clutter).

Pairs and recursive types are not located in the same sense as the
other values. That is, all parties present in a computation when the
pair or recursive type is created can see its structure. They may not, however,
be able to access its values, as these could be located at particular
locations.

\subsection{Expressions}

Many of \lang's expression forms are standard, including
variables $x$; integers $n$; pair introduction $\epair{e_1}{e_2}$ and
elimination (projection) $\eproj{i}{e}$; sum introduction
$\einj{i}{e}$ and elimination $\econd{e}{e_1}{e_2}$ (where $x$ binds
in $e_1$ and $e_2$, only one of which is evaluated); recursive type
introduction $\efold{\trec{\alpha}{\tau}}{e}$ and elimination
$\eunfold{e}$; and abstraction $\elam{x}{e}$ (and recursive
abstraction $\efix{f}{x}{e}$), application $\eapp{e_1}{e_2}$, and
local variable binding $\elet{x}{e_1}{e_2}$. Some of these expressions
are located at $m$, per the discussion on types, above.

The expression $\epar{P}{e}$ says that $e$ may be computed at
principals $P$ in parallel (hence the syntax $\kw{par}$). That is,
every principal $p \in P$ may evaluate $e$. We say ``may'' here
because nesting such an expression in another $\kw{par}$ could shrink
the set of principals; e.g., $e$ will be evaluated only by those in
$P \cap Q$ in $\epar{Q}{\epar{P}{e}}$. We take this approach to avoid
otherwise odd behaviors that could arise.

We call the set of principals $P$ computing an expression in parallel
the \emph{mode} $m$. The semantics of many constructs depends on the
mode. A number $n$ created in mode $m$ (having type $\tnat^m$) can
only be computed on by principals $p \in m$; other principals do not
have access to it. This means that adding two numbers located at $m$
can only be done if principals $P \subseteq m$ are present; additional
principals wouldn't know what to do. The same goes for functions and
sums. The $\eread$ and $\ewrite{e}$ expressions read from and write to
the console. To be clear about \emph{which} console, the mode should
be a singleton principal.

On the other hand, it's possible that a variable $x$ will be bound at
$p$ but have a value only accessible to $q$ in it. Principal $p$ can
still manipulate a placeholder for $x$ but should never look at its
contents (i.e., to operate on it).

We conclude with the MPC-specific constructs in \lang.

Expression $\eshare{\psi}{P}{Q}{e}$ evaluates $e$ to a natural number,
and then $P$ secret-shares this number with the principals in $Q$. All
principals $P \cup Q$ must be present (i.e.,
$m \supseteq Q \cup P$). Moreover, $P$ must be a singleton, so we
are clear who is doing the sharing. The resulting value has type
$\tnat^Q_\psi$.

At this point, principals $Q$ can all mutually compute on the share,
using $\ebinop{e_1}{e_2}$ and $\emux{e}{e_1}{e_2}$. The former is
meant to be a generic binary operator, e.g., addition. The latter is a
multiplexor: We evaluate both $e_1$ and $e_2$ and select the result
based on whether $e$ is zero or non-zero. All sub-expressions must be
shared by the same principals, using the same protocol. Moreover, all
principals that have a share must be present when computing on
it. E.g., for numbers of type $\tnat^{\{p,q\}}_\psi$ to be added, both
$p$ and $q$ must be present. Even stronger, it must be \emph{exactly}
these principals which are present; we do not allow more, since other
principals would not be able to carry out the operation (they don't
have access to the share).

Finally, an MPC is completed by invoking
$\ereveal{P}{Q}{e}{\psi}$. This takes a number shared among principals
$P$ and shares its decrypted (cleartext) result with principals in
$Q$. Doing so requires that all of $P \cup Q$ are present in the
current mode so that the shareholders can agree to send the value and
the result-receivers are there to receive it.

\subsection{Derived Expressions}
\label{sec:derived}

Some useful constructs can be encoded using \lang features (or via
obvious language extensions). 

\subsubsection{Encrypted Sums}

An encrypted sum can be represented as a value of the type
$\tprod{\tnat^m_\psi}{(\tprod{\tau_1}{\tau_2})}$. Here, the first
element is a boolean that represents whether the ``real'' portion of
the sum is the left side. We can introduce (encrypt) an existing sum
by doing the following:
\begin{verbatim}
let sharesum e def_lhs def_rhs =
  match e with
    x.(share 1,x,def_rhs)
  | x.(share 0,def_lhs,x)
\end{verbatim}
We can eliminate an encrypted sum by using $\kw{mux}$, which forces us
to produce a $\tnat^m_\psi$, to ensure obliviousness:
\begin{verbatim}
let muxshare e t_fun f_fun =
  let (x,(l,r)) = e in
  mux x ? t_fun l : f_fun r
\end{verbatim}
While \verb+t_fun+ and \verb+f_fun+ are notated as functions, instead
it makes sense to make these proper syntax in \lang, with a
binding form like $\kw{match}$.

\subsubsection{Generalized Mux and Reveal}
\label{sec:generalmux}

 The $\kw{mux}$ construct is restricted to returning encrypted
$\tnat$s. We can generalize this to returning pairs of encrypted
$\tnat$s:
\begin{verbatim}
muxtopair e e1 e2 =
  let b = e in
  let (l1,r1) = e1 in
  let (l2,r2) = e2 in
  (mux b l1 l2, mux b r1 r2)
\end{verbatim}
With this encoding, we can likewise support multiplexing on encrypted
sums and likewise encrypted recursive types.

We can similarly generalize the $\kw{reveal}$ construct to work on types
that are not numbers, but pairs, sums, or recursive types---just as we
\kw{mux} on the elements of a pair here, we can \kw{reveal} elements
of a pair, too, with a single construct.

\subsubsection{Wire Bundles and Solo Mode}

A \emph{wire bundle} conceptually represents a single logical value,
but each party has its own distinct copy. We represent it as a product
where each element of the product is only visible to a single
party. For simplicity, consider the smallest one:
$\tprod{\tnat^{\{p\}}_\psi}{\tnat^{\{q\}}_\psi}$. One way we could
write this as a derived type might be $W~\{p,q\}~\tnat^\alpha_\phi$
where the interpretation is to substitute each principal in the first
argument to $W$ (a principal set $P$) for $\alpha$ in the second
argument (a type $\tau$).

To operate on a wire bundle we can use \emph{solo mode}, exemplified
in the construct $\kw{wmap}$:
\begin{verbatim}
let wmap (x:W {p,q} t) (f:t -> t0) =
  (par {p} (f (#1 x)), 
   par {q} (f (#2 x)))
\end{verbatim}
This runs the function $f$ on each element of the wire bundle, on its
respective host, and packages the results in another wire bundle. Note
that $f$ would need to be inlined at each call site because we don't
support polymorphism in \lang. Moreover, $f$ might contain
occurrences of $\alpha$ which would  be substituted with
\texttt{\{p\}} in the first half of the pair, and \texttt{\{q\}} in
the second.

The above is basically Wysteria's notion of wire bundles when
constructed and operated on in $\kw{par}$ mode, and the \texttt{wmap}
above is similar to Wysteria's \texttt{waps}. Wysteria's notion of a
wire bundle in \texttt{sec} mode is basically a product of
shares, which is generated automatically by calling $\kw{share}$ on
each element of the input wire bundle. This is easily done:

\bigskip
\noindent
\texttt{wmap w }($\elam{x}{\eshare{\phi}{\alpha}{\{p,q\}}{x}}$)
\bigskip

\noindent
The \texttt{wmap} will produce a pair of shares. Notice the
$\alpha$ annotation on the $\kw{share}$---this will match the (solo)
mode of the principal doing the sharing, after substitution.

You can imagine generalizing this to wire bundles of arbitrary (but
fixed) size. You can also easily imagine converting this pair to a
list, and then supporting equivalent constructs like \texttt{wfold}.

We might want a way to run code over a wire bundle in which parties
are not in solo mode. For example, they could run in full par mode
(with multiple principals) but then accesses to the individual elements
could be dropped to a single mode, for those accesses. For this, you
need a map from principal $\alpha$ to index in the pair for $\alpha$'s
value. For the accessor in the code, you use the map to extra from the
pair. Maybe use ``self'' and not $\alpha$.

\subsection{Future work: First-class principals and dependent types}

One aspect of Wysteria not encoded here is the idea of
\emph{principals as data}, and more generally, having a first-class
representation of a set of principals. Run-time principal sets are
useful for writing computations that are generic over the identity and
number of principals involved in a computation. For example, you could
make a generic function that computes the maximum of any number of
parties' input values.

For principal sets to work, we must generalize constructs in the
language that are currently operating over sets of principals $P$. At
present, the typing and compatibility judgments rely on knowing the
precise makeup of a principal set. This would have to change to permit
unknown principal sets whose contents are governed by set
constraints. A simple manifestation of this point is that
$\ereveal{P}{Q}{e}{\psi}$ should be $\ereveal{e_q}{e_q}{e}{\psi}$
where $e_P$ and $e_q$ are principal sets; likewise for $\kw{share}$
and $\kw{par}$. We would also need dependent types; for example if we
had a run-time principal set stored in variable $s$, then we need to
express types like $\tnat^s$, which indicates a type compatible with
all principals in $s$. One interesting point is that we would like
set-indexed recursive datastrutures like lists, e.g., so that each
element of a list could belong to a different principal. This
generalized the fixed-size notion of wire bundles given above.

We leave it to future work to flesh out the details. 

\section{Examples}
\label{sec:examples}

\subsection{Encoding lists of shares}

\newcommand{\twoprins}{\ensuremath{\{a,b\}}}

A list of shares between $a$ and $b$ would have type
$\trec{\alpha}{\tsum{(\tprod{\tnat^{\twoprins}_\psi}{\alpha})}{\tnat^{\twoprins}}{\twoprins}}$. In
short, a list of shares is either a pair, where the first element is a
\twoprins-share and the second is a list, or it's a normal integer
(i.e., the NULL terminator). Notice that neither the recursive type
nor the sum itself are encrypted---this means that the list's size
(and the fact that's a list) is known and evident to both $a$ and $b$.

Here's an example of how $a$ and $b$ could create a list with a share
originating from each of them:
\begin{verbatim}
let l = par {a,b}
  let x = par {a} read in
  let y = par {b} read in
  let xs = share{a} {a,b} x in
  let ys = share{b} {a,b} y in
  fold (inl (xs, fold (inl (ys, fold (inr 0)))))
\end{verbatim}
Here's a function that sums the elements in the list:
\begin{verbatim}
let sum = par {a,b}
  fix f.lam y.
    match (unfold y) with x.
      let (x1,x2) = x in
      x1 + (f x2)
    | share{a} {a,b} 0
\end{verbatim}
Notice that we have to explicitly share constants. In this case, the
\verb+0+ is shared by $a$ to $a$ and $b$.

Finally, we could apply \verb+sum+ to \verb+l+ and reveal the result
to both $a$ and $b$:
\begin{verbatim}
par{a,b}
  reveal{a,b} {a,b} (sum l)
\end{verbatim}

Suppose we tried to run \verb+sum+ just in \verb+par{a}+---what would
happen? It will fail because we require all parties having a share to
be present when the share is computed on (here, by
\verb!+!). Conversely, if we tried to run in mode \verb+par{a,b,c}+ it
would also fail: parties \emph{without} a share cannot carry out
computations on it.

Another question: What if we ``encrypted'' the sum type that defines
the list (per the above encoding)? This would imply that both the left
and right side of the sum are always possible, so both would be
maintained. However, since this is a recursive type and we cannot
support infinitely sized data structures, we could not actually
construct elements of this type! The reason you can construct
recursive data structures at all is that there is eventually a base
case, i.e., just one side of the sum, here the $\tnat^{\{a,b\}}_\psi$
part. But when you are required provide \emph{both} sides, you never
get to the base case (only). You could do a constant-length list, but
not using a recursive type; you'd have to do a finite (by hand)
unrolling.

\subsection{Lists of private multi-party values}

As another thought experiment, suppose we have a list with values from
both $a$ and $b$, but unencrypted?

A list of shares between $a$ and $b$ would have type
$\trec{\alpha}{\tsum{(\tprod{(\tprod{\tnat^{\{a\}}}{\tnat^{\{b\}}})}{\alpha})}{\tnat^{\twoprins}}{\twoprins}}$.
This list is like the earlier one, but instead of shared numbers as
its contents, it has a pair of normal numbers, with the left as
visible only to $a$ and the right visible only to $b$.

Summing each principal's components would look like this:
\begin{verbatim}
let sum2 = par {a,b}
  fix f.lam y.
    match (unfold y) with x.
      let ((xa,xb),x2) = x in
      let (sa,sb) = f x2 in
      let l = par{a} sa+xa in
      let r = par{b} sb+xb in
      (l,r)
    | (par{a} 0,par{b} 0)
\end{verbatim}
This example makes evident that each party needs to maintain the
complete structure of the list, but only has actual values for its own
parts of it; the other party's values will just be placeholders.

\subsection{Other examples}

\mwh{More}

\begin{verbatim}
(fun x -> { par : C } x) 
  ({ par : A, B, C } reveal{ C } (share{ yao : A, B } 0))
\end{verbatim}
This is allowed by the type system. The $\kw{reveal}$ produces a value
at $C$, which may be ``passed through'' the par block at \verb+{A, B,C}+. 
This is then passed in and used in the function.

\begin{verbatim}
par(A,B) 
  let x = par(A) 0 in
  let y = par(B) 1 in
  par(A) 
    let z = (x,y) in #1 z
\end{verbatim}
Should work.

\begin{verbatim}
(fun x -> { par : B } ((), x)) ({ par : A } 0)
\end{verbatim}
The above is allowed. And equivalently, so is this (which in a
previous incarnation would have been rejected):
\begin{verbatim}
{ par : B } ((), ({ par : A } 0))
\end{verbatim}

\section{Semantics (Single Threaded)}
\label{sec:STsemantics}

\begin{figure}
  \[\begin{array}{rlcll}
      \text{Store} & \sigma & \in & \mathbf{Var} \rightharpoonup \mathbf{Val}\\
      \text{Locatable value} & u & ::=  & n & \text{numbers} \\
                             && \mid & \einj{i}{v} & \text{sum elem, }i \in \{1,2\}\\
                             && \mid & \vclos{\env}{e}  & \text{closure} \\
                             && \mid & \vshare{Q}{\psi}{e} & \text{$\psi$-$Q$ share of evaluating $e$} \\
      \text{Value} & v  \in \mathbf{Val} & ::=  & u & \text{locatable value}\\
                       && \mid & \epair{v_1}{v_2} & \text{pair value}\\
                       && \mid & \efold{\trec{\alpha}{\tau}}{v} & \text{rectype value}\\
                       && \mid & \vloc{u}{P} & \text{located value}\\
      % \text{Eval Context} & \ctxt & ::= & \multicolumn{2}{l}{\bullet \mid\epair{\ctxt}{e} \mid
      %                        \epair{v}{\ctxt} \mid \eproj{i}{\ctxt}}  \\
      %          && \mid & \multicolumn{2}{l}{\eshare{\psi}{P}{Q}{\ctxt} \mid
      %                        \ereveal{P}{Q}{\ctxt}{\psi} \mid \ebinop{\ctxt}{e_2} \mid \ebinop{v}{\ctxt} }  \\
      %          && \mid & \multicolumn{2}{l}{\emux{\ctxt}{e_1}{e_2}
      %                    \mid \emux{v}{\ctxt}{e_2} \mid \emux{v}{v_1}{\ctxt}  }  \\
      %          && \mid & \multicolumn{2}{l}{\einj{i}{\ctxt} \mid \econd{\ctxt}{e_1}{e_2} }  \\
      %          && \mid & \multicolumn{2}{l}{\efold{\trec{\alpha}{\tau}}{\ctxt} \mid \eunfold{\ctxt}}  \\
      %          && \mid & \multicolumn{2}{l}{\eapp{\ctxt}{e} \mid
      %                    \eapp{v}{\ctxt} \mid \elet{x}{\ctxt}{e_2} }\\
    \end{array}
  \]

\[\begin{array}{l@{~~=~~}l}
    \locof{P}{n} & \vloc{n}{P} \\
    \locof{P}{\einj{i}{v}} & \vloc{(\locof{P}{v})}{P} \\
    \locof{P}{\vclos{\env}{\elam{x}{e}}} & \vloc{(\vclos{(\locof{P}{\env})}{\elam{x}{e}})}{P}\\
    \locof{P}{\vshare{Q}{\psi}{e}} & \vloc{(\vshare{Q}{\psi}{e})}{P} \\
    \locof{P}{\epair{v_1}{v_2}} & \epair{\locof{P}{v_1}}{\locof{P}{v_2}}\\
    \locof{P}{ \efold{\trec{\alpha}{\tau}}{v}} &  \efold{\trec{\alpha}{\tau}}{\locof{P}{v}}\\
    \locof{P}{\vloc{u}{Q}} & \vloc{(\locof{P}{u})}{R} \qquad\text{where }R = P \cap Q\\
    \locof{P}{\sigma} & \{ x \mapsto v' \mid \sigma(x) = v \land \locof{P}{v} = v' \}\\
    \multicolumn{2}{c}{}\\
    \getat{P}{(\vloc{u}{Q})} & u \qquad \text{where }Q \vdash P\\
    \getat{P}{v} & v \qquad \text{for all other $v$ syntactic forms}\\
  \end{array}
\]
\caption{Semantics auxiliaries}
\label{fig:auxsem}
\end{figure}

\begin{figure}
$$
\begin{array}{c}
    \inferrule*[lab=E-Nat]
    {
    }
    {
    \eval{\env}{m}{n}{n}
    }
    \qquad

    \inferrule*[lab=E-Var]
    {
    \env(x) = v
    }
    {
    \eval{\env}{m}{x}{v}
  }\qquad

  \inferrule*[lab=E-Read]
    {
  m\text{ is a singleton}
    }
    {
    \eval{\env}{m}{\eread}{n}
    }
    \qquad

      \inferrule*[lab=E-Write]
      {
      m\text{ is a singleton}\\\\
      \eval{\env}{m}{e}{v}\\
  \getat{m}{v} = n
    }
    {
    \eval{\env}{m}{\ewrite{e}}{n}
    }
    \\ \\

      \inferrule*[lab=E-Par]
    {
  Q = m \cap P\\\\
  Q = \emptyset \Rightarrow v = \locof{Q}{0}\\\\
    Q \not= \emptyset \Rightarrow
    \env' = \locof{P}{\env} \land
    \eval{\env'}{{Q}}{e}{v}
    }
    {
    \eval{\env}{m}{\epar{P}{e}}{v}
    } \qquad
  
    \inferrule*[lab=E-Pair]
    {
    \eval{\env}{m}{e_1}{v_1}\\\\
    \eval{\env}{m}{e_2}{v_2}
    }
    {
    \eval{\env}{m}{\epair{e_1}{e_2}}{\epair{v_1}{v_2}}
    }\qquad
    
    \inferrule*[lab=E-Access]
    {
    \eval{\env}{m}{e}{v}\\\\
    \getat{m}{v} = \epair{v_1}{v_2}
    }
    {
    \eval{\env}{m}{\eproj{i}{e}}{v_i}
    }\\\\

    \inferrule*[lab=E-inj]
    {
    \eval{\env}{m}{e}{v}
    }
    {
    \eval{\env}{m}{\einj{i}{e}}{\einj{i}{v}}
    } \qquad
    
    \inferrule*[lab=E-Match]
    {
    \eval{\env}{m}{e}{v_0}\\
    \getat{m}{v_0} = \einj{i}{v_i}\\\\
    \eval{\env[x\mapsto v_i]}{m}{e_i}{v}
    }
    {
      \eval{\env}{m}{\econd{e}{e_1}{e_2}}{v}
    }\\ \\

    \inferrule*[lab=E-Fold]
    {
    \eval{\env}{m}{e}{v}
    }
    {
    \eval{\env}{m}{\efold{\trec{\alpha}{\tau}}{e}}{\efold{\trec{\alpha}{\tau}}{v}}
    } \qquad

    \inferrule*[lab=E-Unfold]
    {
    \eval{\env}{m}{e}{v_0}\\\\
    \getat{m}{v_0} = \efold{\trec{\alpha}{\tau}}{v}
    }
    {
    \eval{\env}{m}{\eunfold{e}}{v}
    } \qquad

    \inferrule*[lab=E-Share]
    {
    m \vdash P\\ m \vdash Q\\\\
    P\text{ is a singleton}  \\\\
    \eval{\env}{m}{e}{v}\\
    \getat{P}{v} = n  
    }
    {
  \eval{\env}{m}{\eshare{\psi}{P}{Q}{e}}{\vloc{\vshare{Q}{\psi}{n}}{Q}}
    }\\ \\
    
    \inferrule*[lab=E-BinopNat]
    {
  \eval{\env}{m}{e_1}{v_1}\\
  \getat{m}{v_1} = n_1\\\\
    \eval{\env}{m}{e_2}{v_2}\\
  \getat{m}{v_2} = n_2\\\\
  n = n_1 \oplus n_2\\
    }
    {
    \eval{\env}{m}{\ebinop{e_1}{e_2}}{n}
    }\qquad

      
    \inferrule*[lab=E-BinopShare]
    {
  \eval{\env}{m}{e_1}{v_1}\\
  \getat{m}{v_1} = \vshare{m}{\psi}{e'_1} \\\\
    \eval{\env}{m}{e_2}{v_2}\\
  \getat{m}{v_2} = \vshare{m}{\psi}{e'_2} \\\\
  v = \vshare{m}{\psi}{\ebinop{e'_1}{e'_2}}
    }
    {
    \eval{\env}{m}{\ebinop{e_1}{e_2}}{v}
    }\\\\

    \inferrule*[lab=E-Mux]
    {
  \eval{\env}{m}{e}{v}\\
  \getat{m}{v} = \vshare{m}{\psi}{e'} \\\\
  \eval{\env}{m}{e_1}{v_1}\\
  \getat{m}{v_1} = \vshare{m}{\psi}{e'_1} \\\\
    \eval{\env}{m}{e_2}{v_2}\\
  \getat{m}{v_2} = \vshare{m}{\psi}{e'_2} \\\\
  v = \vshare{m}{\psi}{\emux{e'}{e_1'}{e_2'}}
    }
    {
    \eval{\env}{m}{\emux{e}{e_1}{e_2}}{v}
    }\qquad

    \inferrule*[lab=E-Reveal]
  {
    m \vdash P\\ m \vdash Q\\\\
    \eval{\env}{m}{e}{v_0}\\
    \getat{P}{v_0} = \vshare{P}{\psi}{e_0}\\\\
    \eval{\env}{m}{e_0}{v}\\
    n = \getat{P}{v} 
    } 
    {
    \eval{\env}{m}{\ereveal{P}{Q}{e}{\psi}}{\vloc{n}{Q}}
    }\\\\
    
   \inferrule*[lab=E-Abs]
    {
    }
    {
    \eval{\env}{m}{\elam{x}{e}}{\vclos{\env}{\elam{x}{e}}}
    }\qquad
   
    \inferrule*[lab=E-Fix]
    {
    }
    {
    \eval{\env}{m}{\efix{f}{x}{e}}{\vclos{\env}{\efix{f}{x}{e}}}
    }\\\\

    \inferrule*[lab=E-App]
    {
  \eval{\env}{m}{e}{v'}\\
    \getat{m}{v'} = \vclos{\env'}{\elam{x}{e'}}\\\\
  \eval{\env}{m}{e_1}{v_1}\\
  \eval{\env'[x \mapsto v_1]}{m}{e'}{v}\\
    }
    {
    \eval{\env}{m}{\eapp{e}{e_1}}{v}
    }\qquad

  
    \inferrule*[lab=E-FixApp]
    {
  \eval{\env}{m}{e}{v'}\\
    \getat{m}{v'} = \vclos{\env'}{\efix{f}{x}{e'}}\\\\
 \eval{\env}{m}{e_1}{v_1}\\
 \eval{\env'[f \mapsto v'][x \mapsto v_1]}{m}{e'}{v}\\
    }
    {
    \eval{\env}{m}{\eapp{e}{e_1}}{v}
    }\\ \\

    \inferrule*[lab=E-Let]
    {
    \eval{\env}{m}{e_1}{v_1}\\\\
    \eval{\env[x\mapsto v_1]}{m}{e_2}{v_2}
    }
    {
    \eval{\env}{m}{\elet{x}{e_1}{e_2}}{v_2}
    }
\end{array}
    $$
\caption{Operational Semantics}
\label{fig:sem}
\end{figure}

We define a big-step operational semantics. The judgment
$\eval{\env}{m}{e}{v}$ states that program
$e$ evaluates under mode $m$ and store $\env$ to a value
$v$. The rules are given in Figure~\ref{fig:sem}.  This is the
``single threaded semantics'' in that we don't have independently
executing parties; rather, we simulate the group of principals
$m$ executing in lockstep.

\subsection{Located values}

To be clear about which values reside on which parties' hosts, we have
a special value form to indicates this. Values are defined in
Figure~\ref{fig:auxsem}. The form $\vloc{u}{P}$ indicates that $u$ is
only visible to principals $p \in P$. Since not all values need to
be explicitly located (if they are in scope, they implicitly
are accessible), we distinguish \emph{locatable} values $u$.
Values for numbers, sums, and closures are standard (closures
have an explicit environment---we don't use substitution), as are
(locatable) values for pairs and recursive types. The value
$\vshare{Q}{\psi}{e}$ represents a circuit for a secure computation
under scheme $\psi$ to be performed by principals in $q \in Q$. Notice
that it contains an expression $e$, not a value $v$; this represents a
``suspended'' computation. 

In the same figure are two functions over values: $\locof{P}{v}$ and
$\getat{v}{P}$. The first is a transformation of $v$ that
``relocates'' it to $P$. For locatable, but not located, values $u$,
we annotate them with $P$. For compound forms we recurse inside them
(sums, pairs, closure environments). Locating an environment locates
its mapped-to values pointwise.  For located values $\vloc{u}{Q}$ we
relocate $u$'s contents and update its location to be $P$ intersected
with $Q$. Note that this intersection could be the $\emptyset$ which
indicates an inaccessible value.

The function $\getat{v}{P}$ attempts to strip off the outermost
location designator so the value $v$ can be computed on. For all
values other than $\vloc{u}{Q}$ this is a no-op. For these, we confirm
that the location $Q$ is compatible with the accessing environment,
written $P \vdash Q$, and given in Figure~\ref{fig:aux} (there it says
$m \vdash m'$). Extrapolating: $Q \vdash P$ is never true if the value's
location $Q$ is $\emptyset$; it will be true if $Q$ contains all
principals in the requested mode $P$.

\subsection{Operational rules}

Now we turn to the rules. Many rules are essentially standard, in
particular \rulelab{E-Nat}, \rulelab{E-Pair}, \rulelab{E-Inj},
\rulelab{E-Var}, \rulelab{E-Let}, \rulelab{E-Abs}, and \rulelab{E-Fix}. Many others are
\emph{almost} standard, including \rulelab{E-Write}, \rulelab{E-Access},
\rulelab{E-Match}, \rulelab{E-Unfold}, \rulelab{E-BinopNat}, 
\rulelab{E-App}, and \rulelab{E-FixApp}. These differ from their
standard counterparts in that 
they refer to $\getat{m}{v}$ in the premise---as elimination forms,
they have to have to strip off any location information to use the
value. This operation will fail if the value is not available to
(located at) \emph{all} principals in the required mode $m$; the type system
aims to rule out this sort of problem. \rulelab{E-Read} and
\rulelab{E-Write} are unsurprising; notably, they only work in a
singleton context---we need to know 
which principal is reading from/writing to their terminal. 

A key invariant of the semantics is the following: \emph{Assuming the
  current environment $\sigma$ is compatible with mode
  $m$ and $\eval{\env}{m}{e}{v}$ then $v$ is also compatible with $m$}. By
"compatible with $m$," recall that we mean that values are located at
principal set(s) $P \subseteq m$. The rules preserve the assumption of
environment compatibility (in the premises) and ensure compatibility
in the conclusion.

Now consider \rulelab{E-Par}, which evaluates
$\epar{P}{e}$. It evaluates $e$ in mode $Q = m \cap P$ to produce
$v_0$; i.e., only those principals in $P$ \emph{also} present $m$ will
run $e$. If $Q$ is empty, then no evaluation takes place, and $0$
(located at $Q = \emptyset$) is returned. (The alternative of running
$e$ with $\emptyset$ as the mode is not equivalent; see discussion
below.) Otherwise, evaluation takes place in environment $\sigma'$,
which is the current environment located at $P$, which is constructed
by intersecting mapped-to values' locations with $P$. Assuming
$\sigma$ is compatible with $m$ already, it just needs to also be
located at $P$, and the result will be compatible with $Q$. On the
other hand the result $v$ need not be explicitly located at $Q$ before
it can be returned, per our invariant.

Let's consider the remaining rules, which focus on multiparty
computation. \rulelab{E-Share} models principal $p \in P$
``encrypting'' an integer, sharing it with principals $Q$. Expression
$e$ is evaluated in the current mode $m$, but the direction is that
just $P$ is doing the sharing; hence we check that $P$ is present in
$m$, and $v$ is located
on $P$. We then encapsulate the extracted number $n$ in a share value,
split between principals at $Q$, which must be present in $m$
(ensuring our invariant on the location of final values).

\rulelab{E-BinopShare} permits multiparty computation on shares. It
makes sure both arguments are available to exactly the executing hosts
and the encapsulates the ``suspended'' computation in a share
itself. \rulelab{E-Mux} produces a multiplexor on shares. It evaluates
its arguments $e$, $e_1$, and $e_2$ to shares, and then constructs a
circuit involving all three.

\rulelab{E-Reveal} eliminates shares by ``forcing'' the suspended
computation in the given share. We require that the principals $P$ who
each have a share are present in $m$, and likewise the principals in
$Q$ to whom the final result is sent.

\paragraph{Discussion}

Rule~\rulelab{E-Par} indicates that if the ``present'' set of
principals $Q$ is $\emptyset$ then $e$ should be skipped, and an
(inaccessible) value returned instead. The alternative is to ``run''
$e$ despite having no principals present.

One important justification for skipping $e$ is that this is what the
distributed semantics will do, in a general sense (see the next
section for more on this). In particular, if
we have $\epar{\{a,b\}}{e}$ running in mode $m = \{ a, b, c \}$ then
what should $c$ do while $a$ and $b$ are each running $e$? The
assumption is that it will skip it. Another way to put this: We can
think of a principal's ``slice'' of an expression as that expression
with $\kw{par}$ sets intersected with that principal. So on $c$ it
would be $\epar{\{a,b\} \cap \{c\}}{e}$ or in other words the
principal set is empty---no relevant principals are ``here''---and we
don't run it. This implies that a $\kw{par}$ block with an empty
principal set should be skipped. 

The alternative is weird. If no-principal blocks should be executed,
how should that be done? The meaning is that no principal sets are
``here'' to run the block, so who exactly is doing the running? 

Suppose we choose to run $e$ with an empty set, say on each principal
$a$, $b$, and $c$. Doing so could have failures or non-termination. For the
former, it could reach a $\kw{reveal}$, $\kw{share}$, $\kw{read}$,
or $\kw{write}$, each of which require certain principals to be
present. Since no principals are present, evaluation will get stuck
at these constructs. This is odd, once again, from the perspective of
the distributed semantics: We would not expect to run $a$'s blocks on
$b$ with an empty principal set because doing so will fail.

You might argue that somehow a $\kw{par}$ block should be run, even
with no principals (somewhere) for its termination behavior. The
analogy would be that you have $\epar{a}{...}$ followed by
  $\epar{b}{...}$ and the first doesn't terminate in the ST semantics,
  precluding running the second block there, whereas in the MT the
  second will run. The argument is somehow that if you don't ``run''
  $\epar{\emptyset}{...}$ blocks, you won't match this kind of
    behavior, if the $...$ would fail to terminate. But I don't think this
is either here nor there; the simulation theorem is about computations
that terminate; we are not obligated to reason about non-terminating
programs. And in any case it's about ``real'' computations; not ones
that are contrived.

\section{Semantics (Multi-threaded)}
\label{sec:MTsemantics}

\mwh{TODO. Thoughts follow.}

Each party $p$ has its own store $\env_p$ and program $e_p$, rather
than there being a global program. Evaluating these is equivalent to
running with $m = \{ p \}$, i.e., for a single party, roughly
speaking.

A key change in the design of ST mode would be to make it that if you
start the same program, meant to be run by $p$ and $q$ together, with
just $p$ or just $q$, it will do so correctly. This will happen as
long as the $\kw{par}$ mode rule is correct: It will just intersect the
annotation $P$ on the $\kw{par}$ with the current mode---a
singleton---and then that single party will continue on and do the
right thing. 

Computations that require coordination will be done in a mode that
contains the coordinating parties. The single-mode parties must
synchronize before carrying out the computation. They will wait for
each party to reach the same spot, carry out the computation, and
continue on with whatever their local result should be. The type
system should ensure things line up.

More details:
\begin{itemize}
\item $\eshare{P}{\psi}{Q}{e}$ requires coordination among $P \cup Q$,
  where $P$ is a singleton. Somehow, the result of this computation
  will be $\vshare{Q}{\psi}{n}$ and given to each party $q \in Q$,
whereas $P$ gets $0$ (if he is not in $Q$).
\item $\ebinop{e_1}{e_2}$ is just as in the ST mode---each party in
  the share will have the full copy of it. Same with $\kw{mux}$. Key
  question: How to prove these end up in the same place?
\item $\ereveal{P}{\psi}{Q}{e}$ requires coordination among $P \cup
  Q$, where $e$ is a $\vshare{Q}{\psi}{e'}$---i.e., the $Q$ parties
match up. Each of the parties $q \in Q$ should reach this redex
\emph{and have the same $e'$}. The type system should ensure they
agree on this, the circuit that's been created. Moreover, $e'$ should
only consist of numbers, binops, and muxes. This means you can just
\emph{run it without an environment, in an empty mode}. We let every
$q \in Q$ do that, and thus they will agree on the result $n$. Parties
$p \in P$ then receive this result, while any other parties $q \not\in
P$ receive $0$.
\end{itemize}

I'm a little unsure about the communication between parties. How
should this be encoded? Is there a generic way to do it? This will
happen at $\kw{share}$ and $\kw{reveal}$. I'm also unsure that the
``just intersect the principals at par mode at will work'' jives with
the handling of these constructs. Need to mentally work through.

To prove that this semantics matches the ST one, I think we need some
kind of ``slice'' of a program, for each of the involved hosts. At
present, I think this slice can be static---you take the program,
create a slice of it, and then run each slice. When we have dependent
types, that may not be true anymore.

\section{Type System}
\label{sec:typing}

\begin{figure}
\[\begin{array}{c}

    \inferrule*[lab=T-Nat]
    {
    }
    {
    \hastyp{\Gamma}{m}{n}{\tnat^{m}}
    } \qquad

    \inferrule*[lab=T-Var]
    {
    x\!:\!\tau \in \Gamma
    }
    {
    \hastyp{\Gamma}{m}{x}{\tau}
    }\qquad

    \inferrule*[lab=T-Read]
    {
    m\text{ is a singleton}
    }
    {
    \hastyp{\Gamma}{m}{\eread}{\tnat^{m}}
    }
    \qquad

    \inferrule*[lab=T-Write]
    {
    m\text{ is a singleton}\\\\
    \hastyp{\Gamma}{m}{e}{\tnat^{m}}
    }
    {
    \hastyp{\Gamma}{m}{\ewrite{e}}{\tnat^{m}}
    }
    \\ \\
    
    \inferrule*[lab=T-Par]
    {
    Q = m \cap P\\
    Q \vdash \tau\\\\
    \hastyp{\Gamma}{{Q}}{e}{\tau}
    }
    {
    \hastyp{\Gamma}{m}{\epar{P}{e}}{\tau}
    } \qquad

    \inferrule*[lab=T-Pair]
    {
    \hastyp{\Gamma}{m}{e_1}{\tau_1}\\\\
    \hastyp{\Gamma}{m}{e_2}{\tau_2}
    }
    {
    \hastyp{\Gamma}{m}{\epair{e_1}{e_2}}{\tau_1 \times \tau_2}
    }\qquad
    
    \inferrule*[lab=T-Access]
    {
    \hastyp{\Gamma}{m}{e}{\tau_1 \times \tau_2}\\
    }
    {
    \hastyp{\Gamma}{m}{\eproj{i}{e}}{\tau_i}
    }\\\\

    \inferrule*[lab=T-inj]
    {
    \hastyp{\Gamma}{m}{e}{\tau}
    }
    {
    \hastyp{\Gamma}{m}{\einj{1}{e}}{\tsum{\tau}{\tau_0}{m}}\\\\
    \hastyp{\Gamma}{m}{\einj{2}{e}}{\tsum{\tau_0}{\tau}{m}}
    } \qquad
    
    \inferrule*[lab=T-Match]
    {
    \hastyp{\Gamma}{m}{e}{\tau_0 +^m \tau_1}\\\\
    m \dashv \tau_0 \\
    m \dashv \tau_1 \\\\
    \hastyp{\Gamma,x\!:\!\tau_0}{m}{e_1}{\tau}\\
    \hastyp{\Gamma,x\!:\!\tau_1}{m}{e_2}{\tau}\\
    }
    {
      \hastyp{\Gamma}{m}{\econd{e}{e_1}{e_2}}{\tau}
    }\\ \\

    \inferrule*[lab=T-Fold]
    {
    \hastyp{\Gamma}{m}{e}{\tau[\trec{\alpha}{\tau}\setminus\alpha]}
    }
    {
    \hastyp{\Gamma}{m}{\efold{\trec{\alpha}{\tau}}{e}}{\trec{\alpha}{\tau}}
    } \qquad

    \inferrule*[lab=T-Unfold]
    {
    \hastyp{\Gamma}{m}{e}{\trec{\alpha}{\tau}}
    }
    {
    \hastyp{\Gamma}{m}{\eunfold{e}}{\tau[\trec{\alpha}{\tau}\setminus\alpha]}
    } \qquad

    \inferrule*[lab=T-Share]
    {
    P\text{ is a singleton}    \\
    m \vdash P\\\\
    \hastyp{\Gamma}{m}{e}{\tnat^P}\\
    m \vdash Q\\
    }
    {
    \hastyp{\Gamma}{m}{\eshare{\psi}{P}{Q}{e}}{\tnat^Q_\psi}
    }\\ \\
    
    \inferrule*[lab=T-Binop]
    {
    \tau = \tnat^m_\psi\\\\
    \hastyp{\Gamma}{m}{e_1}{\tau}\\\\
    \hastyp{\Gamma}{m}{e_2}{\tau}\\
    }
    {
    \hastyp{\Gamma}{m}{\ebinop{e_1}{e_2}}{\tau}
    }\qquad

    \inferrule*[lab=T-Mux]
    {
    \tau = \tnat^m_\psi\\\\
    \hastyp{\Gamma}{m}{e}{\tau}\\\\
    \hastyp{\Gamma}{m}{e_1}{\tau}\\
    \hastyp{\Gamma}{m}{e_2}{\tau}\\
    }
    {
    \hastyp{\Gamma}{m}{\emux{e}{e_1}{e_2}}{\tau}
    }\qquad

    \inferrule*[lab=T-Reveal]
    {
    m \vdash P\\
    m \vdash Q\\\\
    \hastyp{\Gamma}{m}{e}{\tnat^P_\psi}\\
    }
    {
    \hastyp{\Gamma}{m}{\ereveal{P}{Q}{e}{\psi}}{\tnat^Q}
    }\\ \\
   

   \inferrule*[lab=T-Abs]
    {
    m \vdash m'\\\\
    \hastyp{\Gamma, x\!:\!\tau_1}{m'}{e}{\tau_2}
    }
    {
    \hastyp{\Gamma}{m}{\elam{x}{e}}{\tfun{\tau_1}{\tau_2}{m'}}
    }\qquad
   
    \inferrule*[lab=T-App]
    {
    \hastyp{\Gamma}{m}{e}{\tfun{\tau_1}{\tau}{m}}\\\\
    \hastyp{\Gamma}{m}{e_1}{\tau_1}\\
    }
    {
    \hastyp{\Gamma}{m}{\eapp{e}{e_1}}{\tau}
    }\qquad

    \inferrule*[lab=T-Fix]
    {
    \hastyp{\Gamma,f\!:\! \tfun{\tau_1}{\tau_2}{m}}{m}{\elam{x}{e}}{\tfun{\tau_1}{\tau_2}{m}}
    }
    {
    \hastyp{\Gamma}{m}{\efix{f}{x}{e}}{\tfun{\tau_1}{\tau_2}{m}}
    }\\ \\

    \inferrule*[lab=T-Let]
    {
    \hastyp{\Gamma}{m}{e_1}{\tau_1}\\\\
    \hastyp{\Gamma, x\!:\!\tau_1}{m}{e_2}{\tau}
    }
    {
    \hastyp{\Gamma}{m}{\elet{x}{e_1}{e_2}}{\tau}
    }\qquad

    \inferrule*[lab=T-Sub]
    {
    \hastyp{\Gamma}{m}{e}{\tau_1}\\
    \issub{\tau_1}{\tau_2}
    }
    {
    \hastyp{\Gamma}{m}{e}{\tau_2}
    }

  \end{array}
\]
\caption{Typing rules}
\label{fig:typing}
\end{figure}

The typing judgment's rules are defined in Figure~\ref{fig:typing}.
The typing judgment has form $\hastyp{\Gamma}{m}{e}{\tau}$. It states
that under context $\Gamma$, expression $e$ has type $\tau$ when
evaluating in mode $m$. The rules reference judgment $m \vdash m'$,
discussed earlier, in Figure~\ref{fig:aux}. They also reference
judgment $m \vdash \tau$, which says that $\tau$ is located at 
one or more principals in $m$; and $m \dashv \tau$, which says it is
located at \emph{all} principals in $m$. 

Rule~\rulelab{T-Nat} types a (cleartext) constant; it inherits the
visibility of the current mode. Rule~\rulelab{T-Read} types the
\kw{read} command; since it will produce a different value at each
location, it must be run in the visibility of a single principal ($m$
must be a singleton set). Rule~\rulelab{T-Write} is
similar. Rules~\rulelab{T-Var} and \rulelab{T-Let} (at the bottom) are standard.

Rule~\rulelab{T-Par} runs its expression $e$ in par
mode involving principals $P$. At run-time, only $m \cap P$ principals
will actually execute $e$, and so $e$ is checked in this mode, which
we name $Q$.\footnote{Wysteria requires $P \subseteq m$, which is
  always OK in \rulelab{T-Par}, too, but it's strictly more flexible.}
Likewise, the returned value must be compatible with $Q$;
i.e., it should be ``located'' at least some principals $q \in Q$.
For example, in mode $\{p\}$ we don't want to return a value located
(only) at $q$. If we did, then subsequent access by $p$ would fail at
run-time, since the value is not actually present there.
%
Compatibility $m \vdash \tau$ is given in Figure~\ref{fig:aux}. We can
think of it as related to the semantic function $\locof{m}{v}$. This
function takes $v$ and ``locates'' it at principals in $m$, filtering
out principals not present in $P$. The judgment $m \vdash \tau$
ensures that $\locof{m}{v}$ will be a no-op.

Rule~\rulelab{T-Pair} types the introduction of pairs. A pair's
components must be typeable in the current mode, but they do not
necessarily need to have the same visibility; e.g., in mode $\{p,q\}$
a pair could have one component at $p$ and the other at
$q$. Rule~\rulelab{T-Access} types the elimination of pairs. This rule
is standard.

Rules~\rulelab{T-Inj} is standard. Rule~\rulelab{T-Match} requires
that both of the to-be-accessed types are \emph{located} at all of the
principals in the current mode, per the judgment $m \dashv \tau$. This
judgment is a sort of dual to $m \vdash \tau$; it requires that all
components of $\tau$ are present to principals in $m$. We can think of
this judgment as being related to semantic function $\getat{m}{v}$: If $v$
has type $\tau$ and $m \dashv \tau$ (with the expected extensions to
typing for new value forms), then $\getat{m}{v}$ should succeed.

Intuitively, a $\tnat$ located at $\{p,q\}$ is also located at
$p$. Rule~\rulelab{T-Sub} can be used to apply this kind of
reasoning. The subtyping judgment is given in
Figure~\ref{fig:sub}. Intuitively, $\issub{\tau_1}{\tau_2}$ holds when
$\tau_1$ is compatible with the maximal mode that $\tau_2$ is
compatible with; i.e., it's OK to treat a value as being available at
fewer locations than it actually is.

The rules \rulelab{T-Fold} and \rulelab{T-Unfold} for recursive types
are standard.

Rule~\rulelab{T-Share} types encrypting a $\tnat$ (via secret
sharing). The $P$ argument indicates the principal doing the sharing,
and it must be a singleton. The $Q$ argument indicates the principals
to which to share $e$ (which must be a normal (non-share) value). This
value of $e$ must be visible in the current mode ($m \vdash P$) and
the principals $Q$ must be present as well. Finally, the value must be
a number; neither pairs nor functions can be shares.

Rule~\rulelab{T-Binop} types arithmetic computations on both shares
and normal values---both arguments must have the same type (i.e., both
shares or both normal values, with the same visibility), and match the
current mode. Note that this rule precludes adding a 
share and a normal value; you can always do this by converting the
latter to a share (the compiler can be smart about this).

Rule~\rulelab{T-Mux} types multiplexing. The semantics is to evaluate
both branches (second and third arguments), binding $x$ to the left
and right-hand sides of the sum, respectively. The $\kw{mux}$ chooses
the result to return based on the first argument's ultimate
result. These are all (compatible) shares (under protocol $\psi$), so
we can think of this as making a multiplexor circuit. The rule
restrict the results to be $\tnat$s, but this is easily generalized
via encoding (Section~\ref{sec:generalmux}).

Rule~\rulelab{T-Reveal} types share elimination, i.e., converting a
share of a $\tnat$ to a normal value. In essence, it forces the secure
computation (which we are thinking of as a thunk) to produce a result,
and reveals that result held by principals $P$ to the specified
principals $Q$. The rule requires that the current mode includes those
in $Q$, and those $P$ who hold the shares. (We do not allow revealing
encrypted sums, directly---we require destructing them first.)

Rule~\rulelab{T-Match} types conditionals on normal sums, i.e., the
conditional will run on each principal in mode $m$. It can return
shares or normal values, as desired. 

% Unlike the elimination rules for pairs and sums, the \rulelab{T-Var}
% does not mandate ``presence'' of its contents. So the following
% program would typecheck: $\elet{x0}{\epar{b}0}{\epar{a}{x0}}$. When
% checking the second $\kw{par}$ block, the type of $x0$ is $\tnat^{b}$,
% and this variable is occurring with a $\kw{par}$ block with only $a$
% present. But this is not prevented because nothing actually done with
% the contents of that variable.

\rulelab{T-Abs} allows the body of a function to require a strictly
smaller mode than the defining context. \mwh{Why? Can't we just wrap
  in par mode? Rethink} \rulelab{T-App} requires the caller's mode to
match the mode annotation on the function; this ensures that all
principals that must be present in the function body will indeed be
running the function. \rulelab{T-Fix} is essentially a combination of
these two, allowing $f$ to be referred to recursively in $e$.

\begin{figure}
\[\begin{array}{c}

    \inferrule*[lab=M-sub]
    {
    P \subseteq Q
    }
    {
    Q \vdash P
    } \qquad
    
    \inferrule*[lab=M-Nat]
    {
    m = n \vee
    (\psi = \cdot \Rightarrow m \vdash n)
    }
    {
    m \vdash \tnat^n_\psi
    } \qquad

    \inferrule*[lab=M-Sum]
    {
    m \vdash n\\
    m \vdash \tau_1 \\ m \vdash \tau_2
    }
    {
    m \vdash \tsum{\tau_1}{\tau_2}{n}
    } \\ \\

    \inferrule*[lab=M-Fun]
    {
    }
    {
    m \vdash \tfun{\tau_1}{\tau_2}{m}
    }\qquad

    \inferrule*[lab=M-Prod]
    {
    m \vdash \tau_1 \\ m \vdash \tau_2
    }
    {m \vdash \tprod{\tau_1}{\tau_2}}
    \qquad

    \inferrule*[lab=M-Rec]
    {m \vdash \tau}
    {m \vdash \trec{\alpha}{\tau}}
    \qquad
    
    \inferrule*[lab=m-Alpha]
    { }
    {m \vdash \alpha}
    \\ \\

    \inferrule*[lab=L-Nat]
    {  }
    {
    m \dashv \tnat^m_\psi
    } \qquad

    \inferrule*[lab=L-Sum]
    {
    m \dashv \tau_1 \\\\ m \dashv \tau_2
    }
    {
    m \dashv \tsum{\tau_1}{\tau_2}{m}
    } \qquad

    \inferrule*[lab=L-Fun]
    {
    }
    {
    m \dashv \tfun{\tau_1}{\tau_2}{m}
    }\qquad

    \inferrule*[lab=L-Prod]
    {
    m \dashv \tau_1 \\\\ m \dashv \tau_2
    }
    {m \dashv \tprod{\tau_1}{\tau_2}}
    \qquad

    \inferrule*[lab=L-Rec]
    {m \dashv \tau}
    {m \dashv \trec{\alpha}{\tau}}
    \qquad
    
    \inferrule*[lab=L-Alpha]
    { }
    {m \dashv \alpha}
    \\ \\
    
  \end{array}\]
\caption{Locatedness and Presence}
\label{fig:aux}
\end{figure}
    
\begin{figure}
\[\begin{array}{c}

    \inferrule*[lab=S-Nat]
    {
    m \vdash \tnat^n_\psi
    }
    {
    \issub{\tnat^m_\psi}{\tnat^n_\psi}
    } \qquad

    \inferrule*[lab=S-Sum]
    {
    m \vdash \tsum{\tau_1'}{\tau_2'}{n}\\\\
    \issub{\tau_1}{\tau_1'} \land \issub{\tau_2}{\tau_2'}
    }
    {
    \issub{\tsum{\tau_1}{\tau_2}{m}}{\tsum{\tau_1'}{\tau_2'}{n}}
    } \qquad
    
    \inferrule*[lab=S-Fun]
    {
    \issub{\tau_1'}{\tau_1}\\
    \issub{\tau_2}{\tau_2'}
    }
    {
    \issub{\tfun{\tau_1}{\tau_2}{m}}{\tfun{\tau_1'}{\tau_2'}{m}}
    }\qquad

    
    \inferrule*[lab=S-Pair]
    {
    \issub{\tau_1}{\tau_1'}\\
    \issub{\tau_2}{\tau_2'}
    }
    {
    \issub{\tau_1 \times \tau_2}{\tau_1' \times \tau_2'}
    }
    
\end{array}
\]
\caption{Subtyping}
\label{fig:sub}
\end{figure}

\section{TO DO}

Soon:
\begin{itemize}
\item Develop multi-party operational semantics.
\item Prove relationship between single- and multi-threaded semantics
\item Prove type soundness for single-threaded semantics
\end{itemize}
\mwh{TODO}
\begin{itemize}
\item Reconsider function types --- see DavidH's note below.
\item No subtyping at present for recursive types. Should we add it?
\item Function types preclude top-level functions? See note below.
\end{itemize}

\begin{verbatim}
By the way, I don't know if this will overcomplicate everything, but
I've been thinking about how to get back the notion of applying a
function with fewer parties than were there when the closure was
made. (Which if I understand correctly is not possible in the current
version since function sub-typing is invariant in the knownness of the
function arrow). 

It seems that you can view the annotation ^m (on both values and
contexts) as a sort of upper bound on the parties who know some
information (which you can subtype to include fewer parties). 
Analogously you could imagine adding an annotation _n to represent a
lower bound on the parties who know information (conceptually, the
parties whose presence is mandatory to use a value). 
Then you could give function arrows this subtype rule:

t1' <: t1
t2 <: t2'
m >= m'
n' >= n
-------------------
t1 ->^m_n t2    <:    t1' ->^m'_n' t2'

The application rule would require the upper and lower bound to match: 

gamma |-^m_n e : t1 ->^m_m t2
gamma |-^m_n e1 : t1
------------------
gamma |-^m_n (e e1) : t2

par blocks would constrain the lower bound: By including a par block
as a subexpression you indicating that the containing expression must
involve the par block parties: 

m >= m'
gamma |-^m'_n e : t
--------------
gamma |-^m_(n \cup m') par m' e : t
\end{verbatim}


% Next: Look at \texttt{writeup/spdz.md} and think about language
% changes to support verification.

  
\end{document}
