\documentclass[10pt]{article}

\usepackage{times}
\usepackage{fullpage}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathpartir}
\usepackage{color}

%%%%% DEFS %%%%%%

\newcommand{\rulelab}[1]{{\small \textsc{#1}}}
\newcommand{\kw}[1]{\ensuremath{\mathtt{#1}}}

% Types
\newcommand{\tnat}{\ensuremath{\mathtt{nat}}}
\newcommand{\tlist}[1]{\ensuremath{\mathtt{list}~{#1}}}
\newcommand{\tfun}[2]{\ensuremath{{#1} \rightarrow {#2}}}
\newcommand{\tprod}[2]{\ensuremath{{#1} \times {#2}}}
\newcommand{\tsum}[2]{\ensuremath{{#1} + {#2}}}
\newcommand{\ssec}{\ensuremath{\mathtt{sec}}}
\newcommand{\isec}{\ensuremath{\mathtt{pmap}}}
\newcommand{\sshare}[1]{\ensuremath{\mathtt{shr}~{#1}}}
\newcommand{\sectyp}[3]{\ensuremath{{#1} \{~{#2}:{#3}~\}}}
  
% Terms
\newcommand{\ebinop}[2]{\ensuremath{{#1}~\oplus~{#2}}}
\newcommand{\elet}[3]{\ensuremath{\kw{let}~#1\, =\, #2~\kw{in}\;{#3}}}
\newcommand{\epar}[2]{\ensuremath{\kw{par}~{#1}~{#2}}}
\newcommand{\esec}[2]{\ensuremath{\kw{sec}~{#1}~{#2}}}
\newcommand{\ereveal}[2]{\ensuremath{\kw{reveal}~{#1}~{#2}}}
\newcommand{\econd}[3]{\ensuremath{\kw{if}~{#1}~\kw{then}~{#2}~\kw{else}~{#3}}}
\newcommand{\eshare}[3]{\ensuremath{\kw{share}_{#1}~{#2}~{#3}}}
\newcommand{\esharemap}[3]{\ensuremath{\kw{sharemap}_{#1}~{#2}~{#3}}}
\newcommand{\econcat}[2]{\ensuremath{{#1} +\!\!+~ {#2}}} 
\newcommand{\eaccval}[2]{\ensuremath{{#1}.{#2}}}

% Judgments
\newcommand{\hastyp}[4]{\ensuremath{{#1} \vdash_{#2} {#3} : {#4}}}
\newcommand{\canshare}[1]{\ensuremath{\vdash_{\mathit{share}} {#1}}}
\newcommand{\subtype}{\ensuremath{<:}}
\newcommand{\issub}[2]{{#1} \subtype {#2}}

% Aux
\newcommand{\mpar}[1]{\ensuremath{\mathsf{p}(#1)}}
\newcommand{\msec}[1]{\ensuremath{\mathsf{s}(#1)}}

%%%%%%%%%%

\newcommand{\mwh}[1]{\textcolor{red}{Mike: #1}}

\title{PANTHEON Source Language}
\author{PANTHEON Team}

\begin{document}

\maketitle

\begin{figure}[h]
  \centering
  \[\begin{array}{rlcll}
      \text{Raw types} & \omega  & ::=  & \tnat & \text{a base type} \\      
                       && \mid & \tprod{\tau}{\tau} & \text{pairs} \\
                       && \mid & \tsum{\tau}{\tau} & \text{sums} \\
                       && \mid & \tlist{\tau} & \text{lists} \\
                       && \mid & \tfun{\tau}{\tau} & \text{functions} \\
      \text{Types} & \tau & ::= & \omega & \text{cleartext values} \\
                       && \mid & \sectyp\omega\phi{P} & \text{secret values} \\
      \text{Principal} & p, q \\
      \text{Principal set} & P, Q \\
      \text{Format} & \phi & ::= & \ssec & \text{private value}  \\
                       && \mid & \isec & \text{per-principal value}  \\
                       && \mid & \sshare{\psi} & \text{secret share of type $\psi$} \\
      \text{Protocol} & \psi & ::= & ... & \text{MPC type} \\
      \text{Expressions} & e & ::= & n & \text{naturals} \\
                       && \mid & x & \text{variables} \\
                       && \mid & \econcat{e_1}{e_2} & \text{concatenate $\isec$s}\\
                       && \mid & \eaccval{e}{p} & \text{$p$'s value}\\
                       && \mid & \eshare{\psi}{P}{e} & \text{$\psi$ shares to $P$} \\
                       && \mid & \esharemap{\psi}{P}{e} & \text{$\psi$ shares of $\isec$ to $P$} \\
                       && \mid & \ebinop{e_1}{e_2}  & \text{binary operation} \\
                       && \mid & \elet{x}{e_1}{e_2}  & \text{sequencing} \\
                       && \mid & \econd{e_1}{e_2}{e_3}  & \text{conditional} \\
                       && \mid & \epar{P}{e} & \text{parallel evaluation}\\
%                       && \mid & \eall{P}{e} & \text{parallel evaluation}\\
                       && \mid & \esec{P}{e} & \text{secure (cryptographic) evaluation}\\
                       && \mid & \ereveal{P}{e} & \text{distribute result to $P$}\\
  \end{array}
  \]
  \caption{Syntax}
  \label{fig:syntax}
\end{figure}

\section{Encoding in Wysteria}

I'm starting to wonder if our idea from way back --- Wysteria with
small extensions --- is all we really needed, where the current approach
to PSL is just this system with some inference added in. Those
extensions are:
\begin{itemize}
\item that you can create shares for a subset of parties in a secure
  block. Thus, for Alice to create shares for Bob and Charlie, all
  three join the secure block, and then create shares from Alice's
  value. We also need to be able to reconstitute shares for a subset
  of parties; i.e., if there are shares between A and B, we can make a
  secure block with A, B, and C, and reconstitute the shares within
  it. 
\item some kind of seal/unseal primitives for making $\ssec$ values, as
in Wys$^\star$, so as to avoid the weird $\Gamma$ in the Wysteria
paper. I think this also has the benefit that you can use subtyping to
make a sealed value less visible. But maybe this should be a wire
bundle instead, so the runtime semantics is clear?
\mwh{Have a look at the markdown I wrote a while back}
\end{itemize}

Then PSL is basically inference and encoding down to this.

\paragraph{Share primitive} In PSL you can write \texttt{share $P$
  $e$}, which means to secret-share $e$ among principals $P$. It might
be that $e$ is owned by some principal $p$ not in $P$. In our encoding
we do this via \texttt{sec $\{p\}\cup{P}$ (makesh $P$ $e$)}.

\paragraph{Secure computation} In PSL everything you compute on
securely is conceptually a share, and only by explicitly revealing a
share do you get a value. The default in Wysteria is the
opposite. Thus the encoding of $e_1 \oplus e_2$ in PSL, where $e_1$
and $e_2$ are both share types over the same principal $P$, would be
\texttt{sec $P$ (makesh $P$ ((combsh $e_1$) $\oplus$ (combsh
  $e_2$)))}. The encoding for PSL's \texttt{reveal $P$ $e$} would be
\texttt{sec $R$ (let x = combsh $e$ in wire $P$ x)} where $e$ is
a share over principals $Q$ and $Q \cup P = R$. 

\paragraph{SIMD computations resulting in principal mapped values} In
the euclid example, we have something like
\begin{verbatim}
  let ab = {par:A,B} read int "euclid.txt"
\end{verbatim}
The idea is that \verb+ab+ is a $\isec$ value for $A$ and $B$. In
normal Wysteria you can only call \texttt{read} in a par block with a
single principal, but we can encode something like the above using
\texttt{wapp}. Basically \texttt{par $P$ e} in PSL is \texttt{wapp $P$
  ($\lambda$ x. par x $e$)} where \texttt{x} will be bound to the principal
executing $e$. It's not mentioned in the Wysteria paper, but I suspect
that the lambda term should executing $e$ in par mode anyway, so I'm
not sure why we have to specify it.

\section{Syntax}

The syntax of core PSL is in Figure~\ref{fig:syntax}. \mwh{Need terms for
lists, sums, pairs -- construct, destruct}

\mwh{If we are supporting generic principal sets, we need to generalize our
sec, par, etc. blocks so that $P$ can continue run-time values. This
adds various complications.}

\mwh{TODO: Address in the language:} It occurs to me that the
per-principal comprehension construct, that we were equating with par
blocks, might not be the same thing. Instead, it's probably like a map
over a wire bundle, where the bundle is just the identity map over a
set of principals. Then, the function being mapped has access to that
principal in that function.

\subsection{Types}

Raw types $\omega$ are normal types (numbers, pairs, lists,
functions). Types $\tau$ are either raw types $\omega$, which mean
that they are visible to all parties (who agree on their values) in
the clear, or they are security types $\sectyp{\omega}{\phi}{P}$. The
structure of the latter is a the raw type $\omega$, the \emph{format}
$\phi$, and visibility $P$, which is a list of principals who can
access/see the value.  The raw type indicates the basic type of the
value (function, number, list, etc.), while the format is the
interesting part. It has three variants:
\begin{itemize}
\item \emph{secret shares} $\sshare\psi$, which indicate a single
  value that is secret-shared among the given set of parties $P$,
  amenable to MPC using protocol $\psi$ (e.g., BGW, GMW, Yao).
\item \emph{secrets} \ssec, which indicate a single value known to
  (accessible by) those parties in the set $P$, but no others.
\item \emph{maps} \isec, which indicate a single variable for which
  each principal in $P$ may have a distinct value, known only to that
  principal. 
\end{itemize}

\subsection{Terms}

Note that we expect that sec blocks, and sometimes par blocks, can be
inferred by an earlier pass. We leave in the core language for clarity.

\mwh{Ramble follows; I think the upshot is that this doesn't work}
We make shares explicitly among some set of principals operating in
lockstep. So, shares of $e$ to $P$ require being in a par block
involving $Q \supseteq P$. But in Wysteria, you can only access a wire
bundle value in par mode if it's a singleton. This is to prevent Alice
and Bob access their values, which would be OK if subset was OK, and
then summing them up. I think this has to be in a sec block.

Should secure mode always return a share type? Thus, Wysteria is
reveal P (sec P e) ? But this seems not to work with the above. It
requires I explicitly share with a subset of principals, rather than
implicitly share with all of them on return.

\section{Semantics}

The semantics is inspired by that of Wysteria, but is a bit more
expressive. 

\paragraph*{Par blocks}

The entire computation begins in a par block, conceptually involving
all principals. Each principal is running the same program, but it
will skip those blocks of code that don't apply to it.  A key goal of
the system is that all parties are ``present'' to perform joint-secure
operations when they need to be.

\mwh{Need to figure out rules for what secure-block operations can happen
in a par block.}

\paragraph*{Secure blocks}

Cryptographic computations are those over values of
$\sectyp{\omega}{\sshare{\psi}}{P}$ type. Whenever something of this
type ends up in destruct position (e.g., $\ebinop{e_1}{e_2}$) instead
of actually doing the computation, we can think of the operation as
being made into a thunk.\footnote{Behind the scenes the operation might
actually take place, e.g., when adding shares or communicating to
multiply them. Or the frozen operation might result in a circuit being
constructed.} For example, if we do $\ebinop{e_1}{e_2}$ and $e_1$ and
$e_2$ are both shares (i.e., of type $\sshare{\psi}$), then the result
is that both parties will construct a circuit over those shares,
locally. The $\ereveal{P}{e}$ construct takes as its argument a share and
forces the computation to happen. That is, at that moment the secure
computation will be forced to completion, and the result revealed to
the involved principals $P$.

\section{Typing}

\begin{figure}
\[\begin{array}{c}
    \inferrule*[lab=E-Binop]
    {
    \tau = \sectyp{\tnat}{\phi}{P}\\
    M \vdash \tau\\
    \hastyp{\Gamma}{M}{e_1}{\tau}\\
    \hastyp{\Gamma}{M}{e_2}{\tau}\\
    }
    {
    \hastyp{\Gamma}{M}{\ebinop{e_1}{e_2}}{\tau}
    }\\ \\

    \inferrule*[lab=E-Sec]
    {
    M \vdash \msec{P} \\
    \hastyp{\Gamma}{\msec{P}}{e}{\tau}
    }
    {
    \hastyp{\Gamma}{M}{\esec{P}{e}}{\tau}
    } \qquad

    \inferrule*[lab=E-Par]
    {
    M \vdash \mpar{P} \\
    \hastyp{\Gamma}{\mpar{P}}{e}{\tau}
    }
    {
    \hastyp{\Gamma}{M}{\epar{P}{e}}{\tau}
    }
    \\ \\
      
  \end{array}
\]
\caption{Typing rules}
\label{fig:typing}
\end{figure}

The typing judgment's rules are defined in
Figure~\ref{fig:typing}. These use the following syntax.

\[\begin{array}{rlcll}
    \text{Modes} & M  & ::=  & \top & \text{par mode with all principals}\\
                 && \mid & \mpar{P} & \text{par mode with principals $P$} \\      
                 && \mid & \msec{P} & \text{secure mode with principals $P$} \\
  \end{array}
\]

\mwh{We may want effects; Wysteria had them.}

The typing judgment has form $\hastyp{\Gamma}{M}{e}{\tau}$. It states
that under context $\Gamma$, expression $e$ has type $\tau$ when
evaluating in mode $M$. Modes $M$ are
either $\msec{P}$, which is sec mode with a set of principals $P$; par
mode $\mpar{P}$, with a set of principals $P$; and par mode $\top$,
which is a shorthand for par mode with all participating
principals.

We have several auxiliary judgments, shown in
Figure~\ref{fig:aux}. The most important of these is the \emph{mode
  compatibility} judgment, which 

\paragraph*{Secure blocks}

The $\ereveal{Q}{e}$ construct takes as its argument something of type
$\sectyp{\omega}{\sshare{\psi}}{P}$ and produces a value of type
$\sectyp{\omega}{\ssec}{Q}$. That is, it forces the secure computation
(which we are thinking of as a thunk) to produce a result, and reveals
that result to the specified principals $Q$.

\paragraph*{Par blocks}

The type of $\epar{P}{e} $ is $\sectyp{\omega}{\isec}{P}$
type. This is because $e$ is executed independently by each principal
$p \in P$. There are constraints on the type of $e$. Off the top of my
head:
\begin{itemize}
\item All types with visibility $P$ are allowed. We can use subtyping
  (to $Q \subset P$) as needed.
  \item We can insert nested Par blocks, with a subset of principals,
    I think. However, their results will only be visible to subsequent
    par blocks with the same principal set (not the parent).
  \item Conditional execution $\econd{e_1}{e_2}{e_3}$ when $e_1$ could
    contain an $\isec$ needs to be limited. The issue will be if $e_2$
    has a secure computation inside it; not all parties $P$ will
    necessarily reach this point, because their values may differ in
    $e_1$. Remedies:
    \begin{itemize}
      \item Only allow conditionals in Par blocks when $P$ is a singleton, or
      \item Forbid computations on shares inside the branches of a
        conditional when the guard involves an \isec.
      \end{itemize}
\end{itemize}

The auxiliary judgment $\canshare{\tau}$, which says that a type
$\tau$ can be made into a secret share. Only nats and products of nats
can be secret-shared; lists, sum types, and functions cannot be, as
doing so would reveal information about them (e.g., their size).


\begin{figure}
\[\begin{array}{c}

    \canshare{\tnat}
    \qquad

    \inferrule
    {
    \canshare{\tau_1}\\ \canshare{\tau_2}
    }
    {
    \canshare{\tprod{\tau_1}{\tau_2}}
    }
    \qquad
    
    \inferrule*[lab=S-PrinSub]
    {
    Q \subseteq P\\
    \phi = \ssec \vee \phi = \isec
    }
    {
    \issub{\sectyp{\omega}{\phi}{P}}{\sectyp{\omega}{\phi}{Q}}
    }
    \\ \\


    
\end{array}
\]
\caption{Auxiliary Judgments}
\label{fig:aux}
\end{figure}




\paragraph{Subtyping}

We have subtyping $\issub{\tau_1}{\tau_2}$, which indicates when
$\tau_1$ can be used as $\tau_2$. The rules are in
Figure~\ref{fig:subtyping}. Typing only permits operations among
values of exactly the same type $\tau$. Rule PrinSub says an \ssec $P$
can be coerced to \ssec $Q$ when $Q \subseteq P$. That is, a shared
value visible to a larger principal set can be viewed as visible to a
smaller one. The same is true of \isec. There is no subtyping
arrangement for \sshare---all parties have to be present, and
additional parties are not allowed. This is because those parties
represent distributed secret shares of a precise number.

\end{document}