\documentclass[10pt]{article}

\usepackage{times}
\usepackage{fullpage}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathpartir}
\usepackage{color}

%%%%% DEFS %%%%%%

\newcommand{\rulelab}[1]{{\small \textsc{#1}}}
\newcommand{\kw}[1]{\ensuremath{\mathtt{#1}}}

% Types
\newcommand{\tnat}{\ensuremath{\mathtt{nat}}}
\newcommand{\tfun}[3]{\ensuremath{{#1} ~^{#3}\!\rightarrow {#2}}}
\newcommand{\tprod}[2]{\ensuremath{{#1} \times {#2}}}
%\newcommand{\tsum}[4]{\ensuremath{{#1} +^{#3}_{#4} {#2}}}
\newcommand{\tsum}[3]{\ensuremath{{#1} +^{#3} {#2}}}
\newcommand{\trec}[2]{\ensuremath{\mu {#1}.{#2}}}
% \newcommand{\ssec}{\ensuremath{\mathtt{\cdot}}}
% \newcommand{\isec}{\ensuremath{\mathtt{pmap}}}
% \newcommand{\sshare}[1]{\ensuremath{\mathtt{shr}~{#1}}}
% \newcommand{\sectyp}[3]{\ensuremath{{#1} \{~{#2}:{#3}~\}}}
  
% Terms
\newcommand{\ebinop}[2]{\ensuremath{{#1}~\oplus~{#2}}}
\newcommand{\elet}[3]{\ensuremath{\kw{let}~#1\, =\, #2~\kw{in}\;{#3}}}
\newcommand{\epar}[2]{\ensuremath{\kw{par}~{#1}~{#2}}}
\newcommand{\esec}[2]{\ensuremath{\kw{sec}~{#1}~{#2}}}
\newcommand{\ereveal}[4]{\ensuremath{\kw{reveal}^{#1}_{#4}~{#2}~{#3}}}
\newcommand{\econd}[3]{\ensuremath{\kw{match}~{#1}~\kw{with}~x.{#2} \diamond {#3}}}
%\newcommand{\emux}[3]{\ensuremath{\kw{mux}~{#1}~\kw{?}~x.{#2}~\kw{:}~x.{#3}}}
\newcommand{\emux}[3]{\ensuremath{\kw{mux}~{#1}~\kw{?}~{#2}~\kw{:}~{#3}}}
\newcommand{\eshare}[4]{\ensuremath{\kw{share}^{#2}_{#1}~{#3}~{#4}}}
%\newcommand{\esharesum}[4]{\ensuremath{\kw{sharesum}^{#2}_{#1}~{#3}~{#4}}}
\newcommand{\einj}[2]{\ensuremath{\kw{inj}_{#1}~{#2}}}
\newcommand{\eread}{\ensuremath{\kw{read}}}
\newcommand{\epair}[2]{\ensuremath{\langle {#1}, {#2} \rangle}}
\newcommand{\eproj}[2]{\ensuremath{\kw{\#}}_{#1}~{#2}}
\newcommand{\elam}[2]{\ensuremath{\lambda {#1}.{#2}}}
\newcommand{\eapp}[2]{\ensuremath{{#1}~{#2}}}
\newcommand{\efix}[3]{\ensuremath{\kw{fix}~{#1}.\elam{#2}{#3}}}
\newcommand{\efold}[2]{\ensuremath{\kw{fold}_{#1}~{#2}}}
\newcommand{\eunfold}[1]{\ensuremath{\kw{unfold}~{#1}}}
\newcommand{\vshare}[3]{\ensuremath{\{{#3}\}^{#1}_{#2}}}
\newcommand{\vloc}[2]{\ensuremath{{#1}\kw{@}{#2}}}
\newcommand{\vclos}[2]{\ensuremath{\mathbf{clos}~({#1},{#2})}}

% Judgments
\newcommand{\hastyp}[4]{\ensuremath{{#1} \vdash_{#2} {#3} : {#4}}}
%\newcommand{\canshare}[1]{\ensuremath{\text{isFlat } {#1}}}
\newcommand{\subtype}{\ensuremath{<:}}
\newcommand{\issub}[2]{{#1} \subtype {#2}}
\newcommand{\eval}[4]{\ensuremath{\config{#1}{#3} \longrightarrow_{#2} {#4}}}

% Aux
\newcommand{\env}{\ensuremath{\sigma}}
\newcommand{\config}[2]{\ensuremath{\langle{#1},{#2}\rangle}}
\newcommand{\locof}[2]{\ensuremath{\mathit{loc}_{#1}~{#2}}}
\newcommand{\getat}[2]{\ensuremath{\mathit{on}_{#1}~{#2}}}
% \newcommand{\ctxt}{\ensuremath{\mathcal{E}}}
% \newcommand{\pctxt}{\ensuremath{\mathcal{P}}}
  
%%%%%%%%%%

\newcommand{\mwh}[1]{\textcolor{red}{Mike: #1}}

\title{PANTHEON Source Language}
\author{PANTHEON Team}

\begin{document}

\maketitle

\section{TO DO}

Soon:
\begin{itemize}
\item Think about fixpoint types. Don't have an operational rule
  (normally, I'd use substitution, but we are using environments in
  closures). Fixpoints now have the mode $m$ in the context and on the
  arrow as the same. In normal abstractions this doesn't need to
  be. Not sure if I'm being too restrictive.
\item Is there any benefit to the $m \vdash m'$ in T-Abs? Not
  convinced. Reconsider function types --- see DavidH's note below.
\item Sum construction doesn't require its components to be
  present, but deconstruction does. Is the latter required? It
  should be if it's the same as pair access; is it?
\item No subtyping at present for recursive types. Should we add
  it?
\item Prove type soundness for single-threaded semantics
\item Develop multi-party operational semantics.
\end{itemize}

% Next: Look at \texttt{writeup/spdz.md} and think about language
% changes to support verification.

Later:
\begin{itemize}
\item Contemplate Muxable t psi, which denotes that there must be some
  way to combine two different values of type t according to a mux
  under protocol psi. From David D: \emph{Regarding muxable: I still see $A +^P_{\psi} B$ as a sum type where psi only describes the encryption of the "sum bit", and $A$ and $B$ should either be shared base types, tuples, or shared sums (arbitrarily nested). This is the muxable constraint, and I think what David H had in mind.}
\item Contemplate generalized ``reveal'' operation, which works on all
  datatypes by recursing into their contents and revealing
  those. E.g., you could reveal a list of shares all at once.
\item drop $\top$ ?
\item First-class principal sets, as data,
  \begin{itemize}
    \item Add to syntactic forms (e.g., $\ereveal{P}{Q}{e}{\psi}$ should be
    $\ereveal{e_q}{e_q}{e}{\psi}$ where $e_P$ and $e_q$ are principal
    sets).
  \item Generalize wire bundles.
  \end{itemize}
\item Function types preclude top-level functions? See note below.
\end{itemize}

\begin{verbatim}
By the way, I don't know if this will overcomplicate everything, but
I've been thinking about how to get back the notion of applying a
function with fewer parties than were there when the closure was
made. (Which if I understand correctly is not possible in the current
version since function sub-typing is invariant in the knownness of the
function arrow). 

It seems that you can view the annotation ^m (on both values and
contexts) as a sort of upper bound on the parties who know some
information (which you can subtype to include fewer parties). 
Analogously you could imagine adding an annotation _n to represent a
lower bound on the parties who know information (conceptually, the
parties whose presence is mandatory to use a value). 
Then you could give function arrows this subtype rule:

t1' <: t1
t2 <: t2'
m >= m'
n' >= n
-------------------
t1 ->^m_n t2    <:    t1' ->^m'_n' t2'

The application rule would require the upper and lower bound to match: 

gamma |-^m_n e : t1 ->^m_m t2
gamma |-^m_n e1 : t1
------------------
gamma |-^m_n (e e1) : t2

par blocks would constrain the lower bound: By including a par block
as a subexpression you indicating that the containing expression must
involve the par block parties: 

m >= m'
gamma |-^m'_n e : t
--------------
gamma |-^m_(n \cup m') par m' e : t
\end{verbatim}


\begin{figure}[h]
  \centering
  \[\begin{array}{rlcll}
      \text{Principal} & p, q \\
      \text{Principal set} & P, Q \\
    \text{Execution modes} & m  & ::=  & \top & \text{par mode with all principals}\\
                       && \mid & P & \text{par mode with principals $P$} \\
      \text{Protocol} & \psi & ::= & \cdot & \text{cleartext} \\
                       && \mid & \phi & \text{encryption format} \\
      \text{Types} & \tau & ::=  & \tnat^m_\psi & \text{a base type} \\
                       && \mid & \tprod{\tau}{\tau} & \text{pairs} \\
%                       && \mid & \tsum{\tau}{\tau}{m}{\psi} & \text{sums} \\
                       && \mid & \tsum{\tau}{\tau}{m} & \text{sums} \\
                       && \mid & \trec{\alpha}{\tau} & \text{(iso)recursive types} \\
                       && \mid & \tfun{\tau}{\tau}{m} & \text{functions} \\
      \text{Protocol} & \psi & ::= & ... & \text{MPC type} \\
      \text{Expressions} & e & ::= & n & \text{naturals} \\
                       && \mid & x & \text{variables} \\
                       && \mid & \eread & \text{read from terminal}\\
                       && \mid & \epair{e_1}{e_2} & \text{pair construction}\\
                       && \mid & \eproj{i}{e} & \text{pair elem, }i \in \{1,2\}\\
                       && \mid & \eshare{\psi}{P}{Q}{e} & \text{$\psi$ shares of {\tnat} at $P$ to $Q$} \\
                       % && \mid & \esharesum{\psi}{P}{Q}{e} & \text{$\psi$ shares of sum $P$ to $Q$} \\
                       && \mid & \ereveal{P}{Q}{e}{\psi} & \text{distribute result in $\psi$ at $Q$ to $P$}\\
                       && \mid & \ebinop{e_1}{e_2}  & \text{binary operation} \\
                       && \mid & \emux{e}{e_1}{e_2}  & \text{MPC conditional} \\
                       && \mid & \einj{i}{e} & \text{sum elem, }i \in \{1,2\}\\
                       && \mid & \econd{e}{e_1}{e_2}  & \text{sum elimination} \\
                       && \mid & \efold{\trec{\alpha}{\tau}}{e} & \text{rectype intro}\\
                       && \mid & \eunfold{e} & \text{rectype elim}\\
                       && \mid & \epar{P}{e} & \text{parallel evaluation}\\
                       && \mid & \elam{x}{e}  & \text{abstraction} \\
                       && \mid & \eapp{e_1}{e_2}  & \text{application} \\
                       && \mid & \elet{x}{e_1}{e_2}  & \text{sequencing} \\
  \end{array}
  \]
  \caption{Syntax}
  \label{fig:syntax}
\end{figure}

\newpage

\section{Syntax}
  
The syntax of core PSL is in Figure~\ref{fig:syntax}. Some derived
constructs (syntactic sugar) are given in Section~\ref{sec:derived}

There are two key concepts in types. First is their \emph{location},
designated $m$. Natural numbers, sums, and functions are located at
particular places; only here can they be computed on. Second (and in
addition), natural numbers can be \emph{encrypted} as secret
shares (with a different share at each party among the locations
$m$). We annotate the sharing protocol (GMW, Yao, etc.) as $\psi$; the
``cleartext'' protocol is $\cdot$ (or simply elided, to reduce
clutter). Pairs and lists are not located in the same sense as the
other values. That is, all parties present in a computation when the
pair or list is created can see its structure. They may not, however,
be able to access its values, as these could be located at particular
locations.

\section{Semantics}

\begin{figure}
  \[\begin{array}{rlcll}
      \text{Store} & \sigma & \in & \mathbf{Var} \rightharpoonup \mathbf{Val}\\
      \text{Locatable value} & u & ::=  & n & \text{numbers} \\
                             && \mid & \einj{i}{v} & \text{sum elem, }i \in \{1,2\}\\
                             && \mid & \vclos{\env}{\elam{x}{e}}  & \text{closure} \\
                             && \mid & \vshare{Q}{\psi}{e} & \text{$\psi$-$Q$ share of evaluating $e$} \\
      \text{Value} & v  \in \mathbf{Val} & ::=  & u & \text{locatable value}\\
                       && \mid & \epair{v_1}{v_2} & \text{pair value}\\
                       && \mid & \efold{\trec{\alpha}{\tau}}{v} & \text{rectype value}\\
                       && \mid & \vloc{u}{P} & \text{located value}\\
      % \text{Eval Context} & \ctxt & ::= & \multicolumn{2}{l}{\bullet \mid\epair{\ctxt}{e} \mid
      %                        \epair{v}{\ctxt} \mid \eproj{i}{\ctxt}}  \\
      %          && \mid & \multicolumn{2}{l}{\eshare{\psi}{P}{Q}{\ctxt} \mid
      %                        \ereveal{P}{Q}{\ctxt}{\psi} \mid \ebinop{\ctxt}{e_2} \mid \ebinop{v}{\ctxt} }  \\
      %          && \mid & \multicolumn{2}{l}{\emux{\ctxt}{e_1}{e_2}
      %                    \mid \emux{v}{\ctxt}{e_2} \mid \emux{v}{v_1}{\ctxt}  }  \\
      %          && \mid & \multicolumn{2}{l}{\einj{i}{\ctxt} \mid \econd{\ctxt}{e_1}{e_2} }  \\
      %          && \mid & \multicolumn{2}{l}{\efold{\trec{\alpha}{\tau}}{\ctxt} \mid \eunfold{\ctxt}}  \\
      %          && \mid & \multicolumn{2}{l}{\eapp{\ctxt}{e} \mid
      %                    \eapp{v}{\ctxt} \mid \elet{x}{\ctxt}{e_2} }\\
    \end{array}
  \]

\[\begin{array}{l@{~~=~~}l}
    \locof{P}{n} & \vloc{n}{P} \\
    \locof{P}{\einj{i}{v}} & \vloc{(\locof{P}{v})}{P} \\
    \locof{P}{\vclos{\env}{\elam{x}{e}}} & \vloc{(\vclos{(\locof{P}{\env})}{\elam{x}{e}})}{P}\\
    \locof{P}{\vshare{Q}{\psi}{e}} & \vloc{(\vshare{Q}{\psi}{e})}{P} \\
    \locof{P}{\epair{v_1}{v_2}} & \epair{\locof{P}{v_1}}{\locof{P}{v_2}}\\
    \locof{P}{ \efold{\trec{\alpha}{\tau}}{v}} &  \efold{\trec{\alpha}{\tau}}{\locof{P}{v}}\\
    \locof{P}{\vloc{u}{Q}} & \vloc{(\locof{P}{u})}{R} \qquad\text{where }R = P \cap Q\\
    \locof{P}{\sigma} & \{ x \mapsto v' \mid \sigma(x) = v \land \locof{P}{v} = v' \}\\
    \multicolumn{2}{c}{}\\
    \getat{P}{(\vloc{u}{Q})} & u \qquad \text{where }Q \vdash P\\
    \getat{P}{v} & v \qquad \text{for all other $v$ syntactic forms}\\
  \end{array}
\]
\caption{Semantics auxiliaries}
\label{fig:auxsem}
\end{figure}

\begin{figure}
$$
\begin{array}{c}
    \inferrule*[lab=E-Nat]
    {
    }
    {
    \eval{\env}{m}{n}{n}
    }
    \qquad

    \inferrule*[lab=E-Read]
    {
  m\text{ is a singleton}
    }
    {
    \eval{\env}{m}{\eread}{n}
    }
    \qquad

    \inferrule*[lab=E-Pair]
    {
    \eval{\env}{m}{e_1}{v_1}\\\\
    \eval{\env}{m}{e_2}{v_2}
    }
    {
    \eval{\env}{m}{\epair{e_1}{e_2}}{\epair{v_1}{v_2}}
    }\qquad
    
    \inferrule*[lab=E-Access]
    {
    \eval{\env}{m}{e}{v}\\\\
    \getat{m}{v} = \epair{v_1}{v_2}
    }
    {
    \eval{\env}{m}{\eproj{i}{e}}{v_i}
    }\\\\

    \inferrule*[lab=E-inj]
    {
    \eval{\env}{m}{e}{v}
    }
    {
    \eval{\env}{m}{\einj{i}{e}}{\einj{i}{v}}
    } \qquad
    
    \inferrule*[lab=E-Match]
    {
    \eval{\env}{m}{e}{v_0}\\
    \getat{m}{v_0} = \einj{i}{v_i}\\\\
    \eval{\env[x\mapsto v_i]}{m}{e_i}{v}
    }
    {
      \eval{\env}{m}{\econd{e}{e_1}{e_2}}{v}
    }\\ \\

    \inferrule*[lab=E-Fold]
    {
    \eval{\env}{m}{e}{v}
    }
    {
    \eval{\env}{m}{\efold{\trec{\alpha}{\tau}}{e}}{\efold{\trec{\alpha}{\tau}}{v}}
    } \qquad

    \inferrule*[lab=E-Unfold]
    {
    \eval{\env}{m}{e}{v_0}\\\\
    \getat{m}{v_0} = \efold{\trec{\alpha}{\tau}}{v}
    }
    {
    \eval{\env}{m}{\eunfold{e}}{v}
    } \qquad

    \inferrule*[lab=E-Share]
    {
    P\text{ is a singleton}    \\\\
    \eval{\env}{m}{e}{v}\\\\
    \getat{P}{v} = n  
    }
    {
    \eval{\env}{m}{\eshare{\psi}{P}{Q}{e}}{\vshare{Q}{\psi}{n}}
    }\\ \\
    
    \inferrule*[lab=E-BinopNat]
    {
  \eval{\env}{m}{e_1}{v_1}\\
  \getat{m}{v_1} = n_1\\\\
    \eval{\env}{m}{e_2}{v_2}\\
  \getat{m}{v_2} = n_2\\\\
  n = n_1 + n_2\\
    }
    {
    \eval{\env}{m}{\ebinop{e_1}{e_2}}{n}
    }\qquad

      
    \inferrule*[lab=E-BinopShare]
    {
  \eval{\env}{m}{e_1}{v_1}\\
  \getat{m}{v_1} = \vshare{m}{\psi}{e'_1} \\\\
    \eval{\env}{m}{e_2}{v_2}\\
  \getat{m}{v_2} = \vshare{m}{\psi}{e'_2} \\\\
  v = \vshare{m}{\psi}{\ebinop{e'_1}{e'_2}}
    }
    {
    \eval{\env}{m}{\ebinop{e_1}{e_2}}{v}
    }\\\\

    \inferrule*[lab=E-Mux]
    {
  \eval{\env}{m}{e}{v}\\
  \getat{m}{v} = \vshare{m}{\psi}{e'} \\\\
  \eval{\env}{m}{e_1}{v_1}\\
  \getat{m}{v_1} = \vshare{m}{\psi}{e'_1} \\\\
    \eval{\env}{m}{e_2}{v_2}\\
  \getat{m}{v_2} = \vshare{m}{\psi}{e'_2} \\\\
  v = \vshare{m}{\psi}{\emux{e'}{e_1'}{e_2'}}
    }
    {
    \eval{\env}{m}{\emux{e}{e_1}{e_2}}{v}
    }\qquad

    \inferrule*[lab=E-Reveal]
    {
    \eval{\env}{m}{e}{v_0}\\
    \getat{m}{v_0} = \vshare{m}{\psi}{e_0}\\\\
    \eval{\env}{m}{e_0}{v}\\
    n = \getat{P}{v} 
    } 
    {
    \eval{\env}{m}{\ereveal{P}{Q}{e}{\psi}}{\vloc{n}{Q}}
    }\\\\
    
    \inferrule*[lab=E-Var]
    {
    \env(x) = v
    }
    {
    \eval{\env}{m}{x}{v}
    }\qquad

    \inferrule*[lab=E-Let]
    {
    \eval{\env}{m}{e_1}{v_1}\\\\
    \eval{\env[x\mapsto v_1]}{m}{e_2}{v_2}
    }
    {
    \eval{\env}{m}{\elet{x}{e_1}{e_2}}{v_2}
    }\\ \\


   \inferrule*[lab=E-Abs]
    {
    }
    {
    \eval{\env}{m}{\elam{x}{e}}{\vclos{\env}{\elam{x}{e}}}
    }\qquad
   
    \inferrule*[lab=E-App]
    {
  \eval{\env}{m}{e}{v'}\\
    \getat{m}{v'} = \vclos{\env'}{\elam{x}{e'}}\\\\
  \eval{\env}{m}{e_1}{v_1}\\
  \eval{\env'[x \mapsto v_1]}{m}{e'}{v}\\
    }
    {
    \eval{\env}{m}{\eapp{e}{e_1}}{v}
    }\\ \\

    % \inferrule*[lab=E-Fix]
    % {
    % \eval{\env,f\!:\! \tfun{\tau_1}{\tau_2}{m}}{m}{\elam{x}{e}}{\tfun{\tau_1}{\tau_2}{m}}
    % }
    % {
    % \eval{\env}{m}{\efix{f}{x}{e}}{\tfun{\tau_1}{\tau_2}{m}}
    % }\qquad

    \inferrule*[lab=E-Par]
    {
    \env' = \locof{P}{\env}\\
    \eval{\env'}{{P}}{e}{v_0}\\
    v = \locof{P}{v_0}
    }
    {
    \eval{\env}{m}{\epar{P}{e}}{v}
    } \qquad
\end{array}
    $$
\caption{Operational Semantics}
\label{fig:sem}
\end{figure}

We define a big-step operational semantics. The judgment
$\eval{\env}{m}{e}{v}$ states that program
$e$ evaluates under mode $m$ and store $\env$ to a value
$v$. The rules are given in Figure~\ref{fig:sem}.  This is the
``single threaded semantics'' in that we don't have independently
executing parties; rather, we simulate the group of principals
$m$ executing in lockstep.

To be clear about which values reside on which parties' hosts, we have
a special value form to indicates this. Values are defined in
Figure~\ref{fig:auxsem}. The form $\vloc{u}{P}$ indicates that $u$ is
only visible to principals $p \in P$. Since not all values need to
be explicitly located (if they are in scope, they implicitly
are accessible), we distinguish \emph{locatable} values $u$.
Values for numbers, sums, and closures are standard (closures
have an explicit environment---we don't use substitution), as are
(locatable) values for pairs and recursive types. The value
$\vshare{Q}{\psi}{e}$ represents a circuit for a secure computation
under scheme $\psi$ to be performed by principals in $q \in Q$. Notice
that it contains an expression $e$, not a value $v$; this represents a
``suspended'' computation.

In the same figure are two functions over values: $\locof{P}{v}$ and
$\getat{v}{P}$. The first is a transformation of $v$ that
``relocates'' it to $P$. For locatable, but not located, values $u$,
we annotate them with $P$. For compound forms we recurse inside them
(sums, pairs, closure environments). Locating an environment locates
its mapped-to values pointwise.  For located values $\vloc{u}{Q}$ we
relocate $u$'s contents and update its location to be $P$ intersected
with $Q$. Note that this intersection could be the $\emptyset$ which
indicates an inaccessible value.

The function $\getat{v}{P}$ attempts to strip off the outermost
location designator so the value $v$ can be computed on. For all
values other than $\vloc{Q}{u}$ this is a no-op. For these, we confirm
that the location $Q$ is compatible with the accessing
environment. This is never true if the value's location $Q$ is
$\emptyset$; it will be true if $Q$ contains all principals in the
requested mode $P$.

Now we turn to the rules. Many of them are essentially standard, in
particular \rulelab{E-Nat}, \rulelab{E-Pair}, \rulelab{E-Inj},
\rulelab{E-Var}, \rulelab{E-Let}, and \rulelab{E-Abs}. Many others are
\emph{almost} standard, including \rulelab{E-Access},
\rulelab{E-Match}, \rulelab{E-Unfold}, \rulelab{E-BinopNat}, and
\rulelab{E-App}. These differ from their standard counterparts in that
that refer to $\getat{m}{v}$ in the premise---as elimination forms,
they have to have to strip off any location information to use the
value. This operation will fail if the value is not available to
(located at) all principals in the current mode $m$; the type system
aims to rule out this sort of problem.
\mwh{E-Fix is missing; not sure how to do this one!}

Skipping ahead, consider \rulelab{E-Par}, which evaluates
$\epar{P}{e}$. It evaluates $e$ is mode $P$ to produce $v_0$, but does
so in an environment $\sigma'$, which is the current environment
located at $P$ (which is constructed by intersecting mapped-to values'
locations with $P$). Similarly, the final result $v_0$ must also be
located at $P$ before it can be returned; this ensures that principals
in $m$ other than those in $P$ will not be able to access it. This
rule maintains an important invariant: \emph{the current environment $\sigma$ is
always compatible (located at) the current mode $m$.} This is needed,
for example, for \rulelab{E-Abs} to make sense, since it captures the
current environment to store in the produced closure.

Let's consider the remaining rules, which focus on multiparty
computation. \rulelab{E-Share} models principal $p \in P$
``encrypting'' an integer, sharing it with principals $Q$. Expression
$e$ is evaluated in the current mode $m$, but the direction is that
just $P$ is doing the sharing; hence we only check that $v$ is located
on $P$. We then encapsulate the extracted number $n$ in a share value,
split between principals at $Q$. \mwh{Should I also locate this at
  $Q$? I am assuming that $Q$ is already indicating the
  location. Revisit.}

\rulelab{E-BinopShare} permits multiparty computation on shares. It
makes sure both arguments are available to exactly the executing hosts
and the encapsulates the ``suspended'' computation in a share
itself. \rulelab{E-Mux} produces a multiplexor on shares. It evaluates
its arguments $e$, $e_1$, and $e_2$ to shares, and then constructs a
circuit involving all three.

\rulelab{E-Reveal} eliminates shares by ``forcing'' the suspended
computation in the given share. \mwh{Not sure if the mode here should
  be $m$ or $P$. Does it matter? Will the type system catch the
  mistakes in any case?} The final result is located at the designated
principals $Q$. 

\section{Typing}

\begin{figure}
\[\begin{array}{c}

    \inferrule*[lab=T-Nat]
    {
    }
    {
    \hastyp{\Gamma}{m}{n}{\tnat^{m}}
    }
    \qquad

    \inferrule*[lab=T-Read]
    {
    m\text{ is a singleton}
    }
    {
    \hastyp{\Gamma}{m}{\eread}{\tnat^{m}}
    }
    \qquad

    \inferrule*[lab=T-Pair]
    {
    \hastyp{\Gamma}{m}{e_1}{\tau_1}\\\\
    \hastyp{\Gamma}{m}{e_2}{\tau_2}
    }
    {
    \hastyp{\Gamma}{m}{\epair{e_1}{e_2}}{\tau_1 \times \tau_2}
    }\qquad
    
    \inferrule*[lab=T-Access]
    {
    m \vdash \tau_i \\\\
    \hastyp{\Gamma}{m}{e}{\tau_1 \times \tau_2}\\
    }
    {
    \hastyp{\Gamma}{m}{\eproj{i}{e}}{\tau_i}
    }\\\\

    \inferrule*[lab=T-inj]
    {
    \hastyp{\Gamma}{m}{e}{\tau}
    }
    {
    \hastyp{\Gamma}{m}{\einj{1}{e}}{\tsum{\tau}{\tau_0}{m}}\\\\
    \hastyp{\Gamma}{m}{\einj{2}{e}}{\tsum{\tau_0}{\tau}{m}}
    } \qquad
    
    \inferrule*[lab=T-Match]
    {
    \hastyp{\Gamma}{m}{e}{\tau_0 +^m \tau_1}\\\\
    m \vdash \tau_0 \\
    m \vdash \tau_1 \\\\
    \hastyp{\Gamma,x\!:\!\tau_0}{m}{e_1}{\tau}\\
    \hastyp{\Gamma,x\!:\!\tau_1}{m}{e_2}{\tau}\\
    }
    {
      \hastyp{\Gamma}{m}{\econd{e}{e_1}{e_2}}{\tau}
    }\\ \\

    \inferrule*[lab=T-Fold]
    {
    \hastyp{\Gamma}{m}{e}{\tau[\trec{\alpha}{\tau}\setminus\alpha]}
    }
    {
    \hastyp{\Gamma}{m}{\efold{\trec{\alpha}{\tau}}{e}}{\trec{\alpha}{\tau}}
    } \qquad

    \inferrule*[lab=T-Unfold]
    {
    \hastyp{\Gamma}{m}{e}{\trec{\alpha}{\tau}}
    }
    {
    \hastyp{\Gamma}{m}{\eunfold{e}}{\tau[\trec{\alpha}{\tau}\setminus\alpha]}
    } \\ \\

    \inferrule*[lab=T-Share]
    {
    P\text{ is a singleton}    \\\\
    m \vdash P\\
    m \vdash Q\\\\
    \hastyp{\Gamma}{m}{e}{\tnat^P}\\
    }
    {
    \hastyp{\Gamma}{m}{\eshare{\psi}{P}{Q}{e}}{\tnat^Q_\psi}
    }\qquad
    
    \inferrule*[lab=T-Binop]
    {
    \tau = \tnat^m_\psi\\\\
    \hastyp{\Gamma}{m}{e_1}{\tau}\\\\
    \hastyp{\Gamma}{m}{e_2}{\tau}\\
    }
    {
    \hastyp{\Gamma}{m}{\ebinop{e_1}{e_2}}{\tau}
    }\qquad

    \inferrule*[lab=T-Mux]
    {
    \tau = \tnat^m_\psi\\\\
    \hastyp{\Gamma}{m}{e}{\tau}\\\\
    \hastyp{\Gamma}{m}{e_1}{\tau}\\
    \hastyp{\Gamma}{m}{e_2}{\tau}\\
    }
    {
    \hastyp{\Gamma}{m}{\emux{e}{e_1}{e_2}}{\tau}
    }\\ \\

    \inferrule*[lab=T-Reveal]
    {
    m \vdash P\\
    m \vdash Q\\\\
    \hastyp{\Gamma}{m}{e}{\tnat^P_\psi}\\
    }
    {
    \hastyp{\Gamma}{m}{\ereveal{P}{Q}{e}{\psi}}{\tnat^Q}
    }\qquad
    
    \inferrule*[lab=T-Var]
    {
    x\!:\!\tau \in \Gamma
    }
    {
    \hastyp{\Gamma}{m}{x}{\tau}
    }\qquad

    \inferrule*[lab=T-Let]
    {
    \hastyp{\Gamma}{m}{e_1}{\tau_1}\\\\
    \hastyp{\Gamma, x\!:\!\tau_1}{m}{e_2}{\tau}
    }
    {
    \hastyp{\Gamma}{m}{\elet{x}{e_1}{e_2}}{\tau}
    }\\ \\


   \inferrule*[lab=T-Abs]
    {
    m \vdash m'\\\\
    \hastyp{\Gamma, x\!:\!\tau_1}{m'}{e}{\tau_2}
    }
    {
    \hastyp{\Gamma}{m}{\elam{x}{e}}{\tfun{\tau_1}{\tau_2}{m'}}
    }\qquad
   
    \inferrule*[lab=T-App]
    {
    \hastyp{\Gamma}{m}{e}{\tfun{\tau_1}{\tau}{m}}\\\\
    \hastyp{\Gamma}{m}{e_1}{\tau_1}\\
    }
    {
    \hastyp{\Gamma}{m}{\eapp{e}{e_1}}{\tau}
    }\qquad

    \inferrule*[lab=T-Fix]
    {
    \hastyp{\Gamma,f\!:\! \tfun{\tau_1}{\tau_2}{m}}{m}{\elam{x}{e}}{\tfun{\tau_1}{\tau_2}{m}}
    }
    {
    \hastyp{\Gamma}{m}{\efix{f}{x}{e}}{\tfun{\tau_1}{\tau_2}{m}}
    }\\ \\

    \inferrule*[lab=T-Par]
    {
    m \vdash P \\
    P \vdash \tau\\
    \hastyp{\Gamma}{{P}}{e}{\tau}
    }
    {
    \hastyp{\Gamma}{m}{\epar{P}{e}}{\tau}
    } \qquad

    \inferrule*[lab=T-Sub]
    {
    \hastyp{\Gamma}{m}{e}{\tau_1}\\
    \issub{\tau_1}{\tau_2}
    }
    {
    \hastyp{\Gamma}{m}{e}{\tau_2}
    }

  \end{array}
\]
\caption{Typing rules}
\label{fig:typing}
\end{figure}

The typing judgment's rules are defined in Figure~\ref{fig:typing}.
The typing judgment has form $\hastyp{\Gamma}{m}{e}{\tau}$. It states
that under context $\Gamma$, expression $e$ has type $\tau$ when
evaluating in mode $m$. These rules reference the judgment
$m \vdash m'$ which is given in Figure~\ref{fig:aux}. It says that
principals designated in $m'$ are \emph{present} when executing in
mode $m$. $m \vdash m'$ holds when $m = \top$ or $m = Q$ and $m' = P$
with $P \subseteq Q$.

Rule~\rulelab{T-Nat} types a (cleartext) constant; it inherits the
visibility of the current mode. Rule~\rulelab{T-Read} types the
\kw{read} command; since it will produce a different value at each
location, it must be run in the visibility of a single principal ($m$
must be a singleton set).

Jumping ahead, rule~\rulelab{T-Par} runs its expression $e$ in par
mode involving principals $P$; these principals must be compatible
with the current mode $m$ (i.e., they must be a subset of them). This
coercion is useful for making the requirements of other rules match
the expected mode; the rule is also an important hint to the execution
engine about which parties will run a particular block. This rule
requires that the returned result be compatible with current mode $P$;
i.e., it should be ``located'' at all principals $q \in P$.  For
example, in mode $\{p,q\}$ we don't want to return a value located
(only) at $q$. If we did, then subsequent access by $p$ would fail at
run-time, since the value is not actually present there.
%
Compatibility $m \vdash \tau$ is given in Figure~\ref{fig:aux}. We can
think of it as related to the semantic function $\getat{m}{v}$: If $v$
has type $\tau$ and $m \vdash \tau$ (with the expected extensions to
typing for new value forms), then $\getat{m}{v}$ should succeed.

Rule~\rulelab{T-Sub} is also useful for making type requirements match
up. The subtyping judgment is given in
Figure~\ref{fig:sub}. Intuitively, $\issub{\tau_1}{\tau_2}$ holds when
$\tau_1$ is compatible with the maximal mode that $\tau_2$ is
compatible with; i.e., it's OK to treat a value as being available at
fewer locations than it actually is. We can think of subtyping as
being related to semantic function $\locof{P}{v}$: if $v$ has type
$\tau_1$ and $\locof{P}{v}$ has type $\tau_2$, then assuming the
latter has no bogusly located values ($\vloc{v}{\emptyset}$), then we
want $\issub{\tau_1}{\tau_2}$. \mwh{Need to think through this}

Rule~\rulelab{T-Pair} types the introduction of pairs. A pair's
components must be typeable in the current mode, but they do not
necessarily need to have the same visibility; e.g., in mode $\{p,q\}$
a pair could have one component at $p$ and the other at
$q$. Rule~\rulelab{T-Access} types the elimination of pairs. Here we
require that the visibility of the element of type $\tau_i$ being
removed from the pair is compatible with the current mode $m$, per the
judgment $m \vdash \tau$.

Rules~\rulelab{T-Inj} and \rulelab{T-Match} are standard; as with the
elimination form for pairs, the latter rule requires both of the
to-be-accessed types to be compatible with the current mode. The rules
\rulelab{T-Fold} and \rulelab{T-Unfold} for recursive types are
standard.

Rule~\rulelab{T-Share} types encrypting a $\tnat$ (via secret
sharing). The $P$ argument indicates the principal doing the sharing,
and it must be a singleton. The $Q$ argument indicates the principals
to which to share $e$ (which must be a normal (non-share) value). This
value of $e$ must be visible in the current mode ($m \vdash P$) and
the principals $Q$ must be present as well. Finally, the value must be
a number; neither pairs nor functions can be shares.

Rule~\rulelab{T-Binop} types arithmetic computations on both shares
and normal values---both arguments must have the same type (i.e., both
shares or both normal values, with the same visibility), and match the
current mode. Note that this rule precludes adding a 
share and a normal value; you can always do this by converting the
latter to a share (the compiler can be smart about this).

Rule~\rulelab{T-Mux} types multiplexing. The semantics is to evaluate
both branches (second and third arguments), binding $x$ to the left
and right-hand sides of the sum, respectively. The $\kw{mux}$ chooses
the result to return based on the first argument's ultimate
result. These are all (compatible) shares (under protocol $\psi$), so
we can think of this as making a multiplexor circuit. The rule
restrict the results to be $\tnat$s, but this is easily generalized
via encoding (Section~\ref{sec:derived}).

Rule~\rulelab{T-Reveal} types share elimination, i.e., converting a
share of a $\tnat$ to a normal value. In essence, it forces the secure
computation (which we are thinking of as a thunk) to produce a result,
and reveals that result held by principals $P$ to the specified
principals $Q$. The rule requires that the current mode includes those
in $Q$, and those $P$ who hold the shares. (We do not allow revealing
encrypted sums, directly---we require destructing them first.)

Rule~\rulelab{T-Match} types conditionals on normal sums, i.e., the
conditional will run on each principal in mode $m$. It can return
shares or normal values, as desired. 

Unlike the elimination rules for pairs and sums, the \rulelab{T-Var}
does not mandate ``presence'' of its contents. So the following
program would typecheck: $\elet{x0}{\epar{b}0}{\epar{a}{x0}}$. When
checking the second $\kw{par}$ block, the type of $x0$ is $\tnat^{b}$,
and this variable is occurring with a $\kw{par}$ block with only $a$
present. But this is not prevented because nothing actually done with
the contents of that variable.

\rulelab{T-Let} is standard.

\rulelab{T-Abs} allows the body of a function to require a strictly
smaller mode than the defining context. \mwh{Why? Can't we just wrap
  in par mode? Rethink} \rulelab{T-App} requires the caller's mode to
match the mode annotation on the function; this ensures that all
principals that must be present in the function body will indeed be
running the function.

\mwh{Talk about T-Fix, which I don't have an operational rule for ...}

\begin{figure}
\[\begin{array}{c}

    \inferrule*[lab=M-top]
    {
    }
    {
    \top \vdash m
    } \qquad

    \inferrule*[lab=M-sub]
    {
    P \subseteq Q
    }
    {
    Q \vdash P
    } \qquad
    
    \inferrule*[lab=M-Nat]
    {
    m = n \vee
    (\psi = \cdot \Rightarrow n \vdash m)
    }
    {
    m \vdash \tnat^n_\psi
    } \\ \\

    \inferrule*[lab=M-Sum]
    {
    n \vdash m
    }
    {
    m \vdash \tsum{\tau_1}{\tau_2}{n}
    } \qquad

    \inferrule*[lab=M-Fun]
    {
    }
    {
    m \vdash \tfun{\tau_1}{\tau_2}{m}
    }\qquad

    \inferrule*[lab=M-Prod]
    { }
    {m \vdash \tprod{\tau_1}{\tau_2}}
    \qquad

    \inferrule*[lab=M-Rec]
    { }
    {m \vdash \trec{\alpha}{\tau}}
  \end{array}\]
\caption{Mode well-formedness}
\label{fig:aux}
\end{figure}
    
\begin{figure}
\[\begin{array}{c}

    \inferrule*[lab=S-Nat]
    {
    n \vdash \tnat^m_\psi
    }
    {
    \issub{\tnat^m_\psi}{\tnat^n_\psi}
    } \qquad

    \inferrule*[lab=S-Sum]
    {
    n \vdash \tsum{\tau_1'}{\tau_2'}{m}\\\\
    \issub{\tau_1}{\tau_1'} \land \issub{\tau_2}{\tau_2'}
    }
    {
    \issub{\tsum{\tau_1}{\tau_2}{m}}{\tsum{\tau_1'}{\tau_2'}{n}}
    } \qquad
    
    \inferrule*[lab=S-Fun]
    {
    \issub{\tau_1'}{\tau_1}\\
    \issub{\tau_2}{\tau_2'}
    }
    {
    \issub{\tfun{\tau_1}{\tau_2}{m}}{\tfun{\tau_1'}{\tau_2'}{m}}
    }\qquad

    
    \inferrule*[lab=S-Pair]
    {
    \issub{\tau_1}{\tau_1'}\\
    \issub{\tau_2}{\tau_2'}
    }
    {
    \issub{\tau_1 \times \tau_2}{\tau_1' \times \tau_2'}
    }
    
\end{array}
\]
\caption{Subtyping}
\label{fig:sub}
\end{figure}

\section{Derived Forms}
\label{sec:derived}

Rather than put every useful construct in the language, we can defined
some in terms of others.

\subsection{Generalized Mux}

The $\kw{mux}$ construct is restricted to returning encrypted
$\tnat$s. We can generalize this to returning pairs of encrypted
$\tnat$s:
\begin{verbatim}
muxtopair e e1 e2 =
  let b = e in
  let (l1,r1) = e1 in
  let (l2,r2) = e2 in
  (mux b l1 l2, mux b r1 r2)
\end{verbatim}
With this encoding, we can likewise support encrypted sums, which are
encoded as pairs of encrypted nats (see below).

\begin{itemize}
\item It seems evident we can work this out for equal-sized lists
  too. Generalized encoding for (non-encrypted) sums?
\end{itemize}

\subsection{Encrypted sums}

An encrypted sum is a value of the type
$\tprod{\tnat^m_\psi}{(\tprod{\tau_1}{\tau_2})}$. Here, the first
element is a boolean that represents whether the ``real'' portion of
the sum is the left side. We can introduce (encrypt) an existing sum
by doing the following:
\begin{verbatim}
let sharesum e def_lhs def_rhs =
  match e with
    x.(share 1,x,def_rhs)
  | x.(share 0,def_lhs,x)
\end{verbatim}
We can eliminate an encrypted sum by using $\kw{mux}$, which forces us
to produce a $\tnat^m_\psi$, to ensure obliviousness:
\begin{verbatim}
let muxshare e t f =
  let x = #1 e in
  let bs = #2 e in
  mux x ? t (#1 bs) : f (#2 bs)
\end{verbatim}

\mwh{TO DO}:
\begin{itemize}
\item I'm not sure if we literally want to encode this with functions,
  as above, or whether syntax like $\kw{match}$ which does the binding
  locally makes more sense.
\item I'm not sure about modes etc. Probably should just work out the
  derived rules for these things.
\end{itemize}
  
\subsection{Wire bundles and solo mode}

A wire bundle is just a product where each element of the product is
only visible to a single party. For simplicity, consider the smallest
one: $\tprod{\tnat^{\{p\}}_\psi}{\tnat^{\{q\}}_\psi}$. One way we
could write this as a derived type might be
$W~\{p,q\}~\tnat^\alpha_\phi$ where the interpretation is to
substitute each principal in the first argument to $W$ (a principal
set $P$) for $\alpha$ in the second argument (a type $\tau$).

To operate on a wire bundle we can use \emph{solo mode}, exemplified
in the construct $\kw{wmap}$:
\begin{verbatim}
let wmap (x:W {p,q} t) (f:t -> t0) =
  (par {p} (f (#1 x)), 
   par {q} (f (#2 x)))
\end{verbatim}
This runs the function $f$ on each element of the wire bundle, on its
respective host, and packages the results in another wire bundle. Note
that $f$ would need to be inlined at each call site because we don't
support polymorphism in the language. Moreover, $f$ might contain
occurrences of $\alpha$ which would  be substituted with
\texttt{\{p\}} in the first half of the pair, and \texttt{\{q\}} in
the second.

The above is basically Wysteria's notion of wire bundles when
constructed and operated on in $\kw{par}$ mode, and the \texttt{wmap}
above is similar to Wysteria's \texttt{waps}. Wysteria's notion of a
wire bundle in \texttt{sec} mode is basically a product of
shares, which is generated automatically by calling $\kw{share}$ on
each element of the input wire bundle. This is easily done:

\bigskip
\noindent
\texttt{wmap w }($\elam{x}{\eshare{\phi}{\alpha}{\{p,q\}}{x}}$)
\bigskip

\noindent
The \texttt{wmap} will produce a pair of shares (which . Notice the
$\alpha$ annotation on the $\kw{share}$---this will match the (solo)
mode of the principal doing the sharing, after substitution.

You can imagine generalizing this to wire bundles of arbitrary
size. You can also easily imagine converting this pair to a list, and
then supporting equivalent constructs like \texttt{wfold}.

\mwh{TO DO}
\begin{itemize}
  \item Do we want a way to run code over a wire bundle in which
    parties are not in solo mode? For example, they could run in full
    par mode (with both principals) but then accesses to the
    individual elements could be dropped to a single mode, for those
    accesses. For this, you need a map from principal $\alpha$ to
    index in the pair for $\alpha$'s value. For the accessor in the
    code, you use the map to extra from the pair. Maybe use ``self''
    and not $\alpha$. 
  \end{itemize}
  
\end{document}
