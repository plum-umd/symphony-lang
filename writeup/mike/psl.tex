\documentclass[10pt]{article}

\usepackage{times}
\usepackage{fullpage}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathpartir}
\usepackage{color}

%%%%% DEFS %%%%%%

\newcommand{\rulelab}[1]{{\small \textsc{#1}}}
\newcommand{\kw}[1]{\ensuremath{\mathtt{#1}}}

% Types
\newcommand{\tnat}{\ensuremath{\mathtt{nat}}}
\newcommand{\tfun}[3]{\ensuremath{{#1} ~^{#3}\!\rightarrow {#2}}}
\newcommand{\tprod}[2]{\ensuremath{{#1} \times {#2}}}
%\newcommand{\tsum}[4]{\ensuremath{{#1} +^{#3}_{#4} {#2}}}
\newcommand{\tsum}[3]{\ensuremath{{#1} +^{#3} {#2}}}
\newcommand{\trec}[2]{\ensuremath{\mu {#1}.{#2}}}
% \newcommand{\ssec}{\ensuremath{\mathtt{\cdot}}}
% \newcommand{\isec}{\ensuremath{\mathtt{pmap}}}
% \newcommand{\sshare}[1]{\ensuremath{\mathtt{shr}~{#1}}}
% \newcommand{\sectyp}[3]{\ensuremath{{#1} \{~{#2}:{#3}~\}}}
  
% Terms
\newcommand{\ebinop}[2]{\ensuremath{{#1}~\oplus~{#2}}}
\newcommand{\elet}[3]{\ensuremath{\kw{let}~#1\, =\, #2~\kw{in}\;{#3}}}
\newcommand{\epar}[2]{\ensuremath{\kw{par}~{#1}~{#2}}}
\newcommand{\esec}[2]{\ensuremath{\kw{sec}~{#1}~{#2}}}
\newcommand{\ereveal}[4]{\ensuremath{\kw{reveal}^{#1}_{#4}~{#2}~{#3}}}
\newcommand{\econd}[3]{\ensuremath{\kw{match}~{#1}~\kw{with}~x.{#2} \mid x.{#3}}}
%\newcommand{\emux}[3]{\ensuremath{\kw{mux}~{#1}~\kw{?}~x.{#2}~\kw{:}~x.{#3}}}
\newcommand{\emux}[3]{\ensuremath{\kw{mux}~{#1}~\kw{?}~{#2}~\kw{:}~{#3}}}
\newcommand{\eshare}[4]{\ensuremath{\kw{share}^{#2}_{#1}~{#3}~{#4}}}
%\newcommand{\esharesum}[4]{\ensuremath{\kw{sharesum}^{#2}_{#1}~{#3}~{#4}}}
\newcommand{\einj}[2]{\ensuremath{\kw{inj}_{#1}~{#2}}}
\newcommand{\eread}{\ensuremath{\kw{read}}}
\newcommand{\epair}[2]{\ensuremath{\langle {#1}, {#2} \rangle}}
\newcommand{\eproj}[2]{\ensuremath{\kw{\#}}_{#1}~{#2}}
\newcommand{\elam}[2]{\ensuremath{\lambda {#1}.{#2}}}
\newcommand{\eapp}[2]{\ensuremath{{#1}~{#2}}}
\newcommand{\efix}[3]{\ensuremath{\kw{fix}~{#1}.\elam{#2}{#3}}}
\newcommand{\efold}[2]{\ensuremath{\kw{fold}_{#1}~{#2}}}
\newcommand{\eunfold}[1]{\ensuremath{\kw{unfold}~{#1}}}

% Judgments
\newcommand{\hastyp}[4]{\ensuremath{{#1} \vdash_{#2} {#3} : {#4}}}
\newcommand{\canshare}[1]{\ensuremath{\text{isFlat } {#1}}}
\newcommand{\subtype}{\ensuremath{<:}}
\newcommand{\issub}[2]{{#1} \subtype {#2}}

% Aux
% \newcommand{\mpar}[1]{\ensuremath{\mathsf{p}(#1)}}
% \newcommand{\msec}[1]{\ensuremath{\mathsf{s}(#1)}}

%%%%%%%%%%

\newcommand{\mwh}[1]{\textcolor{red}{Mike: #1}}

\title{PANTHEON Source Language}
\author{PANTHEON Team}

\begin{document}

\maketitle

\section{TO DO}

Soon:
\begin{itemize}
\item Add text to go with sums (no longer encrypted, directly),
  recursive types, fixpoint functions. Work out some questions:
  \begin{itemize}
    \item Fixpoints now have the mode $m$ in the context and on the
      arrow as the same. In normal abstractions this doesn't need to
      be. Not sure if I'm being too restrictive.
    \item Sum construction doesn't require its components to be
      present, but deconstruction does. Is the latter required? It
      should be if it's the same as pair access; is it?
    \item No subtyping at present for recursive types. Should we add
      it?
    \end{itemize}
\item Develop operational semantics, both single threaded mode and
  multiparty mode. Make sure the types do what we want!
\end{itemize}

% Next: Look at \texttt{writeup/spdz.md} and think about language
% changes to support verification.

Later:
\begin{itemize}
\item Contemplate Muxable t psi, which denotes that there must be some
  way to combine two different values of type t according to a mux
  under protocol psi. From David D: \emph{Regarding muxable: I still see $A +^P_psi B$ as a sum type where psi only describes the encryption of the "sum bit", and $A$ and $B$ should either be shared base types, tuples, or shared sums (arbitrarily nested). This is the muxable constraint, and I think what David H had in mind.}
\item Contemplate generalized ``reveal'' operation, which works on all
  datatypes by recursing into their contents and revealing
  those. E.g., you could reveal a list of shares all at once.
\item drop $\top$ ?
\item First-class principal sets, as data,
  \begin{itemize}
    \item Add to syntactic forms (e.g., $\ereveal{P}{Q}{e}{\psi}$ should be
    $\ereveal{e_q}{e_q}{e}{\psi}$ where $e_P$ and $e_q$ are principal
    sets).
  \item Generalize wire bundles.
  \end{itemize}
\item Function types preclude top-level functions? See note below.
\end{itemize}

\begin{verbatim}
By the way, I don't know if this will overcomplicate everything, but
I've been thinking about how to get back the notion of applying a
function with fewer parties than were there when the closure was
made. (Which if I understand correctly is not possible in the current
version since function sub-typing is invariant in the knownness of the
function arrow). 

It seems that you can view the annotation ^m (on both values and
contexts) as a sort of upper bound on the parties who know some
information (which you can subtype to include fewer parties). 
Analogously you could imagine adding an annotation _n to represent a
lower bound on the parties who know information (conceptually, the
parties whose presence is mandatory to use a value). 
Then you could give function arrows this subtype rule:

t1' <: t1
t2 <: t2'
m >= m'
n' >= n
-------------------
t1 ->^m_n t2    <:    t1' ->^m'_n' t2'

The application rule would require the upper and lower bound to match: 

gamma |-^m_n e : t1 ->^m_m t2
gamma |-^m_n e1 : t1
------------------
gamma |-^m_n (e e1) : t2

par blocks would constrain the lower bound: By including a par block
as a subexpression you indicating that the containing expression must
involve the par block parties: 

m >= m'
gamma |-^m'_n e : t
--------------
gamma |-^m_(n \cup m') par m' e : t
\end{verbatim}


\begin{figure}[h]
  \centering
  \[\begin{array}{rlcll}
      \text{Principal} & p, q \\
      \text{Principal set} & P, Q \\
    \text{Execution modes} & m  & ::=  & \top & \text{par mode with all principals}\\
                       && \mid & P & \text{par mode with principals $P$} \\
      \text{Protocol} & \psi & ::= & \cdot & \text{cleartext} \\
                       && \mid & \phi & \text{encryption format} \\
      \text{Types} & \tau & ::=  & \tnat^m_\psi & \text{a base type} \\
                       && \mid & \tprod{\tau}{\tau} & \text{pairs} \\
%                       && \mid & \tsum{\tau}{\tau}{m}{\psi} & \text{sums} \\
                       && \mid & \tsum{\tau}{\tau}{m} & \text{sums} \\
                       && \mid & \trec{\alpha}{\tau} & \text{(iso)recursive types} \\
                       && \mid & \tfun{\tau}{\tau}{m} & \text{functions} \\
      \text{Protocol} & \psi & ::= & ... & \text{MPC type} \\
      \text{Expressions} & e & ::= & n & \text{naturals} \\
                       && \mid & x & \text{variables} \\
                       && \mid & \eread & \text{read from terminal}\\
                       && \mid & \epair{e_1}{e_2} & \text{pair construction}\\
                       && \mid & \eproj{i}{e} & \text{pair elem, }i \in \{1,2\}\\
                       && \mid & \eshare{\psi}{P}{Q}{e} & \text{$\psi$ shares of {\tnat} at $P$ to $Q$} \\
                       % && \mid & \esharesum{\psi}{P}{Q}{e} & \text{$\psi$ shares of sum $P$ to $Q$} \\
                       && \mid & \ereveal{P}{Q}{e}{\psi} & \text{distribute result in $\psi$ at $Q$ to $P$}\\
                       && \mid & \ebinop{e_1}{e_2}  & \text{binary operation} \\
                       && \mid & \emux{e}{e_1}{e_2}  & \text{MPC conditional} \\
                       && \mid & \einj{i}{e} & \text{sum elem, }i \in \{1,2\}\\
                       && \mid & \econd{e}{e_1}{e_2}  & \text{sum elimination} \\
                       && \mid & \efold{\trec{\alpha}{\tau}}{e} & \text{rectype intro}\\
                       && \mid & \eunfold{e} & \text{rectype elim}\\
                       && \mid & \epar{P}{e} & \text{parallel evaluation}\\
                       && \mid & \elam{x}{e}  & \text{abstraction} \\
                       && \mid & \eapp{e_1}{e_2}  & \text{application} \\
                       && \mid & \elet{x}{e_1}{e_2}  & \text{sequencing} \\
  \end{array}
  \]
  \caption{Syntax}
  \label{fig:syntax}
\end{figure}

\newpage

\section{Syntax}
  
The syntax of core PSL is in Figure~\ref{fig:syntax}.

There are two key concepts in types. First is their \emph{location},
designated $m$. Natural numbers, sums, and functions are located at
particular places; only here can they be computed on. Second (and in
addition), natural numbers and sums can be \emph{encrypted} as secret
shares (with a different share at each party among the locations
$m$). We annotate the sharing protocol (GMW, Yao, etc.) as $\psi$; the
``cleartext'' protocol is $\cdot$ (or simply elided, to reduce
clutter). Pairs and lists are not located in the same sense as the
other values. That is, all parties present in a computation when the
pair or list is created can see its structure. They may not, however,
be able to access its values, as these could be located at particular
locations.

\section{Semantics}

\begin{figure}
\end{figure}

The semantics is inspired by that of Wysteria, in there being a single
program involving multiple, lock-step principals. However, the notion
of secure mode has disappeared. We just have a mode $m$ which is
either $\top$, meaning all principals are conceptually executing the
present expression, or $P$ indicating that the principals
$p \in P$ are executing it, but other principals $q \not\in P$ are not
(they skip it). The computation always starts in mode $\top$, i.e.,
with all principals. Thus, each principal is running the same program,
but it will skip those blocks of code that don't apply to it.  A key
goal of the system is that all parties are ``present'' to perform
joint-secure operations when they need to be.

\mwh{The following is not quite true anymore: The ``spine'' of pairs
  and lists has to be maintained at all parties, I think.}
Our hoped-for invariant of the semantics is that all parties $p \in P$
will execute $e$ in $\epar{P}{e}$. Within $e$, there may be variables
$x$ that are only visible to some set $Q \subseteq P$. For those
$p \not\in Q$, it should be sufficient to store $\langle \rangle$
(unit) in this variable---it will never be ``destructed'' and is just
a placeholder.

Cryptographic computations are over natural numbers and sums. Whenever
something of this type ends up in destruct position (e.g.,
$\ebinop{e_1}{e_2}$) instead of actually doing the computation, we can
think of the operation as being made into a thunk.\footnote{Behind the
  scenes the operation might actually take place, e.g., when adding
  shares or communicating to multiply them. Or the frozen operation
  might result in a circuit being constructed.} For example, if we do
$\ebinop{e_1}{e_2}$ and $e_1$ and $e_2$ are both $\psi$ shares (i.e.,
of type $\tnat^m_\psi$ for a set of parties $m$), then we can imagine
that all parties will construct a circuit over those shares,
locally. The $\ereveal{P}{Q}{e}{\psi}$ construct takes as its argument
a share encoded using $\psi$ and forces the computation to
happen. That is, at that moment the secure computation will be forced
to completion, and the result revealed to the involved principals $Q$.

% Sum types can also be encrypted. The way we think about representing
% something of type $\tsum{\tau_1}{\tau_2}{m}{\psi}$ is that $\tau_1$
% and $\tau_2$ are stored in a pair $\tprod{\tau_1}{\tau_2}$, while
% location $m$ has access to an encrypted boolean (under $\psi$) which
% indicates whether the left or right element of the pair is valid. When
% computing on such a sum with $\emux{e}{e_1}{e_2}$, we feed the lhs
% into $e_1$ and compute it, feed the rhs into $e_2$ and compute that,
% and then select one output or the other based on the encrypted
% boolean.

\section{Typing}

\begin{figure}
\[\begin{array}{c}

    \inferrule*[lab=E-Nat]
    {
    }
    {
    \hastyp{\Gamma}{m}{n}{\tnat^{m}}
    }
    \qquad

    \inferrule*[lab=E-Read]
    {
    m\text{ is a singleton}
    }
    {
    \hastyp{\Gamma}{m}{\eread}{\tnat^{m}}
    }
    \qquad

    \inferrule*[lab=E-Pair]
    {
    \hastyp{\Gamma}{m}{e_1}{\tau_1}\\\\
    \hastyp{\Gamma}{m}{e_2}{\tau_2}
    }
    {
    \hastyp{\Gamma}{m}{\epair{e_1}{e_2}}{\tau_1 \times \tau_2}
    }\qquad
    
    \inferrule*[lab=E-Access]
    {
    m \vdash \tau_i \\\\
    \hastyp{\Gamma}{m}{e}{\tau_1 \times \tau_2}\\
    }
    {
    \hastyp{\Gamma}{m}{\eproj{i}{e}}{\tau_i}
    }\\\\

    \inferrule*[lab=E-inj]
    {
    \hastyp{\Gamma}{m}{e}{\tau}
    }
    {
    \hastyp{\Gamma}{m}{\einj{1}{e}}{\tsum{\tau}{\tau_0}{m}}\\\\
    \hastyp{\Gamma}{m}{\einj{2}{e}}{\tsum{\tau_0}{\tau}{m}}
    } \qquad
    
    \inferrule*[lab=E-Match]
    {
    \hastyp{\Gamma}{m}{e}{\tau_0 +^m \tau_1}\\\\
    m \vdash \tau_0 \\
    m \vdash \tau_1 \\\\
    \hastyp{\Gamma,x\!:\!\tau_0}{m}{e_1}{\tau}\\
    \hastyp{\Gamma,x\!:\!\tau_1}{m}{e_2}{\tau}\\
    }
    {
      \hastyp{\Gamma}{m}{\econd{e}{e_1}{e_2}}{\tau}
    }\\ \\

    \inferrule*[lab=E-Fold]
    {
    \hastyp{\Gamma}{m}{e}{\tau[\trec{\alpha}{\tau}\setminus\alpha]}
    }
    {
    \hastyp{\Gamma}{m}{\efold{\trec{\alpha}{\tau}}{e}}{\trec{\alpha}{\tau}}
    } \qquad

    \inferrule*[lab=E-Unfold]
    {
    \hastyp{\Gamma}{m}{e}{\trec{\alpha}{\tau}}
    }
    {
    \hastyp{\Gamma}{m}{\eunfold{e}}{\tau[\trec{\alpha}{\tau}\setminus\alpha]}
    } \\ \\

    \inferrule*[lab=E-Share]
    {
    P\text{ is a singleton}    \\\\
    m \vdash P\\
    m \vdash Q\\\\
    \hastyp{\Gamma}{m}{e}{\tnat^P}\\
    }
    {
    \hastyp{\Gamma}{m}{\eshare{\psi}{P}{Q}{e}}{\tnat^Q_\psi}
    }\qquad

    % \inferrule*[lab=E-Sharesum]
    % {
    % P\text{ is a singleton}    \\\\
    % m \vdash P\\
    % m \vdash Q\\\\
    % \hastyp{\Gamma}{m}{e}{\tsum{\tau_0}{\tau_1}{P}{}}
    % }
    % {
    % \hastyp{\Gamma}{m}{\esharesum{\psi}{P}{Q}{e}}{\tsum{\tau_0}{\tau_1}{Q}{\psi}}
    % } \\ \\
    
    \inferrule*[lab=E-Binop]
    {
    \tau = \tnat^m_\psi\\\\
    \hastyp{\Gamma}{m}{e_1}{\tau}\\\\
    \hastyp{\Gamma}{m}{e_2}{\tau}\\
    }
    {
    \hastyp{\Gamma}{m}{\ebinop{e_1}{e_2}}{\tau}
    }\qquad

    % \inferrule*[lab=E-Mux]
    % {
    % \hastyp{\Gamma}{m}{e}{\tau_0 +^m_\psi \tau_1}\\\\
    % m \vdash \tau_0 \\
    % m \vdash \tau_1 \\\\
    % \tau = \tnat^m_\psi \vee \tau = \tsum{\tau_2}{\tau_3}{m}{\psi}\\\\
    % \hastyp{\Gamma,x\!:\!\tau_0}{m}{e_1}{\tau}\\
    % \hastyp{\Gamma,x\!:\!\tau_1}{m}{e_2}{\tau}\\
    % }
    % {
    % \hastyp{\Gamma}{m}{\emux{e}{e_1}{e_2}}{\tau}
    % }\\ \\

    \inferrule*[lab=E-Mux]
    {
    \tau = \tnat^m_\psi\\\\
    \hastyp{\Gamma}{m}{e}{\tau}\\\\
    \hastyp{\Gamma}{m}{e_1}{\tau}\\
    \hastyp{\Gamma}{m}{e_2}{\tau}\\
    }
    {
    \hastyp{\Gamma}{m}{\emux{e}{e_1}{e_2}}{\tau}
    }\\ \\

    \inferrule*[lab=E-Reveal]
    {
    m \vdash P\\
    m \vdash Q\\\\
    \hastyp{\Gamma}{m}{e}{\tnat^P_\psi}\\
    }
    {
    \hastyp{\Gamma}{m}{\ereveal{P}{Q}{e}{\psi}}{\tnat^Q}
    }\qquad
    
    \inferrule*[lab=E-Var]
    {
    x\!:\!\tau \in \Gamma
    }
    {
    \hastyp{\Gamma}{m}{x}{\tau}
    }\qquad

    \inferrule*[lab=E-Let]
    {
    \hastyp{\Gamma}{m}{e_1}{\tau_1}\\\\
    \hastyp{\Gamma, x\!:\!\tau_1}{m}{e_2}{\tau}
    }
    {
    \hastyp{\Gamma}{m}{\elet{x}{e_1}{e_2}}{\tau}
    }\\ \\


   \inferrule*[lab=E-Abs]
    {
    m \vdash m'\\\\
    \hastyp{\Gamma, x\!:\!\tau_1}{m'}{e}{\tau_2}
    }
    {
    \hastyp{\Gamma}{m}{\elam{x}{e}}{\tfun{\tau_1}{\tau_2}{m'}}
    }\qquad
   
    \inferrule*[lab=E-App]
    {
    \hastyp{\Gamma}{m}{e}{\tfun{\tau_1}{\tau}{m}}\\\\
    \hastyp{\Gamma}{m}{e_1}{\tau_1}\\
    }
    {
    \hastyp{\Gamma}{m}{\eapp{e}{e_1}}{\tau}
    }\qquad

    \inferrule*[lab=E-Fix]
    {
    \hastyp{\Gamma,f\!:\! \tfun{\tau_1}{\tau_2}{m}}{m}{\elam{x}{e}}{\tfun{\tau_1}{\tau_2}{m}}
    }
    {
    \hastyp{\Gamma}{m}{\efix{f}{x}{e}}{\tfun{\tau_1}{\tau_2}{m}}
    }\\ \\

    \inferrule*[lab=E-Par]
    {
    m \vdash P \\
    P \vdash \tau\\
    \hastyp{\Gamma}{{P}}{e}{\tau}
    }
    {
    \hastyp{\Gamma}{m}{\epar{P}{e}}{\tau}
    } \qquad

    \inferrule*[lab=E-Sub]
    {
    \hastyp{\Gamma}{m}{e}{\tau_1}\\
    \issub{\tau_1}{\tau_2}
    }
    {
    \hastyp{\Gamma}{m}{e}{\tau_2}
    }

  \end{array}
\]
\caption{Typing rules}
\label{fig:typing}
\end{figure}

The typing judgment's rules are defined in Figure~\ref{fig:typing}.
The typing judgment has form $\hastyp{\Gamma}{m}{e}{\tau}$. It states
that under context $\Gamma$, expression $e$ has type $\tau$ when
evaluating in mode $m$. These rules reference the judgment
$m \vdash m'$ which is given in Figure~\ref{fig:aux}. It says that
principals designated in $m'$ are \emph{present} when executing in
mode $m$. $m \vdash m'$ holds when $m = \top$ or $m = Q$ and $m' = P$
and $P \subseteq Q$.

Rule~\rulelab{E-Nat} types a (cleartext) constant; it inherits the
visibility of the current mode. Rule~\rulelab{E-Read} types the
\kw{read} command; since it will produce a different value at each
location, it must be run in the visibility of a single principal ($m$
must be a singleton set).

Jumping ahead, rule~\rulelab{E-Par} runs its expression $e$ in par
mode involving principals $P$; these principals must be compatible
with the current mode $m$ (i.e., they must be a subset of them). This
coercion is useful for making the requirements of other rules match
the expected mode; the rule is also an important hint to the execution
engine about which parties will run a particular block. This rule
requires that the returned result be compatible with current mode $P$;
i.e., it should not be ``located'' at principals $q \not\in P$.
Compatibility $m \vdash \tau$ is given in Figure~\ref{fig:aux}. For
example, in mode $\{p\}$ we don't want to return a value located at
$q$. If we did, then subsequent access in mode $\{q\}$ would be
allowed by the type system but would fail at run-time as that location
did not perform the extraction (only $p$ did).

Rule~\rulelab{E-Sub} is also useful for making type requirements match
up. The subtyping judgment is given in Figure~\ref{fig:sub}. Simply
put, a cleartext value located at $m$ can be located at a compatible
location instead. When the value is encrypted, the location is
invariant. 

Rule~\rulelab{E-Pair} types the introduction of pairs. A pair's
components must be typeable in the current mode, but they do not
necessarily need to have the same visibility; e.g., in mode $\{p,q\}$
a pair could have one component at $p$ and the other at
$q$. Rule~\rulelab{E-Access} types the elimination of pairs. Here we
require that the visibility of the element of type $\tau_i$ being
removed from the pair is compatible with the current mode $m$, per the
judgment $m \vdash \tau$.

Rule~\rulelab{E-Share} types encrypting a $\tnat$ (via secret
sharing). The $P$ argument indicates the principal doing the sharing,
and it must be a singleton. The $Q$ argument indicates the principals
to which to share $e$ (which must be a normal (non-share) value). This
value of $e$ must be visible in the current mode ($m \vdash P$) and
the principals $Q$ must be present as well. Finally, the value must be
a number; neither pairs nor functions can be shares.

% Rule~\rulelab{E-Sharesum} types encrypting a sum type. The $P$ and $Q$
% arguments are as with \rulelab{E-Share}. No requirements are made
% about $\tau_0$ and $\tau_1$; their location is enforced when the pair
% is used in a $\kw{mux}$; see below.

Rule~\rulelab{E-Binop} types arithmetic computations on both shares
and normal values---both arguments must have the same type (i.e., both
shares or both normal values, with the same visibility), and match the
current mode. Note that this rule precludes adding a 
share and a normal value; you can always do this by converting the
latter to a share (the compiler can be smart about this).

% Rule~\rulelab{E-Mux} types multiplexing. The semantics is to evaluate
% both branches (second and third arguments), binding $x$ to the left
% and right-hand sides of the sum, respectively. The $\kw{mux}$ chooses
% the result to return based on the first argument's ultimate
% result. These are all (compatible) shares (under protocol $\psi$), so
% we can think of this as making a multiplexor circuit.

Rule~\rulelab{E-Mux} types multiplexing. The semantics is to evaluate
both branches (second and third arguments), binding $x$ to the left
and right-hand sides of the sum, respectively. The $\kw{mux}$ chooses
the result to return based on the first argument's ultimate
result. These are all (compatible) shares (under protocol $\psi$), so
we can think of this as making a multiplexor circuit. The rule
restrict the results to be $\tnat$s, but this is easily generalized
via encoding (Section~\ref{sec:derived}).

Rule~\rulelab{E-Reveal} types share elimination, i.e., converting a
share of a $\tnat$ to a normal value. In essence, it forces the secure
computation (which we are thinking of as a thunk) to produce a result,
and reveals that result held by principals $P$ to the specified
principals $Q$. The rule requires that the current mode includes those
in $Q$, and those $P$ who hold the shares. (We do not allow revealing
encrypted sums, directly---we require destructing them first.)

Rule~\rulelab{E-Match} types conditionals on normal sums, i.e., the
conditional will run on each principal in mode $m$. It can return
shares or normal values, as desired. 

Unlike the elimination rules for pairs and sums, the \rulelab{E-Var}
does not mandate ``presence'' of its contents. So the following
program would typecheck: $\elet{x0}{\epar{b}0}{\epar{a}{x0}}$. When
checking the second $\kw{par}$ block, the type of $x0$ is $\tnat^{b}$,
and this variable is occurring with a $\kw{par}$ block with only $a$
present. But this is not prevented because nothing actually done with
the contents of that variable.

\mwh{Say more about the let, abs, app rules. The let rule is
  unsurprising. Maybe point out that all hosts in $m$ must create the
  variable $x$, no matter the visibility of $\tau_1$. The abs rule
  needs to think about variables added in the closure. The app rule
  takes this into account.}

Rule~\rulelab{E-Sub} defines subsumption, using subtyping.  The
definition of subtyping $\issub{\tau_1}{\tau_2}$, which indicates when
$\tau_1$ can be used as $\tau_2$ is given in Figure~\ref{fig:sub}.

% The type of $\epar{P}{e} $ is $\sectyp{\omega}{\isec}{P}$
% type. This is because $e$ is executed independently by each principal
% $p \in P$. There are constraints on the type of $e$. Off the top of my
% head:
% \begin{itemize}
% \item All types with visibility $P$ are allowed. We can use subtyping
%   (to $Q \subset P$) as needed.
%   \item We can insert nested Par blocks, with a subset of principals,
%     I think. However, their results will only be visible to subsequent
%     par blocks with the same principal set (not the parent).
%   \item Conditional execution $\econd{e_1}{e_2}{e_3}$ when $e_1$ could
%     contain an $\isec$ needs to be limited. The issue will be if $e_2$
%     has a secure computation inside it; not all parties $P$ will
%     necessarily reach this point, because their values may differ in
%     $e_1$. Remedies:
%     \begin{itemize}
%       \item Only allow conditionals in Par blocks when $P$ is a singleton, or
%       \item Forbid computations on shares inside the branches of a
%         conditional when the guard involves an \isec.
%       \end{itemize}
% \end{itemize}


\begin{figure}
\[\begin{array}{c}

    \inferrule*[lab=M-top]
    {
    }
    {
    \top \vdash m
    } \qquad

    \inferrule*[lab=M-sub]
    {
    P \subseteq Q
    }
    {
    Q \vdash P
    } \qquad
    
    \inferrule*[lab=M-Nat]
    {
    m = n \vee
    (\psi = \cdot \Rightarrow m \vdash n)
    }
    {
    m \vdash \tnat^n_\psi
    } \\ \\

    % \inferrule*[lab=M-Sum]
    % {
    % m = n \vee
    % (\psi = \cdot \Rightarrow m \vdash n)
    % }
    % {
    % m \vdash \tsum{\tau_1}{\tau_2}{m}{\psi}
    % } \\ \\

    \inferrule*[lab=M-Sum]
    {
    m \vdash n
    }
    {
    m \vdash \tsum{\tau_1}{\tau_2}{m}
    } \qquad

    \inferrule*[lab=M-Fun]
    {
    m \vdash n
    }
    {
    m \vdash \tfun{\tau_1}{\tau_2}{n}
    }\qquad

    \inferrule*[lab=M-Prod]
    { }
    {m \vdash \tprod{\tau_1}{\tau_2}}
    \qquad

    \inferrule*[lab=M-Rec]
    { }
    {m \vdash \trec{\alpha}{\tau}}
  \end{array}\]
\caption{Mode well-formedness}
\label{fig:aux}
\end{figure}
    
\begin{figure}
\[\begin{array}{c}

    \inferrule*[lab=S-Nat]
    {
    m \vdash \tnat^n_\psi
    }
    {
    \issub{\tnat^m_\psi}{\tnat^n_\psi}
    } \qquad

    % \inferrule*[lab=S-Sum]
    % {
    % m \vdash \tsum{\tau_1'}{\tau_2'}{n}{\psi}\\\\
    % \psi = \cdot \Rightarrow \issub{\tau_1}{\tau_1'} \land \issub{\tau_2}{\tau_2'}\\\\
    % \psi \not= \cdot \Rightarrow \tau_1 = \tau_1' \land \tau_2 = \tau_2'\\
    % }
    % {
    % \issub{\tsum{\tau_1}{\tau_2}{m}{\psi}}{\tsum{\tau_1'}{\tau_2'}{n}{\psi}}
    % }

    \inferrule*[lab=S-Sum]
    {
    m \vdash \tsum{\tau_1'}{\tau_2'}{n}\\\\
    \issub{\tau_1}{\tau_1'} \land \issub{\tau_2}{\tau_2'}
    }
    {
    \issub{\tsum{\tau_1}{\tau_2}{m}}{\tsum{\tau_1'}{\tau_2'}{n}}
    } \qquad
    
    \inferrule*[lab=S-Fun]
    {
    \issub{\tau_1'}{\tau_1}\\
    \issub{\tau_2}{\tau_2'}
    }
    {
    \issub{\tfun{\tau_1}{\tau_2}{m}}{\tfun{\tau_1'}{\tau_2'}{m}}
    }\qquad

    
    \inferrule*[lab=S-Pair]
    {
    \issub{\tau_1}{\tau_1'}\\
    \issub{\tau_2}{\tau_2'}
    }
    {
    \issub{\tau_1 \times \tau_2}{\tau_1' \times \tau_2'}
    }
    
\end{array}
\]
\caption{Subtyping}
\label{fig:sub}
\end{figure}

\section{Derived Forms}
\label{sec:derived}

Rather than put every useful construct in the language, we can defined
some in terms of others.

\subsection{Generalized Mux}

The $\kw{mux}$ construct is restricted to returning encrypted
$\tnat$s. We can generalize this to returning pairs of encrypted
$\tnat$s:
\begin{verbatim}
muxtopair e e1 e2 =
  let b = e in
  let (l1,r1) = e1 in
  let (l2,r2) = e2 in
  (mux b l1 l2, mux b r1 r2)
\end{verbatim}
With this encoding, we can likewise support encrypted sums, which are
encoded as pairs of encrypted nats (see below).

\begin{itemize}
\item It seems evident we can work this out for equal-sized lists
  too. Generalized encoding for (non-encrypted) sums?
\end{itemize}

\subsection{Encrypted sums}

An encrypted sum is a value of the type
$\tprod{\tnat^m_\psi}{(\tprod{\tau_1}{\tau_2})}$. Here, the first
element is a boolean that represents whether the ``real'' portion of
the sum is the left side. We can introduce (encrypt) an existing sum
by doing the following:
\begin{verbatim}
let sharesum e def_lhs def_rhs =
  match e with
    x.(share 1,x,def_rhs)
  | x.(share 0,def_lhs,x)
\end{verbatim}
We can eliminate an encrypted sum by using $\kw{mux}$, which forces us
to produce a $\tnat^m_\psi$, to ensure obliviousness:
\begin{verbatim}
let muxshare e t f =
  let x = #1 e in
  let bs = #2 e in
  mux x ? t (#1 bs) : f (#2 bs)
\end{verbatim}

\mwh{TO DO}:
\begin{itemize}
\item I'm not sure if we literally want to encode this with functions,
  as above, or whether syntax like $\kw{match}$ which does the binding
  locally makes more sense.
\item I'm not sure about modes etc. Probably should just work out the
  derived rules for these things.
\end{itemize}
  
\subsection{Wire bundles and solo mode}

A wire bundle is just a product where each element of the product is
only visible to a single party. For simplicity, consider the smallest
one: $\tprod{\tnat^{\{p\}}_\psi}{\tnat^{\{q\}}_\psi}$. One way we
could write this as a derived type might be
$W~\{p,q\}~\tnat^\alpha_\phi$ where the interpretation is to
substitute each principal in the first argument to $W$ (a principal
set $P$) for $\alpha$ in the second argument (a type $\tau$).

To operate on a wire bundle we can use \emph{solo mode}, exemplified
in the construct $\kw{wmap}$:
\begin{verbatim}
let wmap (x:W {p,q} t) (f:t -> t0) =
  (par {p} (f (#1 x)), 
   par {q} (f (#2 x)))
\end{verbatim}
This runs the function $f$ on each element of the wire bundle, on its
respective host, and packages the results in another wire bundle. Note
that $f$ would need to be inlined at each call site because we don't
support polymorphism in the language. Moreover, $f$ might contain
occurrences of $\alpha$ which would  be substituted with
\texttt{\{p\}} in the first half of the pair, and \texttt{\{q\}} in
the second.

The above is basically Wysteria's notion of wire bundles when
constructed and operated on in $\kw{par}$ mode, and the \texttt{wmap}
above is similar to Wysteria's \texttt{waps}. Wysteria's notion of a
wire bundle in \texttt{sec} mode is basically a product of
shares, which is generated automatically by calling $\kw{share}$ on
each element of the input wire bundle. This is easily done:

\bigskip
\noindent
\texttt{wmap w }($\elam{x}{\eshare{\phi}{\alpha}{\{p,q\}}{x}}$)
\bigskip

\noindent
The \texttt{wmap} will produce a pair of shares (which . Notice the
$\alpha$ annotation on the $\kw{share}$---this will match the (solo)
mode of the principal doing the sharing, after substitution.

You can imagine generalizing this to wire bundles of arbitrary
size. You can also easily imagine converting this pair to a list, and
then supporting equivalent constructs like \texttt{wfold}.

\mwh{TO DO}
\begin{itemize}
  \item Do we want a way to run code over a wire bundle in which
    parties are not in solo mode? For example, they could run in full
    par mode (with both principals) but then accesses to the
    individual elements could be dropped to a single mode, for those
    accesses. For this, you need a map from principal $\alpha$ to
    index in the pair for $\alpha$'s value. For the accessor in the
    code, you use the map to extra from the pair. Maybe use ``self''
    and not $\alpha$. 
  \end{itemize}
  
\end{document}
