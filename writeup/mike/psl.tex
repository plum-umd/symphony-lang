\documentclass[10pt]{article}

\usepackage{times}
\usepackage{fullpage}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathpartir}
\usepackage{color}

%%%%% DEFS %%%%%%

\newcommand{\rulelab}[1]{{\small \textsc{#1}}}
\newcommand{\kw}[1]{\ensuremath{\mathtt{#1}}}

% Types
\newcommand{\tnat}{\ensuremath{\mathtt{nat}}}
\newcommand{\tlist}[1]{\ensuremath{\mathtt{list}~{#1}}}
\newcommand{\tfun}[3]{\ensuremath{{#1} ~^{#3}\!\rightarrow {#2}}}
\newcommand{\tprod}[2]{\ensuremath{{#1} \times {#2}}}
\newcommand{\tsum}[4]{\ensuremath{{#1} +^{#3}_{#4} {#2}}}
\newcommand{\ssec}{\ensuremath{\mathtt{\cdot}}}
\newcommand{\isec}{\ensuremath{\mathtt{pmap}}}
\newcommand{\sshare}[1]{\ensuremath{\mathtt{shr}~{#1}}}
\newcommand{\sectyp}[3]{\ensuremath{{#1} \{~{#2}:{#3}~\}}}
  
% Terms
\newcommand{\ebinop}[2]{\ensuremath{{#1}~\oplus~{#2}}}
\newcommand{\elet}[3]{\ensuremath{\kw{let}~#1\, =\, #2~\kw{in}\;{#3}}}
\newcommand{\epar}[2]{\ensuremath{\kw{par}~{#1}~{#2}}}
\newcommand{\esec}[2]{\ensuremath{\kw{sec}~{#1}~{#2}}}
\newcommand{\ereveal}[4]{\ensuremath{\kw{reveal}^{#1}_{#4}~{#2}~{#3}}}
\newcommand{\econd}[3]{\ensuremath{\kw{match}~{#1}~\kw{with}~{#2} \mid {#3}}}
\newcommand{\emux}[3]{\ensuremath{\kw{mux}~{#1}~\kw{?}~{#2}~\kw{:}~{#3}}}
\newcommand{\eshare}[4]{\ensuremath{\kw{share}^{#2}_{#1}~{#3}~{#4}}}
\newcommand{\esharesum}[4]{\ensuremath{\kw{sharesum}^{#2}_{#1}~{#3}~{#4}}}
\newcommand{\econcat}[2]{\ensuremath{{#1} +\!\!+~ {#2}}} 
\newcommand{\eaccval}[2]{\ensuremath{{#1}.{#2}}}
\newcommand{\eread}{\ensuremath{\kw{read}}}
\newcommand{\epair}[2]{\ensuremath{\langle {#1}, {#2} \rangle}}
\newcommand{\eproj}[2]{\ensuremath{\kw{\#}}_{#1}~{#2}}
\newcommand{\elam}[2]{\ensuremath{\lambda {#1}.{#2}}}
\newcommand{\eapp}[2]{\ensuremath{{#1}~{#2}}}

% Judgments
\newcommand{\hastyp}[4]{\ensuremath{{#1} \vdash_{#2} {#3} : {#4}}}
\newcommand{\canshare}[1]{\ensuremath{\text{isFlat } {#1}}}
\newcommand{\subtype}{\ensuremath{<:}}
\newcommand{\issub}[2]{{#1} \subtype {#2}}

% Aux
% \newcommand{\mpar}[1]{\ensuremath{\mathsf{p}(#1)}}
% \newcommand{\msec}[1]{\ensuremath{\mathsf{s}(#1)}}

%%%%%%%%%%

\newcommand{\mwh}[1]{\textcolor{red}{Mike: #1}}

\title{PANTHEON Source Language}
\author{PANTHEON Team}

\begin{document}

\maketitle

\begin{figure}[h]
  \centering
  \[\begin{array}{rlcll}
      \text{Principal} & p, q \\
      \text{Principal set} & P, Q \\
    \text{Execution modes} & m  & ::=  & \top & \text{par mode with all principals}\\
                       && \mid & P & \text{par mode with principals $P$} \\
      \text{Protocol} & \psi & ::= & \cdot & \text{cleartext} \\
                       && \mid & \phi & \text{encryption format} \\
      \text{Types} & \tau & ::=  & \tnat^m_\psi & \text{a base type} \\
                       && \mid & \tprod{\tau}{\tau} & \text{pairs} \\
                       && \mid & \tsum{\tau}{\tau}{m}{\psi} & \text{sums} \\
                       && \mid & \tlist{\tau} & \text{lists} \\
                       && \mid & \tfun{\tau}{\tau}{m} & \text{functions} \\
      \text{Protocol} & \psi & ::= & ... & \text{MPC type} \\
      \text{Expressions} & e & ::= & n & \text{naturals} \\
                       && \mid & x & \text{variables} \\
                       % && \mid & \econcat{e_1}{e_2} & \text{concatenate $\isec$s}\\
                       % && \mid & \eaccval{e}{p} & \text{$p$'s value}\\
                       && \mid & \eread & \text{read from terminal}\\
                       && \mid & \epair{e_1}{e_2} & \text{pair construction}\\
                       && \mid & \eproj{i}{e} & \text{pair elem, }i \in \{1,2\}\\
                       && \mid & \eshare{\psi}{P}{Q}{e} & \text{$\psi$ shares of {\tnat} at $P$ to $Q$} \\
                       && \mid & \esharesum{\psi}{P}{Q}{e} & \text{$\psi$ shares of sum $P$ to $Q$} \\
                       && \mid & \ereveal{P}{Q}{e}{\psi} & \text{distribute result in $\psi$ at $Q$ to $P$}\\
                       && \mid & \ebinop{e_1}{e_2}  & \text{binary operation} \\
                       && \mid & \econd{e_1}{e_2}{e_3}  & \text{non-MPC conditional} \\
                       && \mid & \emux{e_1}{e_2}{e_3}  & \text{MPC conditional} \\
                       && \mid & \epar{P}{e} & \text{parallel evaluation}\\
%                       && \mid & \eall{P}{e} & \text{parallel evaluation}\\
                       % && \mid & \esec{P}{e} & \text{secure (cryptographic) evaluation}\\
                       && \mid & \elam{x}{e}  & \text{abstraction} \\
                       && \mid & \eapp{e_1}{e_2}  & \text{application} \\
                       && \mid & \elet{x}{e_1}{e_2}  & \text{sequencing} \\
  \end{array}
  \]
  \caption{Syntax}
  \label{fig:syntax}
\end{figure}

\section{TO DO}

\begin{itemize}
\item finish list types (can't encrypt) 
\item drop $\top$ ?
\item I've dropped wire bundles and first-class principals, for
  now. These allow for generic, $N$-party computations. Will want
  later.
  \begin{itemize}
  \item Wire bundles. Can we encode these? We now allow tuples whose
    components $i$ have visibility $P_i \subseteq Q$ where $Q$ is the
    visibility of the entire tuple.
  \item Solo mode
  \item First-class principal sets, as data, and appearing in
    syntactic forms (e.g., $\ereveal{P}{Q}{e}{\psi}$ should be
    $\ereveal{e_q}{e_q}{e}{\psi}$ where $e_P$ and $e_q$ are principal sets).
  \end{itemize}
\end{itemize}

\section{Syntax}
  
The syntax of core PSL is in Figure~\ref{fig:syntax}.

There are two key concepts in types. First is their \emph{location},
designated $m$. Natural numbers, sums, and functions are located at
particular places; only here can they be computed on. Second (and in
addition), natural numbers and sums can be \emph{encrypted} as secret
shares (with a different share at each party among the locations
$m$). We annotate the sharing protocol (GMW, Yao, etc.) as $\psi$; the
``cleartext'' protocol is $\cdot$ (or simply elided, to reduce
clutter). Pairs and lists are not located in the same sense as the
other values. That is, all parties present in a computation when the
pair or list is created can see its structure. They may not, however,
be able to access its values, as these could be located at particular
locations.

\section{Semantics}

The semantics is inspired by that of Wysteria, in there being a single
program involving multiple, lock-step principals. However, the notion
of secure mode has disappeared. We just have a mode $m$ which is
either $\top$, meaning all principals are conceptually executing the
present expression, or $P$ indicating that the principals
$p \in P$ are executing it, but other principals $q \not\in P$ are not
(they skip it). The computation always starts in mode $\top$, i.e.,
with all principals. Thus, each principal is running the same program,
but it will skip those blocks of code that don't apply to it.  A key
goal of the system is that all parties are ``present'' to perform
joint-secure operations when they need to be.

\mwh{The following is not quite true anymore: The ``spine'' of pairs
  and lists has to be maintained at all parties, I think.}
Our hoped-for invariant of the semantics is that all parties $p \in P$
will execute $e$ in $\epar{P}{e}$. Within $e$, there may be variables
$x$ that are only visible to some set $Q \subseteq P$. For those
$p \not\in Q$, it should be sufficient to store $\langle \rangle$
(unit) in this variable---it will never be ``destructed'' and is just
a placeholder.

Cryptographic computations are over natural numbers and sums. Whenever
something of this type ends up in destruct position (e.g.,
$\ebinop{e_1}{e_2}$) instead of actually doing the computation, we can
think of the operation as being made into a thunk.\footnote{Behind the
  scenes the operation might actually take place, e.g., when adding
  shares or communicating to multiply them. Or the frozen operation
  might result in a circuit being constructed.} For example, if we do
$\ebinop{e_1}{e_2}$ and $e_1$ and $e_2$ are both $\psi$ shares (i.e.,
of type $\tnat^m_\psi$ for a set of parties $m$), then the result is
that all parties will construct a circuit over those shares,
locally. The $\ereveal{P}{Q}{e}{\psi}$ construct takes as its argument
a share encoded using $\psi$ and forces the computation to
happen. That is, at that moment the secure computation will be forced
to completion, and the result revealed to the involved principals $Q$.

\mwh{Something about how shares of nats and sums are represented. How
  mux works.}

\section{Typing}

\begin{figure}
\[\begin{array}{c}

    \inferrule*[lab=E-Nat]
    {
    }
    {
    \hastyp{\Gamma}{m}{n}{\tnat^{m}}
    }
    \qquad

    \inferrule*[lab=E-Read]
    {
    m\text{ is a singleton}
    }
    {
    \hastyp{\Gamma}{m}{\eread}{\tnat^{m}}
    }
    \\ \\

    \inferrule*[lab=E-Pair]
    {
    \hastyp{\Gamma}{m}{e_1}{\tau_1}\\
    \hastyp{\Gamma}{m}{e_2}{\tau_2}
    }
    {
    \hastyp{\Gamma}{m}{\epair{e_1}{e_2}}{\tau_1 \times \tau_2}
    }\qquad
    
    \inferrule*[lab=E-Access]
    {
    m \vdash \tau_i \\
    \hastyp{\Gamma}{m}{e}{\tau_1 \times \tau_2}\\
    }
    {
    \hastyp{\Gamma}{m}{\eproj{i}{e}}{\tau_i}
    }\\\\
    
    \inferrule*[lab=E-Share]
    {
    m \vdash P\\
    m \vdash Q\\\\
    \hastyp{\Gamma}{m}{e}{\tnat^P}\\
    }
    {
    \hastyp{\Gamma}{m}{\eshare{\psi}{P}{Q}{e}}{\tnat^Q_\psi}
    }    \qquad
    
    \inferrule*[lab=E-Reveal]
    {
    m \vdash P\\
    m \vdash Q\\\\
    \hastyp{\Gamma}{m}{e}{\tnat^P_\psi}\\
    }
    {
    \hastyp{\Gamma}{m}{\ereveal{P}{Q}{e}{\psi}}{\tnat^Q}
    }\\\\
    
    \inferrule*[lab=E-Sharesum]
    {
    m \vdash P\\
    m \vdash Q\\\\
    \hastyp{\Gamma}{m}{e}{\tsum{\tau_0}{\tau_1}{Q}{}}
    }
    {
    \hastyp{\Gamma}{m}{\esharesum{\psi}{P}{Q}{e}}{\tsum{\tau_0}{\tau_1}{P}{\psi}}
    } \\ \\
    
    \inferrule*[lab=E-Binop]
    {
    \tau = \tnat^m_\psi\\\\
    \hastyp{\Gamma}{m}{e_1}{\tau}\\
    \hastyp{\Gamma}{m}{e_2}{\tau}\\
    }
    {
    \hastyp{\Gamma}{m}{\ebinop{e_1}{e_2}}{\tau}
    }\qquad

    \inferrule*[lab=E-Mux]
    {
    \hastyp{\Gamma}{m}{e}{\tau_0 +^m_\psi \tau_1}\\\\
    m \vdash \tau_0 \\
    m \vdash \tau_1 \\\\
    \tau = \tnat^m_\psi \vee \tau = \tsum{\tau_2}{\tau_3}{m}{\psi}\\\\
    \hastyp{\Gamma,x\!:\!\tau_0}{m}{e_1}{\tau}\\
    \hastyp{\Gamma,x\!:\!\tau_1}{m}{e_2}{\tau}\\
    }
    {
    \hastyp{\Gamma}{m}{\emux{e}{e_1}{e_2}}{\tau}
    }\\ \\

    \inferrule*[lab=E-Match]
    {
    \hastyp{\Gamma}{m}{e}{\tau_0 +^m \tau_1}\\\\
    m \vdash \tau_0 \\
    m \vdash \tau_1 \\\\
    \hastyp{\Gamma,x\!:\!\tau_0}{m}{e_1}{\tau}\\
    \hastyp{\Gamma,x\!:\!\tau_1}{m}{e_2}{\tau}\\
    }
    {
      \hastyp{\Gamma}{m}{\econd{e}{e_1}{e_2}}{\tau}
    }\qquad

    \inferrule*[lab=E-Let]
    {
    \hastyp{\Gamma}{m}{e_1}{\tau_1}\\\\
    \hastyp{\Gamma, x\!:\!\tau_1}{m}{e_2}{\tau}
    }
    {
    \hastyp{\Gamma}{m}{\elet{x}{e_1}{e_2}}{\tau}
    }\\ \\

    \inferrule*[lab=E-Var]
    {
    x\!:\!\tau \in \Gamma
    }
    {
    \hastyp{\Gamma}{m}{x}{\tau}
    }\qquad

   \inferrule*[lab=E-Abs]
    {
    m \vdash m'\\
    \hastyp{\Gamma, x\!:\!\tau_1}{m'}{e}{\tau_2}
    }
    {
    \hastyp{\Gamma}{m}{\elam{x}{e}}{\tfun{\tau_1}{\tau_2}{m'}}
    }\qquad
   
    \inferrule*[lab=E-App]
    {
    \hastyp{\Gamma}{m}{e}{\tfun{\tau_1}{\tau}{m}}\\\\
    \hastyp{\Gamma}{m}{e_1}{\tau_1}\\
    }
    {
    \hastyp{\Gamma}{m}{\eapp{e}{e_1}}{\tau}
    }\\ \\

    \inferrule*[lab=E-Par]
    {
    m \vdash P \\
    \hastyp{\Gamma}{{P}}{e}{\tau}
    }
    {
    \hastyp{\Gamma}{m}{\epar{P}{e}}{\tau}
    } \qquad

    \inferrule*[lab=E-Sub]
    {
    \hastyp{\Gamma}{m}{e}{\tau_1}\\
    \issub{\tau_1}{\tau_2}
    }
    {
    \hastyp{\Gamma}{m}{e}{\tau_2}
    }

  \end{array}
\]
\caption{Typing rules}
\label{fig:typing}
\end{figure}

The typing judgment's rules are defined in Figure~\ref{fig:typing}.
The typing judgment has form $\hastyp{\Gamma}{m}{e}{\tau}$. It states
that under context $\Gamma$, expression $e$ has type $\tau$ when
evaluating in mode $m$. These rules reference the judgment
$m \vdash m;$ says that principals designated in $m'$ are
\emph{present} when executing in mode $m$. $m \vdash m'$ holds when
$m = \top$ or $m = Q$ and $m' = P$ and $P \subseteq Q$.

Rule~\rulelab{E-Nat} types a (private) constant; it inherits the
visibility of the current mode. Rule~\rulelab{E-Read} types the
\kw{read} command; since it will produce a different value at each
location, it must be run in the visibility of a single principal ($m$
must be a singleton set).

Jumping ahead, rule~\rulelab{E-Par} runs its expression $e$ in par
mode involving principals $P$; these principals must be compatible
with the current mode $m$ (i.e., they must be a subset of them). This
coercion is useful for making the requirements of other rules match
the expected mode; the rule is also an important hint to the execution
engine about which parties will run a particular block.

Rule~\rulelab{E-Sub} is also useful for making type requirements match
up. The subtyping judgment is given in Figure~\ref{fig:sub}.

Rule~\rulelab{E-Pair} types the introduction of pairs. A pair's
components must be typeable in the current mode, but they do not
necessarily need to have the same visibility; e.g., in mode $\{p,q\}$
a pair could have one component at $p$ and the other at
$q$. Rule~\rulelab{E-Access} types the elimination of pairs. Here we
require that the visibility of the element of type $\tau_i$ being
removed from the pair is compatible with the current mode $m$, per the
judgment $m \vdash \tau$ given in Figure~\ref{fig:aux}. This check is
needed to prevent one party from extracting the element of a pair that
is visible to parties not currently present; e.g., in mode $\{p\}$ we
don't want to allow extraction of a pair element located in
$\{p,q\}$. If we did, then subsequent access in mode $\{q\}$ would be
allowed by the type system but would fail at run-time as that location
did not perform the extraction (only $p$ did).

Rule~\rulelab{E-Share} types encrypting a $\tnat$. The $P$ argument
indicates the principal doing the sharing, while the $Q$ argument
indicates the principals to which to share $e$ (which must be a normal
(non-share) value). This value of $e$ must be visible in the current
mode ($m \vdash P$) and the principals $Q$ must be present as
well. Finally, the value must be a number; neither pairs nor functions
can be shares.  \mwh{Should we require the share's visibility $m'$ to
  be singleton?  Otherwise it will be unclear who should be sharing
  the value known to multiple parties.}

Rule~\rulelab{E-Reveal} types share elimination, i.e., converting a
share of a $\tnat$ to a normal value. In essence, it forces the secure
computation (which we are thinking of as a thunk) to produce a result,
and reveals that result held by principals $P$ to the specified
principals $Q$. The rule requires that the current mode includes those
in $Q$, and those $P$ who hold the shares.

\mwh{TODO: sharesum}

Rule~\rulelab{E-Binop} types arithmetic computations on both shares
and normal values---both arguments must have the same type (i.e., both
shares or both normal values, with the same visibility), and match the
current mode. Note that this rule precludes adding a 
share and a normal value; you can always do this by converting the
latter to a share (the compiler can be smart about this).

\mwh{Fix the following}
Rule~\rulelab{E-Mux} types multiplexing. The semantics is to evaluate
both branches (second and third arguments), and choose the result to
return based on the first argument's ultimate result. These are all
(compatible) shares, so we can think of this as making a multiplexor
circuit. 

Rule~\rulelab{E-Match} types conditionals on normal sums, i.e., the
conditional will run on each principal in mode $m$. It can return
shares or normal values, as desired. 

\mwh{Say more about the var, abs, app rules. The key here is that the
  variable rule does not require $\tau$'s visibility to match the
  current mode. The visibility requirement will be enforced later. The
  abs rule needs to think about variables added in the closure. The
  app rule takes this into account.}

Rule~\rulelab{E-Sub} defines subsumption, using subtyping.  The
definition of subtyping $\issub{\tau_1}{\tau_2}$, which indicates when
$\tau_1$ can be used as $\tau_2$ is given in Figure~\ref{fig:sub}.

% The type of $\epar{P}{e} $ is $\sectyp{\omega}{\isec}{P}$
% type. This is because $e$ is executed independently by each principal
% $p \in P$. There are constraints on the type of $e$. Off the top of my
% head:
% \begin{itemize}
% \item All types with visibility $P$ are allowed. We can use subtyping
%   (to $Q \subset P$) as needed.
%   \item We can insert nested Par blocks, with a subset of principals,
%     I think. However, their results will only be visible to subsequent
%     par blocks with the same principal set (not the parent).
%   \item Conditional execution $\econd{e_1}{e_2}{e_3}$ when $e_1$ could
%     contain an $\isec$ needs to be limited. The issue will be if $e_2$
%     has a secure computation inside it; not all parties $P$ will
%     necessarily reach this point, because their values may differ in
%     $e_1$. Remedies:
%     \begin{itemize}
%       \item Only allow conditionals in Par blocks when $P$ is a singleton, or
%       \item Forbid computations on shares inside the branches of a
%         conditional when the guard involves an \isec.
%       \end{itemize}
% \end{itemize}


\begin{figure}
\[\begin{array}{c}

    \inferrule*[lab=M-Nat]
    {
    m = n \vee
    (\psi = \cdot \Rightarrow m \vdash n)
    }
    {
    m \vdash \tnat^n_\psi
    } \qquad

    \inferrule*[lab=M-Sum]
    {
    m = n \vee
    (\psi = \cdot \Rightarrow m \vdash n)
    }
    {
    m \vdash \tsum{\tau_1}{\tau_2}{m}{\psi}
    } \qquad

    \inferrule*[lab=M-Fun]
    {
    m \vdash n
    }
    {
    m \vdash \tfun{\tau_1}{\tau_2}{n}
    }\\\\

    \inferrule*[lab=M-Prod]
    { }
    {m \vdash \tprod{\tau_1}{\tau_2}}
    \qquad

    \inferrule*[lab=M-List]
    { }
    {m \vdash \tlist{\tau}}
  \end{array}\]
\caption{Mode well-formedness}
\label{fig:aux}
\end{figure}
    
\begin{figure}
\[\begin{array}{c}

    \inferrule*[lab=S-Nat]
    {
    m \vdash \tnat^n_\psi
    }
    {
    \issub{\tnat^m_\psi}{\tnat^n_\psi}
    } \qquad

    \inferrule*[lab=S-Sum]
    {
    m \vdash \tsum{\tau_1'}{\tau_2'}{n}{\psi}\\\\
    \psi = \cdot \Rightarrow \issub{\tau_1}{\tau_1'} \land \issub{\tau_2}{\tau_2'}\\\\
    \psi \not= \cdot \Rightarrow \tau_1 = \tau_1' \land \tau_2 = \tau_2'\\
    }
    {
    \issub{\tsum{\tau_1}{\tau_2}{m}{\psi}}{\tsum{\tau_1'}{\tau_2'}{n}{\psi}}
    }
    \\ \\
    
    \inferrule*[lab=S-Fun]
    {
    \issub{\tau_1'}{\tau_1}\\
    \issub{\tau_2}{\tau_2'}
    }
    {
    \issub{\tfun{\tau_1}{\tau_2}{m}}{\tfun{\tau_1'}{\tau_2'}{m}}
    }\qquad

    
    \inferrule*[lab=S-Pair]
    {
    \issub{\tau_1}{\tau_1'}\\
    \issub{\tau_2}{\tau_2'}
    }
    {
    \issub{\tau_1 \times \tau_2}{\tau_1' \times \tau_2'}
    }
    \qquad

    \inferrule*[lab=S-List]
    {
    \issub{\tau}{\tau'}
    }
    {
    \issub{\tlist{\tau}}{\tlist{\tau'}}
    }
    
\end{array}
\]
\caption{Subtyping}
\label{fig:sub}
\end{figure}


\end{document}
