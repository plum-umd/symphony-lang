\documentclass[10pt]{article}

\usepackage{times}
\usepackage{fullpage}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathpartir}
\usepackage{color}

%%%%% DEFS %%%%%%

\newcommand{\rulelab}[1]{{\small \textsc{#1}}}
\newcommand{\kw}[1]{\ensuremath{\mathtt{#1}}}

% Types
\newcommand{\tnat}{\ensuremath{\mathtt{nat}}}
\newcommand{\tlist}[1]{\ensuremath{\mathtt{list}~{#1}}}
\newcommand{\tfun}[2]{\ensuremath{{#1} \rightarrow {#2}}}
\newcommand{\tprod}[2]{\ensuremath{{#1} \times {#2}}}
\newcommand{\tsum}[2]{\ensuremath{{#1} + {#2}}}
\newcommand{\ssec}{\ensuremath{\mathtt{\cdot}}}
\newcommand{\isec}{\ensuremath{\mathtt{pmap}}}
\newcommand{\sshare}[1]{\ensuremath{\mathtt{shr}~{#1}}}
\newcommand{\sectyp}[3]{\ensuremath{{#1} \{~{#2}:{#3}~\}}}
  
% Terms
\newcommand{\ebinop}[2]{\ensuremath{{#1}~\oplus~{#2}}}
\newcommand{\elet}[3]{\ensuremath{\kw{let}~#1\, =\, #2~\kw{in}\;{#3}}}
\newcommand{\epar}[2]{\ensuremath{\kw{par}~{#1}~{#2}}}
\newcommand{\esec}[2]{\ensuremath{\kw{sec}~{#1}~{#2}}}
\newcommand{\ereveal}[2]{\ensuremath{\kw{reveal}~{#1}~{#2}}}
\newcommand{\econd}[3]{\ensuremath{\kw{if}~{#1}~\kw{then}~{#2}~\kw{else}~{#3}}}
\newcommand{\emux}[3]{\ensuremath{\kw{mux}~{#1}~\kw{?}~{#2}~\kw{:}~{#3}}}
\newcommand{\eshare}[3]{\ensuremath{\kw{share}_{#1}~{#2}~{#3}}}
\newcommand{\esharemap}[3]{\ensuremath{\kw{sharemap}_{#1}~{#2}~{#3}}}
\newcommand{\econcat}[2]{\ensuremath{{#1} +\!\!+~ {#2}}} 
\newcommand{\eaccval}[2]{\ensuremath{{#1}.{#2}}}
\newcommand{\eread}{\ensuremath{\kw{read}}}
\newcommand{\epair}[2]{\ensuremath{\langle {#1}, {#2} \rangle}}
\newcommand{\eproj}[2]{\ensuremath{\kw{\#}}_{#1}~{#2}}

% Judgments
\newcommand{\hastyp}[4]{\ensuremath{{#1} \vdash_{#2} {#3} : {#4}}}
\newcommand{\canshare}[1]{\ensuremath{\text{isFlat } {#1}}}
\newcommand{\subtype}{\ensuremath{<:}}
\newcommand{\issub}[2]{{#1} \subtype {#2}}

% Aux
% \newcommand{\mpar}[1]{\ensuremath{\mathsf{p}(#1)}}
% \newcommand{\msec}[1]{\ensuremath{\mathsf{s}(#1)}}

%%%%%%%%%%

\newcommand{\mwh}[1]{\textcolor{red}{Mike: #1}}

\title{PANTHEON Source Language}
\author{PANTHEON Team}

\begin{document}

\maketitle

\begin{figure}[h]
  \centering
  \[\begin{array}{rlcll}
      \text{Raw types} & \omega  & ::=  & \tnat & \text{a base type} \\      
                       && \mid & \tprod{\tau}{\tau} & \text{pairs} \\
                       && \mid & \tsum{\tau}{\tau} & \text{sums} \\
                       && \mid & \tlist{\tau} & \text{lists} \\
                       && \mid & \tfun{\tau}{\tau} & \text{functions} \\
      \text{Types} & \tau & ::= &
                       %                  \omega & \text{cleartext values} \\
                       % && \mid &
                                 \sectyp\omega\phi{P} & \text{located values} \\
      \text{Principal} & p, q \\
      \text{Principal set} & P, Q \\
      \text{Format} & \phi & ::= & \ssec & \text{private value}  \\
                       % && \mid & \isec & \text{per-principal value}  \\
                       && \mid & \sshare{\psi} & \text{secret share of type $\psi$} \\
      \text{Protocol} & \psi & ::= & ... & \text{MPC type} \\
      \text{Expressions} & e & ::= & n & \text{naturals} \\
                       && \mid & x & \text{variables} \\
                       % && \mid & \econcat{e_1}{e_2} & \text{concatenate $\isec$s}\\
                       % && \mid & \eaccval{e}{p} & \text{$p$'s value}\\
                       && \mid & \eread & \text{read from terminal}\\
                       && \mid & \epair{e_1}{e_2} & \text{pair construction}\\
                       && \mid & \eproj{i}{e} & \text{pair elem, }i \in \{1,2\}\\
                       && \mid & \eshare{\psi}{P}{e} & \text{$\psi$ shares to $P$} \\
                       % && \mid & \esharemap{\psi}{P}{e} & \text{$\psi$ shares of $\isec$ to $P$} \\
                       && \mid & \ebinop{e_1}{e_2}  & \text{binary operation} \\
                       && \mid & \elet{x}{e_1}{e_2}  & \text{sequencing} \\
                       && \mid & \econd{e_1}{e_2}{e_3}  & \text{non-MPC conditional} \\
                       && \mid & \emux{e_1}{e_2}{e_3}  & \text{MPC conditional} \\
                       && \mid & \epar{P}{e} & \text{parallel evaluation}\\
%                       && \mid & \eall{P}{e} & \text{parallel evaluation}\\
                       % && \mid & \esec{P}{e} & \text{secure (cryptographic) evaluation}\\
                       && \mid & \ereveal{P}{e} & \text{distribute result to $P$}\\
    \text{Execution modes} & m  & ::=  & \top & \text{par mode with all principals}\\
                 && \mid & P & \text{par mode with principals $P$} \\      
  \end{array}
  \]
  \caption{Syntax}
  \label{fig:syntax}
\end{figure}

\section{TO DO}

\begin{itemize}
\item I've dropped wire bundles and first-class principals, for
  now. These allow for generic, $N$-party computations. Will want
  later.
\item It occurs to me that the per-principal comprehension
  construct, that we were equating with par blocks, might not be the
  same thing. Instead, it's probably like a map over a wire bundle,
  where the bundle is just the identity map over a set of
  principals. Then, the function being mapped has access to that
  principal in that function.
\item Pairs are wrong. If I have a pair that is a share, and then I
  access its first element, it should also be a share. So the
  interesting question is what the content of a pair should be. Maybe
  my constructor interleaving is wrong?
\end{itemize}

\section{Syntax}
  
The syntax of core PSL is in Figure~\ref{fig:syntax}. \mwh{Need terms for
  lists, sums, pairs -- construct, destruct}

\mwh{Fix mode problem -- modes in types and turnstiles should match
  (i.e., should allow $\top$ in types)}

\subsection{Types}

Raw types $\omega$ are normal types (numbers, pairs, lists,
functions). Types $\tau$ are either raw types $\omega$, which mean
that they are visible to all parties (who agree on their values) in
the clear, or they are security types $\sectyp{\omega}{\phi}{P}$. The
structure of the latter is a the raw type $\omega$, the \emph{format}
$\phi$, and visibility $P$, which is a list of principals who can
access/see the value.  The raw type indicates the basic type of the
value (function, number, list, etc.), while the format is either
\emph{secret shares} $\sshare\psi$, which indicate a single 
  value that is secret-shared among the given set of parties $P$,
  amenable to MPC using protocol $\psi$ (e.g., BGW, GMW, Yao), or 
\emph{secrets} \ssec, which indicate a single value known to
  (accessible by) those parties in the set $P$, but no others.
% \item \emph{maps} \isec, which indicate a single variable for which
%   each principal in $P$ may have a distinct value, known only to that
%   principal. 

\subsection{Terms}

% \mwh{Ramble follows; I think the upshot is that this doesn't work}
% We make shares explicitly among some set of principals operating in
% lockstep. So, shares of $e$ to $P$ require being in a par block
% involving $Q \supseteq P$. But in Wysteria, you can only access a wire
% bundle value in par mode if it's a singleton. This is to prevent Alice
% and Bob access their values, which would be OK if subset was OK, and
% then summing them up. I think this has to be in a sec block.

% Should secure mode always return a share type? Thus, Wysteria is
% reveal P (sec P e) ? But this seems not to work with the above. It
% requires I explicitly share with a subset of principals, rather than
% implicitly share with all of them on return.

\section{Semantics}

The semantics is inspired by that of Wysteria, in there being a single
program involving multiple, lock-step principals. However, the notion
of secure mode has disappeared. We just have a mode $M$ which is
either $\top$, meaning all principals are conceptually executing the
present expression, or ${P}$ indicating that the principals
$p \in P$ are executing it, but other principals $q \not\in P$ are not
(they skip it). The computation always starts in mode $\top$, i.e.,
with all principals. Thus, each principal is running the same program,
but it will skip those blocks of code that don't apply to it.  A key
goal of the system is that all parties are ``present'' to perform
joint-secure operations when they need to be.

Cryptographic computations are those over values of
$\sectyp{\omega}{\sshare{\psi}}{P}$ type. Whenever something of this
type ends up in destruct position (e.g., $\ebinop{e_1}{e_2}$) instead
of actually doing the computation, we can think of the operation as
being made into a thunk.\footnote{Behind the scenes the operation
  might actually take place, e.g., when adding shares or communicating
  to multiply them. Or the frozen operation might result in a circuit
  being constructed.} For example, if we do $\ebinop{e_1}{e_2}$ and
$e_1$ and $e_2$ are both shares (i.e., of type $\sshare{\psi}$), then
the result is that both parties will construct a circuit over those
shares, locally. The $\ereveal{P}{e}$ construct takes as its argument
a share and forces the computation to happen. That is, at that moment
the secure computation will be forced to completion, and the result
revealed to the involved principals $P$.

Not all operations can happen cryptographically. For example, a
$\kw{mux}$ operation can, and thus can operate directly on shares, but
a conditional $\kw{if}$ cannot---it operates on cleartext values,
running on each host.

\section{Typing}

\begin{figure}
\[\begin{array}{c}

    \inferrule*[lab=E-Nat]
    {
    }
    {
    \hastyp{\Gamma}{m}{n}{\sectyp{\tnat}{\ssec}{m}}
    }
    \qquad

    \inferrule*[lab=E-Read]
    {
    m\text{ is a singleton}
    }
    {
    \hastyp{\Gamma}{m}{\eread}{\sectyp{\tnat}{\ssec}{m}}
    }
    \qquad

    \inferrule*[lab=E-Par]
    {
    m \vdash P \\
    \hastyp{\Gamma}{{P}}{e}{\tau}
    }
    {
    \hastyp{\Gamma}{m}{\epar{P}{e}}{\tau}
    }
    \\ \\

    \inferrule*[lab=E-Pair]
    {
    \tau_1 = \sectyp{\omega_1}{\phi_1}{m}\\
    \tau_2 = \sectyp{\omega_2}{\phi_2}{m}\\\\
    \hastyp{\Gamma}{m}{e_1}{\tau_1}\\
    \hastyp{\Gamma}{m}{e_1}{\tau_2}
    }
    {
    \hastyp{\Gamma}{m}{\epair{e_1}{e_2}}{\sectyp{\tprod{\tau_1}{\tau_2}}{\ssec}{m}}
    }\qquad
    
    \inferrule*[lab=E-Access]
    {
    m \vdash P\\
    \hastyp{\Gamma}{m}{e}{\sectyp{\tprod{\tau_1}{\tau_2}}{\phi}{P}}\\
    }
    {
    \hastyp{\Gamma}{m}{\eproj{i}{e}}{\tau_i}
    }\\\\
    
    \inferrule*[lab=E-Share]
    {
    m \vdash P\\
    m \vdash R\\\\
    \hastyp{\Gamma}{m}{e}{\sectyp{\omega}{\ssec}{R}}\\
    \text{isFlat }\tau
    }
    {
    \hastyp{\Gamma}{m}{\eshare{\psi}{P}{e}}{\sectyp{\omega}{\sshare{\psi}}{P}}
    }    \qquad
    
    \inferrule*[lab=E-Reveal]
    {
    m \vdash P\\
    m \vdash R\\\\
    \hastyp{\Gamma}{m}{e}{\sectyp{\omega}{\sshare{\psi}}{R}}\\
    }
    {
    \hastyp{\Gamma}{m}{\ereveal{P}{e}}{\sectyp{\omega}{\ssec}{P}}
    }\\\\
    
    \inferrule*[lab=E-Binop]
    {
    \tau = \sectyp{\tnat}{\phi}{P}\\
    m \vdash P\\\\
    \hastyp{\Gamma}{m}{e_1}{\tau}\\
    \hastyp{\Gamma}{m}{e_2}{\tau}\\
    }
    {
    \hastyp{\Gamma}{m}{\ebinop{e_1}{e_2}}{\tau}
    }\qquad

    \inferrule*[lab=E-Mux]
    {
    \tau = \sectyp{\tnat}{\phi}{P}\\
    \tau' = \sectyp{\omega}{\phi}{P}\\
    m \vdash P\\\\
    \hastyp{\Gamma}{m}{e}{\tau}\\
    \hastyp{\Gamma}{m}{e_1}{\tau'}\\
    \hastyp{\Gamma}{m}{e_2}{\tau'}\\
    }
    {
    \hastyp{\Gamma}{m}{\emux{e}{e_1}{e_2}}{\tau'}
    }\\ \\

    \inferrule*[lab=E-Cond]
    {
    \tau = \sectyp{\tnat}{\ssec}{P}\\
    \tau' = \sectyp{\omega}{\phi}{P}\\
    m \vdash P\\\\
    \hastyp{\Gamma}{m}{e}{\tau}\\
    \hastyp{\Gamma}{m}{e_1}{\tau'}\\
    \hastyp{\Gamma}{m}{e_2}{\tau'}\\
    }
    {
    \hastyp{\Gamma}{m}{\econd{e}{e_1}{e_2}}{\tau}
    }\\ \\
   
    \inferrule*[lab=E-Var]
    {
    x\!:\!\tau \in \Gamma\\
    \tau = \sectyp{\omega}{\phi}{P}\\
    m \vdash P
    }
    {
    \hastyp{\Gamma}{m}{x}{\tau}
    }
  \end{array}
\]
\caption{Typing rules}
\label{fig:typing}
\end{figure}

The typing judgment's rules are defined in Figure~\ref{fig:typing}.

The typing judgment has form $\hastyp{\Gamma}{m}{e}{\tau}$. It states
that under context $\Gamma$, expression $e$ has type $\tau$ when
evaluating in mode $m$. Mode $m$ is a set of principals $P$ (``par
mode'' in involving $P$) or $\top$, which is a shorthand for all
principals participating.

\mwh{Not sure if E-var is correct. Should I prohibit lookups if the
  variable is not defined in the present mode, or only care if you actually
  destruct the variable? Doing the former for now.}

The $\ereveal{Q}{e}$ construct takes as its argument something of type
$\sectyp{\omega}{\sshare{\psi}}{P}$ and produces a value of type
$\sectyp{\omega}{\ssec}{Q}$. That is, it forces the secure computation
(which we are thinking of as a thunk) to produce a result, and reveals
that result to the specified principals $Q$.

We have several auxiliary judgments, shown in
Figure~\ref{fig:aux}. The judgment $m \vdash P$ says that principals
$P$ are \emph{present} when executing in mode $m$. $m \vdash P$ holds
when $m = \top$ or $m = Q$ and $P \subseteq Q$. \mwh{This is
  oversimplified --- need to move to Wysteria's set-generic dependent
  types.}

\mwh{For shares -- what does ``isFlat'' mean? I'm not sure if it just means
int, float, etc. or it also means a tuple of those things. I'm not
sure why a tuple is useful, since it's clear from the program text
which element of the tuple you are accessing.}

\paragraph*{Secure blocks}

\paragraph*{Par blocks}

The type of $\epar{P}{e} $ is $\sectyp{\omega}{\isec}{P}$
type. This is because $e$ is executed independently by each principal
$p \in P$. There are constraints on the type of $e$. Off the top of my
head:
\begin{itemize}
\item All types with visibility $P$ are allowed. We can use subtyping
  (to $Q \subset P$) as needed.
  \item We can insert nested Par blocks, with a subset of principals,
    I think. However, their results will only be visible to subsequent
    par blocks with the same principal set (not the parent).
  \item Conditional execution $\econd{e_1}{e_2}{e_3}$ when $e_1$ could
    contain an $\isec$ needs to be limited. The issue will be if $e_2$
    has a secure computation inside it; not all parties $P$ will
    necessarily reach this point, because their values may differ in
    $e_1$. Remedies:
    \begin{itemize}
      \item Only allow conditionals in Par blocks when $P$ is a singleton, or
      \item Forbid computations on shares inside the branches of a
        conditional when the guard involves an \isec.
      \end{itemize}
\end{itemize}

The auxiliary judgment $\canshare{\tau}$, which says that a type
$\tau$ can be made into a secret share. Only nats and products of nats
can be secret-shared; lists, sum types, and functions cannot be, as
doing so would reveal information about them (e.g., their size).


\begin{figure}
\[\begin{array}{c}

    \canshare{\tnat}
    \qquad

    \inferrule
    {
    \canshare{\tau_1}\\ \canshare{\tau_2}
    }
    {
    \canshare{\tprod{\tau_1}{\tau_2}}
    }
    \qquad
    
    \inferrule*[lab=S-PrinSub]
    {
    Q \subseteq P\\
    \phi = \ssec \vee \phi = \isec
    }
    {
    \issub{\sectyp{\omega}{\phi}{P}}{\sectyp{\omega}{\phi}{Q}}
    }
    \\ \\


    
\end{array}
\]
\caption{Auxiliary Judgments}
\label{fig:aux}
\end{figure}




\paragraph{Subtyping}

We have subtyping $\issub{\tau_1}{\tau_2}$, which indicates when
$\tau_1$ can be used as $\tau_2$. The rules are in
Figure~\ref{fig:subtyping}. Typing only permits operations among
values of exactly the same type $\tau$. Rule PrinSub says an \ssec $P$
can be coerced to \ssec $Q$ when $Q \subseteq P$. That is, a shared
value visible to a larger principal set can be viewed as visible to a
smaller one. The same is true of \isec. There is no subtyping
arrangement for \sshare---all parties have to be present, and
additional parties are not allowed. This is because those parties
represent distributed secret shares of a precise number.


\section{Encoding in Wysteria}

I'm starting to wonder if our idea from way back --- Wysteria with
small extensions --- is all we really needed, where the current approach
to PSL is just this system with some inference added in. Those
extensions are:
\begin{itemize}
\item that you can create shares for a subset of parties in a secure
  block. Thus, for Alice to create shares for Bob and Charlie, all
  three join the secure block, and then create shares from Alice's
  value. We also need to be able to reconstitute shares for a subset
  of parties; i.e., if there are shares between A and B, we can make a
  secure block with A, B, and C, and reconstitute the shares within
  it. 
\item some kind of seal/unseal primitives for making $\ssec$ values, as
in Wys$^\star$, so as to avoid the weird $\Gamma$ in the Wysteria
paper. I think this also has the benefit that you can use subtyping to
make a sealed value less visible. But maybe this should be a wire
bundle instead, so the runtime semantics is clear?
\mwh{Have a look at the markdown I wrote a while back}
\end{itemize}

Then PSL is basically inference and encoding down to this.

\paragraph{Share primitive} In PSL you can write \texttt{share $P$
  $e$}, which means to secret-share $e$ among principals $P$. It might
be that $e$ is owned by some principal $p$ not in $P$. In our encoding
we do this via \texttt{sec $\{p\}\cup{P}$ (makesh $P$ $e$)}.

\paragraph{Secure computation} In PSL everything you compute on
securely is conceptually a share, and only by explicitly revealing a
share do you get a value. The default in Wysteria is the
opposite. Thus the encoding of $e_1 \oplus e_2$ in PSL, where $e_1$
and $e_2$ are both share types over the same principal $P$, would be
\texttt{sec $P$ (makesh $P$ ((combsh $e_1$) $\oplus$ (combsh
  $e_2$)))}. The encoding for PSL's \texttt{reveal $P$ $e$} would be
\texttt{sec $R$ (let x = combsh $e$ in wire $P$ x)} where $e$ is
a share over principals $Q$ and $Q \cup P = R$. 

\paragraph{SIMD computations resulting in principal mapped values} In
the euclid example, we have something like
\begin{verbatim}
  let ab = {par:A,B} read int "euclid.txt"
\end{verbatim}
The idea is that \verb+ab+ is a $\isec$ value for $A$ and $B$. In
normal Wysteria you can only call \texttt{read} in a par block with a
single principal, but we can encode something like the above using
\texttt{wapp}. Basically \texttt{par $P$ e} in PSL is \texttt{wapp $P$
  ($\lambda$ x. par x $e$)} where \texttt{x} will be bound to the principal
executing $e$. It's not mentioned in the Wysteria paper, but I suspect
that the lambda term should executing $e$ in par mode anyway, so I'm
not sure why we have to specify it.

\end{document}