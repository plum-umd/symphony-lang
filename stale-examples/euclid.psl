-- NOTES:
-- - We can totally ditch monadic syntax; I'm by no means attached to it
-- - ℕ{bcir:A,B} is a boolean circuit which when executed in a protocol will
--   return a natural number
-- - ℕ{par:A,B} is a wire bundle with values for A and B
-- - recursive functions are defined with rλ and the first parameter is a
--   binding to "self"
-- - It is still unclear to me when it is necessary or not to explicitly create
--   boundaries around circuit construction and operations; this is currently
--   written with keyword `circuit`

principal A
principal B

def mod : ℕ{bcir:A,B} → ℕ{bcir:A,B} → MPC{A,B} ℕ{bcir:A,B}
def mod = rλ rec a → λ b →
  do stop ← mpc{gmw:A,B} circuit a < b;
  if stop
  then return a
  else rec (circuit a - b) b

-- OR 
-- (can we get away with type-directed selection of circuit operations?)

def mod′ : ℕ{bcir:A,B} → ℕ{bcir:A,B} → MPC{A,B} ℕ{bcir:A,B}
def mod′ = rλ rec a → λ b →
  do stop ← mpc{gmw:A,B} a < b;
  if stop
  then return a
  else rec (a - b) b

def mod′ : ℕ{bcir:A,B} → ℕ{bcir:A,B} → MPC{A,B} ℕ{bcir:A,B}
def mod′ = rλ rec a → λ b →
  do stop ← mpc{gmw:A,B} ⌊a < b⌋;
  if stop
  then return ⌊a⌋
  else rec ⌊a - b⌋ ⌊b⌋

def mod′ : ℕ{bcir:A,B} → ℕ{bcir:A,B} → MPC{A,B} ℕ{bcir:A,B}
def mod′ = rλ rec a → λ b →
  do stop ← mpc{gmw:A,B} cir a < b;
  if stop
  then return cir a
  else rec (cir a - b) (cir b)


def gcd : ℕ{bcir:A,B} → ℕ{bcir:A,B} → MPC{A,B} ℕ{bcir:A,B}
def gcd = rλ rec a → λ b →
  do stop ← mpc{gmw:A,B} circuit b ≡ 0;
  if stop
  then return a
  else rec b (mod a b)

gcd-mpc : ℕ{par:A,B} → MPC{A,B} ℕ{sec:A,B}
gcd-mpc = λ ⟨a@A,b@B⟩ → mpc{gmw:A,B} gcd a b

-- OR 
-- (different notation for pulling A and B values out of a wire bundle)

gcd-mpc′ : ℕ{par:A,B} → MPC{A,B} ℕ{sec:A,B}
gcd-mpc′ = λ ab → mpc{gmw:A,B} gcd ab.A ab.B
