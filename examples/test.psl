principal A
principal B


-- given a swap function for type a, build swap for bool * a
-- def tag-swap : (bool{P} -> a -> a -> a) 
--             -> (bool{P} -> bool{P} * a -> bool{P} * a -> bool{P} * a)
def tag-swap swap =
  fun b x y ->
    let tx, x' = x
    let ty, y' = y
    in (b ? tx >< ty), (b ? x' >< y')


-- def init-content : nat -> a -> array{P} a
def content-init default n =
  if n == 0
  then []
  else
    (false, default) :: content-init default (n - 1)


-- def vector-init : a -> (bool{P} -> a -> a -> a) -> nat -> vector{P} a
def vec-init default swap n =
  let tswap = tag-swap swap
  in
    default, tswap, content-init default n


def content-write swap n y xs =
  case xs
  { [] -> []
  ; cell::xs' ->
    let (tag, x) = cell
    in
      swap ((n == 0) && tag) (tag, y) cell
        :: content-write swap (n - 1) y xs'
  }


-- def vector : nat{P} -> a -> vector{P} a -> vector{P} a
def vec-write n y vec =
  let default, swap, xs = vec
  in default, swap, (content-write swap n y xs)

def not b = b ? false >< true

def content-push swap flag y xs =
  case xs
  { [] -> []
  ; cell::xs' ->
    let (tag, x) = cell
    in
      swap (not tag && flag) (true, y) cell
        :: content-push swap tag y xs'
  }


def vec-push x vec =
  let default, swap, xs = vec
  in default, swap, (content-push swap true x xs)


def resize-content n xs =
  case xs
  { [] -> []
  ; cell::xs ->
    let (tag, x) = cell
    in
      (n > 0, x) :: resize-content (n - 1) xs
  }


-- def resize : nat{P} -> vector{P} a -> vector{P} a
def vec-resize n vec =
  let default, swap, xs = vec
  in default, swap, (resize-content n xs)


def content-size xs =
  case xs
  { [] -> 0
  ; cell::xs ->
    let (tag, x) = cell
    let diff = tag ? 1 >< 0
    in
      diff + content-size xs
  }


def vec-size vec =
  let default, swap, xs = vec
  in content-size xs


def content-push swap flag y xs =
  case xs
  { [] -> []
  ; cell::xs' ->
    let (tag, x) = cell
    in
      swap (not tag && flag) (true, y) cell
        :: content-push swap tag y xs'
  }


def content-read default swap n xs =
  case xs
  { [] -> false, default
  ; cell::xs' ->
    let tl = content-read default swap (n - 1) xs'
    in swap (n == 0) cell tl
  }


def vec-read n vec =
  let default, swap, xs = vec
  in content-read default swap n xs


def content-swap swap b xs ys =
  case xs, ys
  { [], [] -> []
  ; x::xs, y::ys -> swap b x y :: content-swap swap b xs ys
  }


def vec-swap b vecx vecy =
  let default, swap, xs = vecx
  let _, _, ys = vecy
  in default, swap, content-swap swap b xs ys


def int-vec-init = vec-init 0 (fun b x y -> b ? x >< y)


def main () =
  let t = vec-push 245 (
    vec-push 15 (
      vec-write 1 10 (
        vec-resize 2 (int-vec-init 5))))
  let xs = int-vec-init 5
  in vec-swap false t xs
