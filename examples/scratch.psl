principal A
principal B

â„¤{ssec:A,B} -- shared secret between A and B
â„¤{psec:A,B} -- private secret for A and B
â„¤{cir:ashare:A,B} -- a circuit with inputs from A and B which are additive shared
â„¤{acir:sshare:A,B} -- an arithmetic circuit with inputs from A and B which are shamir shared

def op : â„¤{joint:A} â†’ â„¤{joint:B} â†’ â„¤{pcir:A,B}
def op = Î» (x : â„¤{joint:A}) â†’ Î» y â†’ circuit( (x : â„¤) + y )

def op : â„¤{joint:A} â†’ â„¤{joint:B} â†’ â„¤{pcir:A,B}
def op = Î» (x : â„¤{joint:A}) â†’ Î» y â†’ (circuit x : â„¤{ncir:A})) + (circuit y : â„¤{ncir:B})) : â„¤{acir:A,B}

def contrived-exampleâ‚ : â„¤{joint:A} â†’ â„¤{ncir:A,B} â†’ â„¤{acir:A,B}
def contrived-exampleâ‚ = Î» x â†’ Î» y â†’ ~x + ~y

def contrived-exampleâ‚‚ : â„¤{joint:A} â†’ â„¤{joint:A,B} â†’ â„¤{acir:A,B}
def contrived-exampleâ‚‚ = Î» x â†’ Î» y â†’ --  ~x + y
  x + y

def example-two-prv : â„¤{prv:A,B} â†’ â„¤{prv:A,B}
def example-two-prv = Î» x â†’
  let z : â„¤{prv:A,B}
  let z = prv{A,B} { x + x }
  in z

def example-two-jnt : â„¤{jnt:A,B} â†’ â„¤{jnt:A,B}
def example-two-jnt = Î» x â†’
  let z : â„¤{jnt:A,B}
  let z = jnt{A,B} { x + x }
  in z

def example-two-enc : â„¤{prv:A} â†’ â„¤{prv:B} â†’ â„¤{enc:A,B}
def example-two-enc = Î» x â†’ Î» y â†’ 
  let xS : â„¤{enc:A,B}
  let xS = ~x
  let yS : â„¤{enc:A,B}
  let yS = share{A,B} { y + y }
  let c = ~xS + ~yS
  let wrong : (enc{A,B} â„¤){jnt:A,B}
  let wrong = âŸ¨A â‡’ xS.A , B â‡’ yS.BâŸ©
  let cx : (enc{A,B} â„¤){jnt:C,D}
  let cx = send xS to C and D
  (mpc{bgw:A,B} reveal ~xS + ~yS : MPC{A,B} â„¤{jnt:A,B}

(mpc{yao:A,B} cira) : MPC{A,B} â„¤{joint:A,B}

def blah : â„• â†’ â„•
def blah = Î» x â†’ x + 1

  âŠ¤
 /   \
bcir acir ccir  Ã—     â„˜{ashare,yshare,sshare}
 \   /
  âŠ¥

def isort : list â„¤{prv:A,B} â†’ list â„¤{ucir:A,B}

ucir = bcir + acir + â‰¤ stuff and supports â„¤ and ğ”¹

bcir = âŠ•, âˆ§, âˆ¨, etc. and supports ğ”¹

acir = +,Ã— and supports â„¤ types

ccir = â‰¤, â‰¡, etc. on â„¤

âŠ¥ = ncir

access modality: prv, jnt, enc (like jnt but encrypted, e.g., secret shared)
representation modality: acir, bcir, ncir, etc. (e.g., operators like + overloaded)

def blah : â„¤{priv:A,B} â†’ â„¤{acir:A,B}
def blah = Î» x â†’
  x : â„¤{priv:A,B}

  x.A : â„¤{joint:A}
  x.B

  x.A
  x[A]
  x@A

  a : â„¤{joint:A}  
  b : â„¤{joint:B}

  {A â‰” a, B â‰” b}

  { fst: x
  , snd: y 
  }
  
  {a@A, b@B}
  {A: a, B: b}
  {A â‡’ a, B â‡’ b}

  { A : a }


def mainâ‚ : â„¤{joint:A} â†’ â„¤{joint:B} â†’ MPC{A,B âª« A,B} ğ”¹{sshare:A,B}
def mainâ‚ = Î» x â†’ Î» y â†’ mpc{bgw:A,B} op x y

def mainâ‚‚ : â„¤{joint:A} â†’ â„¤{joint:B} â†’ MPC{A,B âª« A,B} ğ”¹{ashare:A,B}
def mainâ‚‚ = Î» x â†’ Î» y â†’ mpc{bgw:A,B} op x y

def mainâ‚ƒ : â„¤{joint:A} â†’ â„¤{joint:B} â†’ MPC{A,B âª« A,B} ğ”¹{yshare:A,B}
def mainâ‚ƒ = Î» x â†’ Î» y â†’ mpc{yao:A,B} op x y

