-- m : user parameter: number of constraint parties
def m : nat
def m = 2n

-- n : user parameter: dimension of the constraint system
def n : nat
def n = 2n

-- Ctr: parties that bring the constraints
principal Ctr[2]

-- party that provides the cost vector:
principal Cost

-- party that gets the output:
principal Out

-- reals: IEEE64
-- def real : type
-- def real = flt[64]
-- PSL: support type definitions

-- ctr: the type of constraints. An independent secret vector.
-- def ctr : type
-- def ctr = list (real{ isec : Ctr })

-- costs: the type of cost vectors:
-- def costs : type
-- def costs = list (real{ ssec : Cost })

-- comp_shr: a real secret-shared between all compute parties
-- def comp_shr : type
-- def comp_shr = real{ spdz : Ctr, Cost }

-- def comp_shr_bool : type
-- def comp_shr_bool = bool{ spdz: Ctr, Cost }

-- out_sec: a secret known only to the output party
-- def out_sec : type
-- def out_sec = real{ ssec : Out }

-- public_bool: booleans known to everyone
-- def public_bool : type
-- def public_bool = bool{ ssec: Ctr, Cost, Out }

-- public_nat: nats known to everyone
-- def public_nat : type 
-- def public_nat = nat{ ssec: Ctr, Cost, Out }

-- point: a point the comp_shrensional space of a constraint
-- def point : type 
-- def point = list comp_shr

-- secretMat: a matrix of additive shares of reals
-- def secretMat : type
-- def secretMat = list point

-- ltMat: a lower-trignular matrix of additive shares of reals in
-- row-major order
-- def ltMat : type
-- def ltMat = list ((list comp_shr) * comp_shr)

-- ltMat: a lower-triangular matrix of additive shares in column-major
-- order
-- def colLtMat : type
-- def colLtMat = list (comp_shr * (list comp_shr))

-- err msg: throw an error message
def err msg = msg + 0

-- library functions for functions:

def compose : (t0 -> t1) -> (t1 -> t2) -> (t0 -> t2)
def compose f g x = g (f x)

def const : t -> u -> t
def const x y = x

def curry : (a * b -> c) -> (a -> b -> c)
def curry f x y = f (x, y)

def id : t -> t
def id x = x

def swap : (a -> b -> c) -> (b -> a -> c)
def swap f y x = f x y

def uncurry : (a -> b -> c) -> (a * b -> c)
def uncurry f (a, b) = f a b

-- shr_spdz: a first-order operation that shares over SPDZ
def shr_spdz P x = share{ spdz : P } x

-- shr_w_comp: 
def shr_w_comp = shr_spdz set(Ctr,Cost)

-- library for types with equality:

-- eq: non-infix equality test
def eq x y = x == y

-- library for numeric types:

-- plus: non-infix sum
def plus m n = m + n

-- minus: non-infix subtraction
def minus m n = m - n

-- mult: non-infix multiplication 
def mult m n = m * n

-- exp: non-infix exponentiation
def exp m n = m ^ n

-- square: multiple a number with itself:
def square a = a * a

-- library for nats:

-- inc n: increment of nat n
def inc : nat -> nat
def inc = plus 1n

-- dec n: decrement of nat n
def dec : nat -> nat
def dec n = n - 1n

-- elim_nats: form for eliminating (folding over) nats
def elim_nats : nat -> t -> (t -> t) -> t
def elim_nats m z s = 
  if m ≡ 0n then z
  else s (elim_nats (dec m) z s)

-- elim_natsl: analog of fold right, for nats
def eliml_nat : nat -> t -> (t -> t) -> t
def eliml_nat n z s = 
  (elim_nats n id (compose s)) z

-- nat_log: logarithm over nats. Diverges at 0n.
def nat_log : nat -> nat -> nat
def nat_log b n =
  if n == 1n then 0n
  else inc (nat_log b (n / b))

-- library functions for lists:

-- cons: non-infix list cons
def cons : t -> list t -> list t
def cons x l = x :: l

-- const_vec t a n: a vector of constant a of size n
def const_vec : t -> nat -> list t
def const_vec c n = elim_nats n [ ] (cons c)

-- foldr: right fold, the list eliminator
def foldr : list t -> acc -> (t -> acc -> acc) -> acc
def foldr l acc f = case l
  { [ ] -> acc
  ; x :: l' -> f x (foldr l' acc f)
  } 

def filter test l = foldr l
  [ ]
  (fun x rest -> if test x then x :: rest else rest)

-- foldr_tl: right fold with access to the tail of the list
def foldr_tl : list t -> acc -> (t -> list t -> acc -> acc) -> acc
def foldr_tl l i f =
  let (_, a) = foldr l ([ ], i) (fun x (l', b) -> (x :: l', f x l' b)) in
  a

def decons_ls : list t -> u -> (t -> list t -> u) -> u
def decons_ls l a0 f = foldr_tl l a0 (fun x ls -> const (f x ls))
  
-- foldl: left fold
def foldl : list t -> acc -> (t -> acc -> acc) -> acc
def foldl l acc0 f = (foldr l id (fun x acc -> compose acc (f x))) acc0

def concat : list t -> list t -> list t
def concat l0 l1 = foldr l0 l1 cons

def len : list t -> nat
def len l = foldr l 0n (const inc)

-- map: map operation for the list functor
def map : (t -> u) -> list t -> list u
def map f l = foldr l [ ] (compose f cons)

-- rev_ls l: the reverse of list l
def rev_ls : list t -> list t
def rev_ls l = foldl l [ ] cons

def snoc : t -> list t -> list t
def snoc x l = concat l [ x ]

-- zip_lists pt0 pt1: the zip of points p0 and p1
def zip_lists : list t -> list u -> list (t * u)
def zip_lists l0 l1 =
  (foldr l0
    (const [ ])
    (fun x z0 l -> decons_ls l
       [ ]
       (fun y l' -> (x, y) :: z0 l') ) )
    l1

def zip_map : (t -> u -> v) -> list t -> list u -> list v
def zip_map f l0 l1 = map (uncurry f) (zip_lists l0 l1)

-- numeric operations:

-- prod: the product over a list of numerics
def prod v one = foldr v one mult

-- sum: the sum over a list of numerics
def sum v z = foldr v z plus

-- nzProd z one l: the product of all non-zero entries in list l:
def nzProd z one l = prod
  (filter (fun x -> !(z == x)) l)
  one 

-- pt_diff: subtract one point from another
def vec_diff : point -> point -> point
def vec_diff v0 v1 = zip_map minus v0 v1 

-- vec_div: divide a vector of reals by a constant
def vec_div : real -> list real -> list real
def vec_div a = map (fun x -> x / a)

-- dot_prod: take the dot product of two points
def dot_prod z p0 p1 = sum (zip_map mult p0 p1) z

-- l2norm z v: the L2 norm of a vector of numerics with zero element z
def l2norm : point -> comp_shr
def l2norm z v = sqrt (sum (map square v) z)

-- zeros_vec: a vector of floating-point zeroes
def zeros_vec : nat -> list real
def zeros_vec = const_vec 0.0

-- onesVec: a vector of real ones
def onesVec : nat -> list real
def onesVec = const_vec 1.0

-- transpose: shift matrix between row major and column major order
def transpose : list (list t) -> list (list t)
def transpose m = foldr m
  (const_vec [ ] (decons_ls m 0n (compose len const)) )
  (zip_map cons)

-- mult_mat_vec : multiply a matrix of secrets and a point
def mult_mat_vec : num -> matrix -> point -> point
def mult_mat_vec z m pt = map (dot_prod z pt) m

-- mult_mat: product of row matrix and column matrix
def mult_mat z m0 m1 = map (fun v -> map (dot_prod z v) m1) m0 

-- and: non-infix Boolean conjunction
def and b0 b1 = b0 && b1

def all_true : list bool -> bool
def all_true l = foldr l true and

def max : comp_shr -> comp_shr -> comp_shr_bool
def max m n = if m <= n then n else m

-- is_zero_vec v: test if v is the vector of shares of 0
def is_const_vec : point -> public_bool
def is_const_vec c v = all_true (map (eq c) v)

-- sqMat: square matrix: a matrix with explicit diagonal elements
-- def sqMat : type
-- def sqMat = list (point * comp_shr * point)

-- part_ith a i l: l partitioned into the first i - elements, ith elt,
-- and the everything after element i. a is a default elt, which
-- should never be used.
def part_ith : nat -> t -> list t -> (list t) * t * (list t)
def part_ith a i l =
  let (first_i, rem) =
    eliml_nat i
      ([ ], l)
      (fun (front, tl) -> decons_ls tl
        (front, tl) -- shouldn't happen
        (fun hd tl' -> (hd :: front, tl)) ) in
  let (ith, tl) = decons_ls rem
    (a, rem) -- shoudln't happen
    (fun b rem' -> (b, rem')) in
  (first_i, ith, tl)

-- squareMat m: matrix m coerced into a square matrix
def squareMat m =
  let (_, m') = foldl m
    (0n, [ ])
    (fun rv (i, acc) -> (inc i, (part_ith (shr_w_comp 0.0) i rv) :: acc)) in
  rev_ls m'

-- cholesky m: the Cholesky decomposition of matrix m, in column-major
-- order, computed using the Cholesky-Crout algorithm
def cholesky : sqMat -> ltMat
def cholesky z m =
  let (m', _) = foldl m -- fold over each column in the matrix,
    ([ ], [ ])
    (fun (top, diag, bot) (tri, base) ->
      -- deconstruct the maintained base box 
      let (jth_row', base') = decons_ls base
        ([ ], const_vec [ ] (len bot))
        (fun x tl -> (x, tl)) in
      -- diag': the diagonal elt of the solution
      let diag' = sqrt (diag - (dot_prod z jth_row' jth_row')) in
      -- tri': the upper triangle, extended
      let tri' = snoc (diag', [ ])
        (map (fun ((d, tl), jth_elt) -> (d, snoc jth_elt tl))
          (zip_lists tri jth_row')) in
      -- the base box, extended
      let base'' = map 
        (fun (rv', elt) ->
          snoc ((diag - (dot_prod z rv' jth_row')) / diag') rv')
        (zip_lists base' bot) in
      (tri', base'')) in
  m'

-- col_lt_to_row m: LT matrix m in col-major form, converted to
-- row-major form
def col_lt_to_row m = foldr m
  [ ]
  (fun (hd, bot) acc -> ([ ], hd) ::
    (zip_map (fun b (ls, rt) -> (b :: ls, rt)) bot acc) )

-- lt_inverse m: the inverse of LT matrix m:
def lt_inverse : ltMat -> ltMat
def lt_inverse z l =
  let add_inv = fun x -> z - x in
  foldr_tl l -- fold over the LT matrix
    [ ]
    (fun (d, cv) tl -> snoc
      -- fold over the tail of the current column and the rest of the matrix
      (foldl (zip_lists cv (col_lt_to_row tl))
        (d, [ ])
        (fun (x, (rv, y)) (hd', tl') ->
          let dprod = dot_prod z (snoc y rv) (hd' :: tl') in
          (hd', snoc ((add_inv dprod) / y) tl') ) ) )

-- lt_lift d l: LT matrix l, lifted into a matrix by padding copies of
-- default element d
def lt_lift : t -> list (t * (list t)) -> list (list t)
def lt_lift d l =
  let (_, m) = foldl l
    ([ ], [ ])
    (fun (hd, tl) (buf, m) -> (d :: buf, (concat buf (hd :: tl)) :: m) ) in
  rev_ls m

-- inverse z m: the inverse matrix of m over numeric type with zero
-- element z
def inverse : num -> matrix -> matrix
def inverse z m =
  let l_inv = lt_lift z
    (lt_inverse z (cholesky z (squareMat (transpose m)))) in
  mult_mat z (transpose l_inv) l_inv

-- mult_diag_vec d v: product of diagonal matrix over vector d, and v
def mult_diag_vec : point -> point -> point
def mult_diag_vec = zip_map mult 

def pdecons a f xy = case xy
  { ⟪⟫ → a
  ; ⟪Q.x⟫⧺xy′ → f Q x 
  }

def pfold : ∀ A:☆,P:ℙ. A → ((Q:ℙ | Q⊆P) → ℤ{Q} → A → A) → ℤ{isec:P} →{sec:P} A
def pfold i f xy = case xy
  { ⟪⟫ → i
  ; ⟪Q.x⟫⧺xy′ → f Q x (pfold i f xy′)
  }

def nOnes : list flt
def nOnes = onesVec n 

def reveal_ls P l = 
  case (reveal{ P } l)
  { [ ] -> [ ]
  ; x :: l' -> x :: (reveal_ls P l') 
  }

-- karmarkar_iter: an iteration of Karmarkar's algorithm
def karmarkar_iter : ctr -> cost -> point -> point
def karmarkar_iter shr0 a cost pt =
  -- vector and matrix operations instantiated to SPDZ
  let invert_spdz = inverse shr0 in
  let mult_spdz_mats = mult_mat shr0 in
  let mult_spdz_mat_vec = mult_mat_vec shr0 in

  let unit_cp =
    -- project c onto b's nullspace
    let cp =
      -- c': product of diagonal of point and cost vector
      let c' = mult_diag_vec pt (map shr_w_comp cost) in
      let b = pfold 
        [ nOnes ]
        (fun Q ctr -> cons
          (mult_diag_vec pt
            (map shr_w_comp (reveal_ls set(Cost,Ctr) ctr)) ) )
        a in
      vec_diff
        c'
        (mult_spdz_mat_vec (transpose b)
          (mult_spdz_mat_vec (invert_spdz (mult_spdz_mats b b))
            (mult_spdz_mat_vec b c') ) ) in

    -- test if the projection is the 0 vector:
    let is_const = is_const_vec shr0 cp in
    zip_map (fun c n -> is_const ? c ◇ n)
      (const_vec shr0 n) (vec_div (l2norm shr0 cp) cp)

  -- take a step of 1/3 n in the direction of cp
  let b' = vec_diff
    (map shr_w_comp (vec_div (to_flt n) nOnes))
    (vec_div (shr_w_comp (to_flt (3n * n))) unit_cp) in

  let db' = mult_diag_vec pt b' in
  vec_div (dot_prod shr0 (map shr_w_comp nOnes) db') db'

def ceil_fn f f_inv n =
  let n' = f n in
  n' + (if n == f_inv n' then 0n else 1n)

def log_2_ceil = ceil_fn (nat_log 2n) (exp 2n)

-- Karmarkar's algorithm, main loop:

def karmarkar_loop : ctr -> costs -> point
def karmarkar_loop a cost =
  -- bound: upper bound on the required number of iterations, based on
  -- product of non-zero constraint and cost coeffs:
  let shr0 = share{ spdz : Ctr, Cost } 0.0 in
  let nzFltProd = nzProd 0.0 1.0 in
  let bound = 
        (12n * n *
         ((inc m) * n +
          (log_2_ceil (abs_val (ceil (reveal{ Cost, Ctr } ( 
           (pfold
             -- multiply non-zero cost coeffs,
             (shr_w_comp ({ par : Cost } nzFltProd cost))
             -- multiply non-zero constraint coeffs,
             (fun Q pnzs -> mult (shr_w_comp pnzs))
             ({ Ctr } nzFltProd a) )
          ) ) ) ) ) +
         n * (log_2_ceil n) ) ) in
  let bound = 8n in
  (elim_nats bound
    id
    (compose (karmarkar_iter shr0 a cost)) )
    (vec_div (to_flt n) nOnes)

-- read_vec (): reads a vector of n input floats from a fixed filename
def read_vec : unit -> list flt
def read_vec () = read (list flt) "in.txt"
  
-- main:
def main : unit ->{ inp : Ctr, Cost; rev : Out } (list out_sec)
def main () =
  -- Ctr and Cost send the data in the list to Out:
  let soln = { par : Ctr, Cost, Out } (map
    (fun x -> reveal{ Out } x)
    -- Ctr and Cost reveal the list structure of the point to Out:
    (reveal_ls set(Ctr,Cost,Out)
      -- Ctr and Cost compute the solution point:
      ({ par : Ctr, Cost } karmarkar_loop
        -- Ctr reads inputs constraints,
        ({ par : Ctr } read_vec ())
        -- Cost shares the list structure of the cost vector with Ctr,
        ({ par : Ctr, Cost } pdecons 
          [ ]
          (fun Q c -> reveal_ls set(Cost,Ctr) (reveal{ Cost, Ctr } c))
          -- Cost reads the cost vector,
          ({ par : Cost } read_vec ())
        ) ) ) ) in
  -- Ctr and Cost forget the structure of the solution
  { par : Out } reveal_ls set(Out) soln
