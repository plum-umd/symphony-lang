-- m : number of constraint parties
def m : nat
def m = 2n

-- Ctr: parties that bring the constraints
principal Ctr[2]

-- party that provides the cost vector:
principal Cost

-- party that gets the output:
principal Out

-- reals: IEEE64
-- def real : type
-- def real = flt[64]
-- PSL: support type definitions

-- PSL: BEGIN ops that need to be supported

def spdz_sqrt : real{ spdz : Ctr, Cost } -> real{ spdz : Ctr, Cost }

-- PSL: END ops that need to be supported

-- ctr: the type of constraints. An independent secret vector.
-- def ctr : type
-- def ctr = list (real{ isec : Ctr })

-- costs: the type of cost vectors:
-- def costs : type
-- def costs = list (real{ ssec : Cost })

-- comp_shr: a real secret-shared between all compute parties
-- def comp_shr : type
-- def comp_shr = real{ spdz : Ctr, Cost }

-- def comp_shr_bool : type
-- def comp_shr_bool = bool{ spdz: Ctr, Cost }

-- out_sec: a secret known only to the output party
-- def out_sec : type
-- def out_sec = real{ ssec : Out }

-- shr_w_comp: 
def shr_w_comp : real{ ssec : Cost } -> comp_shr
def shr_w_comp x = share{ spdz : Ctr, Cost } x

-- shr_pub_w_comp: make shares of a public real
def shr_pub_w_comp : real -> comp_shr
def shr_pub_w_comp x = share{ spdz : Ctr, Cost } x

-- public_bool: booleans known to everyone
-- def public_bool : type
-- def public_bool = bool{ ssec: Ctr, Cost, Out }

-- public_nat: nats known to everyone
-- def public_nat : type 
-- def public_nat = nat{ ssec: Ctr, Cost, Out }

-- release_nat: publicly reveal a nat shared between all compute
-- parties
def release_nat : comp_shr_nat -> public_nat
def release_nat n = reveal{ Ctr, Cost, Out } n

-- point: a point the comp_shrensional space of a constraint
-- def point : type 
-- def point = list comp_shr

-- secretMat: a matrix of additive shares of reals
-- def secretMat : type
-- def secretMat = list point

-- ltMat: a lower-trignular matrix of additive shares of reals in
-- row-major order
-- def ltMat : type
-- def ltMat = list ((list comp_shr) * comp_shr)

-- ltMat: a lower-triangular matrix of additive shares in column-major
-- order
-- def colLtMat : type
-- def colLtMat = list (comp_shr * (list comp_shr))

-- library functions for types with equality:

def eq x y = x == y

-- library functions for numeric types

-- plus: non-infix sum
def plus m n = m + n

-- minus: non-infix substraction
def minus m n = m - n

-- inc n: increment of n
def inc : nat -> nat
def inc = plus 1n

-- dec n: decrement of n
def dec : nat -> nat
def dec n = n - 1n

-- mult: infix multiplication of nats
def mult m n = m * n

-- square: multiple a number with itself:
def square a = a * a

-- elim_nats: form for eliminating (folding over) nats
def elim_nats : nat -> t -> (t -> t) -> t
def elim_nats m z s = 
  if m ≡ 0n then z
  else s (elim_nats (dec m) z s)

-- elim_natsl: analog of fold right, for nats
def elim_natsl : nat -> t -> (t -> t) -> t
def eliml_natl n z s = 
  (elim_nats n id (compose s)) z

-- library functions for functions:

def compose : (t0 -> t1) -> (t1 -> t2) -> (t0 -> t2)
def compose f g x = g (f x)

def const : t -> u -> t
def const x y = x

def curry : (a * b -> c) -> (a -> b -> c)
def curry f x y = f (a, b)

def id : t -> t
def id x = x

def uncurry : (a -> b -> c) -> (a * b -> c)
def uncurry f (a, b) = f a b

-- library functions for lists:

-- cons: non-infix list cons
def cons : t -> list t -> list t
def cons x l = x :: l

-- const_vec t a n: a vector of constant a of size n
def const_vec : t -> nat -> list t
def const_vec c n = elim_nats n [ ] (cons c)

-- foldr: right fold, the list eliminator
def foldr : list t -> acc -> (t -> acc -> acc) -> acc
def foldr l acc f = case l
{ [ ] -> acc
; x :: l' -> f x (foldr l' acc f)
}

-- foldr_tl: right fold with access to the tail of the list
def foldr_tl : list t -> acc -> (t -> list t -> acc -> acc) -> acc
def foldr_tl l i f =
  let (_, a) = foldr l ([ ], i) (fun x (l', b) -> (x :: l', f x l' b)) in
  a

def decons_ls : list t -> u -> (t -> list t -> u) -> u
def decons_ls l a0 f = foldr_tl l a0 (fun x ls -> const (f x ls))
  
-- foldl: left fold
def foldl : list t -> acc -> (t -> acc -> acc) -> acc
def foldl l acc f = (foldr l id (fun x -> compose (f x))) acc

def concat : list t -> list t -> list t
def concat l0 l1 = foldr l0 l1 cons

def len : list t -> nat
def len l = foldr l 0 (fun x -> inc)

-- map: map operation for the list functor
def map : (t -> u) -> list t -> list u
def map f l = foldr l [ ] (compose f cons)

-- rev l: the reverse of list l
def rev_ls : list t -> list t
def rev_ls l = foldl l [ ] cons

def snoc : t -> list t -> list t
def snoc x l = foldr l [ x ] cons

-- zip_lists pt0 pt1: the zip of points p0 and p1
def zip_lists : list t -> list u -> list (t * u)
def zip_lists l0 l1 =
  let zip0 = foldr l0
    (const [ ])
    (fun x z0 l -> decons_ls l
       [ ]
       (fun y l' -> (x, y) :: z0 l') ) in
  zip0 l1

def zip_map : list t -> list u -> (t -> u -> v) -> list v
def zip_map l0 l1 f = map (uncurry f) (zip_lists l0 l1)

-- point_div x pt: divide each entry in pt by x
def point_div : comp_shr -> point -> point
def point_div x = map (fun a -> a / x) 

-- vec_div: divide a vector of reals by a constant
def vec_div : real -> list real -> list real
def vec_div a = map (fun x -> x / a)

-- nzProd a: the product of all non-zero entries in a vector:
def nzProd : list (real{ ssec : p }) -> real{ ssec : p }
def nzProd l = foldr l
  (shr_w_comp 1.0)
  (fun x -> if x == 0.0 then id else mult x)

-- pt_diff: subtract one point from another
def pt_diff : point -> point -> point
def pt_diff pt0 pt1 = zip_map pt0 pt1 minus

-- sum: sum of a list of secret reals
def sum : point -> comp_shr
def sum v z = foldr v z plus

-- dot_prod: take the dot product of two points
def dot_prod p0 p1 = sum (zip_map p0 p1 mult)

-- pt_cost : evaluate the cost of a point
def pt_cost : costs -> point -> comp_shr
def pt_cost c = dot_prod (map shr_costs_w_comp c) 0.0

-- l2norm v: the L2 norm of a vector of shares
def l2norm : point -> comp_shr
def l2norm pt = spdz_sqrt (sum (map square pt) (shr_w_comp 0.0))

-- zeros_vec: a vector of zeroes
def zeros_vec : nat -> list real
def zeros_vec = const_vec 0.0

-- onesVec: a vector of real ones
def onesVec : nat -> list real
def onesVec = const_vec 1.0

-- shift_major: shift matrix between row major and column major order
def shift_major : nat -> list (list t) -> list (list t)
def shift_major c m = foldr m
  (const_vec [ ] c)
  (fun v acc -> map cons (zip_lists v acc))

-- n : parameter: number of variables in the constraint system
def n : nat
def n = 2n

-- row_major: put given matrix in row-major order
def row_major : secretMat -> secretMat
def row_major = shift_major m

-- col_major: put given matrix in column-major order
def col_major : secretMat -> secretMat
def col_major = shift_major n

-- diagonal_matrix p: the diagonal matrix of a point
def diagonal_matrix : point -> secretMat
def diagonal_matrix pt = foldr pt
  [ ]
  (fun d m' ->
    let n' = len pt' in
    (d :: (zeros_vec n')) :: (row_major
      ((zeros_vec n')) :: (col_major (diagonal_matrix pt')))
  )

-- prod_mat_pt : multiply a matrix of secrets and a point
def prod_mat_pt : secretMat -> point -> point
def prod_mat_pt m pt = foldr pt
  [ ]
  (fun f v p -> (map (fun g -> dot_prod v) m1) :: p)

-- prod_mat: product of matrices of secrets
def prod_mat : secretMat -> secretMat -> secretMat
def prod_mat m0 m1 = row_major
  (foldr (col_major m1)
     [ ]
     (fun f c m' -> (prod_mat_pt m0 c) :: m') )

-- prod_mat_rowms: product of two matrices in row-major form
def prod_mat_rowms : secretMat -> secretMat -> secretMat
def prod_mat_rowms m0 m1 = prod_mat m0 (shift_major m1)

-- shr_cost: share a (secret) cost among all non-output parties
def shr_cost : real{ ssec : Cost } -> comp_shr
def shr_cost x = share{ spdz : Ctr, Cost } x

def all_true : list public_bool -> public_bool
def all_true l = foldr l true (fun x acc -> x && acc)

def max : comp_shr -> comp_shr -> comp_shr_bool
def max m n = if m <= n then n else m

-- is_zero_vec v: test if v is the vector of shares of 0
def is_zero_vec : point -> public_bool
def is_zero_vec p = all_true
  (map
    (fun f x -> release_bool (x == (shr_w_comp 0.0)))
    p)

-- transpose m: the transposition of matrix t
def transpose : list (list t) -> list (list t)
def transpose n m = foldr m
  (const_vec [ ] n)
  (fun v acc -> map
    (compose (uncurry cons))
    (zip_lists v acc) )

-- sqMat: square matrix: a matrix with explicit diagonal elements
-- def sqMat : type
-- def sqMat = list (point * comp_shr * point)

-- partition i a l: l partitioned into the first i - elements, ith
-- elt, and the everything after element i. a is a default elt, which
-- should never be used.
def part_ith : nat -> t -> list t -> (list t) * t * (list t)
def part_ith a i l = eliml_nat i
  (fun (hd, tl) -> case tl
     { [ ] -> (rev_ls hd, a, tl)
     ; b :: l' -> (rev_ls hd, b, l')
     })
  ([ ], l)
  (fun (rev_hd, tl) -> case tl
   { [ ] -> (rev_hd, tl)
   ; x :: tl' -> (x :: rev_hd, tl')
   })

-- square m: matrix m coerced into a square matrix
def square : secretMat -> sqMat
def squareMat m =
  let (_, m') = foldl m
    (0, [ ])
    (fun rv (i, acc) -> (inc i, (part_ith (shr_w_comp 0.0) rv i) :: acc)) in
  rev_ls m'

-- cholesky m: the Cholesky decomposition of matrix m, in column-major
-- order, computed using the Cholesky-Crout algorithm
def cholesky : sqMat -> ltMat
def cholesky m =
  let (m', _) = foldl m -- fold over each column in the matrix,
    ([ ], [ ])
    (fun (top, diag, bot) (tri, base) ->
      -- deconstruct the maintained base box 
      let (jth_row', base') = elim_decons base
        ([ ], const_vec [ ] (len bot))
        (fun x tl -> (x, tl)) in
      -- diag': the diagonal elt of the solution
      let diag' = sqrt (diag - (dot_prod jth_row' jth_row')) in
      -- tri': the upper triangle, extended
      let tri' = snoc (diag', [ ])
        (map (fun ((d, tl), jth_elt) -> (d, snoc jth_elt tl))
          (zip_lists tri jth_row')) in
      -- the base box, extended
      let base'' = map 
        (fun (rv', elt) -> snoc ((diag - (dot_prod rv' jth_row')) / diag') rv')
        (zip_lists base' bot) in
      (tri', base'')) in
  m'

def ne_single : t -> (t * list t)
def ne_single x = (x, [ ])

def ne_cons : t -> (t * list t) -> (t * list t)
def ne_cons x (y, l) = (x, y :: l)

def ne_to_list : (t * list t) -> list t
def ne_to_list = uncurry cons

def shr_add_inv : comp_shr -> comp_shr
def shr_add_inv x = (shr_w_comp 0.0) - x

-- col_lt_to_row: convert a row-major LT-matrix to be column major
def col_lt_to_row : colLtMat -> ltMat
-- BILL: define

-- row_lt_to_col: convert a row-major LT-matrix to be column major
def row_lt_to_col : ltMat -> colLtMat
-- BILL: deprecated?

-- lt_inverse m: the inverse of lower-triangular matrix m 
def lt_inverse : ltMat -> ltMat
def lt_inverse l = foldr_tl l -- fold over the LT matrix
  [ ]
  (fun (d, cv) tl -> snoc
    -- fold over the tail of the current column and the rest of the matrix
    (foldl (zip_lists cv (col_lt_to_row tl))
      (d, [ ])
      (fun (x, (rv, y)) cv' ->
        let dprod = dot_prod (cons rv y) ((uncurry cons) cv') in
        snoc ((shr_add_inv dprod) / y) cv' ) ) )

-- BILL: fix defn of lt_inverse

-- lt_lift d l: lower-triangular matrix l, lifted into a matrix by
-- padding copies of default element d
def lt_lift : t -> list (t * (list t)) -> list (list t)
def lt_lift d l =
  let (_, m) = foldl l
    ([ ], [ ])
    (fun (hd, tl) (buf, m) -> (d :: buf, (concat buf (hd :: tl)) :: m) ) in
  rev_ls m

-- inverse m: the inverse matrix of m
def inverse : nat -> secretMat -> secretMat
def inverse n m =
  let l_inv = lt_lift (shr_w_comp 0.0)
    (lt_inverse (cholesky (squareMat (shift_major m)))) in
  prod_mat (transpose linv) l_inv

def prod_diag_pt : point -> point -> point
def prod_diag_pt d p = zip_map d p mult 

def pdecons a f xy = case xy
  { ⟪⟫ → a
  ; ⟪Q.x⟫⧺xy′ → f Q x 
  }

def pfold : ∀ A:☆,P:ℙ. A → ((Q:ℙ | Q⊆P) → ℤ{Q} → A → A) → ℤ{isec:P} →{sec:P} A
def pfold i f xy = case xy
  { ⟪⟫ → i
  ; ⟪Q.x⟫⧺xy′ → f Q x (pfold i f xy′)
  }

def nOnes : list flt
def nOnes = onesVec n 

def reveal_ls P l = 
  case (reveal{ P } l)
  { [ ] -> [ ]
  ; x :: l' -> x :: (reveal_ls P l') 
  }

-- karmarkar_iter: an iteration of Karmarkar's algorithm
def karmarkar_iter : ctr -> cost -> point -> point
def karmarkar_iter a cost pt =
  let unit_cp =
    -- c': vector: product of diagonal of point and cost
    let c' = prod_diag_pt pt (map shr_cost cost) in

    -- ad: m * n matrix; product of diagonal of point and constraints,
    -- and a row of ones
    let b = pfold a
      [ nOnes ]
      (fun Q ctr -> cons
        (prod_diag_pt pt
          (map shr_w_comp (reveal_ls set(Cost,Ctr) ctr)) ) ) in

    -- bt: n * (m + 1) matrix
    let err = "iter: post pfold" + 0 in
    let bt = transpose n b in

    -- project c onto b's nullspace
    let cp = pt_diff
      c'
      (prod_mat_rowms
        bt
        (prod_mat_rowms
          (inverse (m + 1) (prod_mat_rowms b bt))
          (prod_mat_pt b c'))) in

    -- test if the projection is the 0 vector:
    if is_zero_vec cp then const_vec (shr_w_comp 0.0) n
    else point_div (l2norm cp) cp in

  -- take a step of 1/3 n in the direction of cp
  let b' = point_diff
    (map shr_w_comp (vec_div (to_flt n) nOnes))
    (point_div (shr_w_comp (to_flt (3 * n))) unit_cp) in

  let db' = prod_diag_pt pt b' in
  point_div (dot_prod (map shr_pub_with_comp nOnes) db') db'

-- Karmarkar's algorithm, main loop:

-- nat_log: logarithm over nats
def nat_log : nat -> nat -> nat
def nat_log b n =
  if n == 1n then 0n
  else 1n + (nat_log b (n / 2n))

def log_2_ceil : nat -> nat
def log_2_ceil n = 
  let n' = nat_log 2n n in
  let offset = 
    if n == (2n ^ n') then 0n
    else 1n in
  n' + offset

def karmarkar_loop : ctr -> costs -> point
def karmarkar_loop a cost =
    (elim_nats 
      (12n * n *
        ((m + 1n) * n +
         (log_2_ceil (abs_val (ceil (reveal{ Cost, Ctr } (
           -- compute the product of non-zero cost coeffs
           (shr_w_comp
             ({ par : Cost } foldr cost
               1.0 
               (fun x -> if x == 0.0 then id else (mult x)) ) ) *
           (pfold
             (share{ spdz : Cost, Ctr } 1.0)
             (fun Q pnzs acc -> (share{ spdz : Cost, Ctr } pnzs) * acc)
             ({ Ctr } (foldr a
                1.0
                (fun x -> if x == 0.0 then id else (mult x) ) ) ) )
           ) ) ) ) ) +
         n * (log_2_ceil n) ) )
      id
      (fun kr x -> kr (karmarkar_iter a cost x) ) )
      -- compute from the initial point:
      ({ par : Ctr, Cost } map shr_w_comp (vec_div (to_flt n) nOnes))

-- read_vec (): reads a vector of n input floats from a fixed file
def read_vec : unit -> list flt
def read_vec () = read (list flt) "in.txt"
  
-- main:
def main : unit ->{ inp : Ctr, Cost; rev : Out } (list out_sec)
def main () =
  -- Ctr and Cost send the data in the list to Out:
  let soln = { par : Ctr, Cost, Out } (map
    (fun x -> reveal{ Out } x)
    -- Ctr and Cost reveal the list structure of the point to Out:
    (reveal_ls set(Ctr,Cost,Out)
      -- Ctr and Cost compute the solution point:
      ({ par : Ctr, Cost } karmarkar_loop
        -- Ctr reads inputs constraints,
        ({ par : Ctr } (read_vec ()) ) 
        -- Cost reads cost vector, shares list structure with Ctr,
        ({ par : Ctr, Cost } (pdecons 
          [ ]
          (fun Q c -> reveal_ls set(Cost,Ctr) (reveal{ Cost, Ctr } c))
          ({ par : Cost } read_vec ()) ) ) ) ) ) in
  -- Ctr and Cost forget the structure of the solution
  { par : Out } reveal_ls set(Out) soln
