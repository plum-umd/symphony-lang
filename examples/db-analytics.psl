principal A B

-- library of option types as tagged pairs:
def tagJust v = (true, v)

def tagNothing = (false, _|_)

def elim-ooption v vNothing vJust = mux if (fst v)
  then vJust (snd v)
  else vNothing

def main () = par{A, B}
  let pA = map (fun x -> share {yao: A -> A, B} x) 
      (send-ls {A} {A, B}
       (par {A} (read list (int * int) from "biomatching-input.txt"))) in
  let pB = map (fun x -> share {yao: B -> A, B} x) 
      (send-ls {B} {A, B}
       (par {B} (read list (int * int) from "biomatching-input.txt"))) in

  -- compute facts about the union of DB's:
  let unionDb = append pA pB in
  let col2 = map (fun (a, x) -> x) unionDb in
  let unionSum = sum-ints col2 in
  let mean = unionSum / (length unionDb) in
  let variance = elim-list col2
    0
    (fun x -> let d = x - mean in plus (d * d)) in

  let joinDb = elim-list pA
    [ ]
    (fun (xa, ya) joinDb0 -> elim-list pB joinDb0
      (fun (xb, yb) -> cons
         (mux if xa == xb then tagJust (xa, ya, yb)
          else tagNothing)
      )) in

  let joinNumElts = elim-list joinDb 0
    (fun x sum -> elim-ooption x sum (const (plus 1 sum))) in
  let joinSum = elim-list joinDb 0
    (fun x -> plus (elim-ooption x 0 (fun (x0, y0, z0) -> y0))) in
  let joinMean = joinSum / joinNumElts in
  let joinVar = elim-list joinDb 0
    (fun x var0 -> elim-ooption x var0
      (fun (x0, y0, z0) -> let d = y0 - mean in plus (d * d) var0) ) in

  (variance, joinVar)
