principal A B

-- library of option types as tagged pairs:
def tagJust v = (true, v)

def tagNothing = (false, _|_)

def elim-ooption v vNothing vJust = mux if (fst v)
  then vJust (snd v)
  else vNothing

def main () = par{A, B}
  let pA = map (fun x -> share {yao: A -> A, B} x) 
      (send-ls {A} {A, B}
       (par {A} (read list (int * int) from "biomatching-input.txt"))) in
  let pB = map (fun x -> share {yao: B -> A, B} x) 
      (send-ls {B} {A, B}
       (par {B} (read list (int * int) from "biomatching-input.txt"))) in

  -- compute facts about the union of DB's:
  let union-db = append pA pB in
  let col2 = map snd union-db in
  let union-num-elts = length union-db in

  let union-mean = (sum-ints col2) / union-num-elts in
  let union-variance = (elim-list col2 0
    (fun x -> let d = x - union-mean in plus (d * d))) /
    union-num-elts in

  -- compute facts about the join of DB's:
  let join-db = elim-list pA [ ]
    (fun (xa, ya) join-db0 -> elim-list pB join-db0
      (fun (xb, yb) -> cons
         (mux if xa == xb then tagJust (xa, ya, yb)
          else tagNothing)
      )) in

  let join-num-elts = elim-list join-db 0
    (fun x sum -> elim-ooption x sum (const (plus 1 sum))) in
  let join-mean = (elim-list join-db 0
    (fun x -> plus (elim-ooption x 0 (fun (x0, y0, z0) -> y0))) ) /
    join-num-elts in
  let join-variance = (elim-list join-db 0
    (fun x -> plus (elim-ooption x 0
      (fun (x0, y0, z0) -> let d = y0 - join-mean in (d * d)) ) ) ) /
    join-num-elts in

  -- TODO: reveal these
  (reveal { A, B } union-mean,
   reveal { A, B } union-variance,
   reveal { A, B } join-mean,
   reveal { A, B } join-variance)
