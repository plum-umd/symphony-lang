principal A B

-- Copied from standard library

-- Get the tail of the list or a default value.
def tail : list a -> list a
def tail xs = case xs
  { [] -> _|_
  ; _::xs' -> xs'
  }

-- Get the head of a list or a default value.
def head : list a -> a
def head ys = case ys
    { [] -> _|_
    ; y::_ -> y
    }

-- Turn a secret list of elements known to p, xs, to a list known to t of secret shared elements up to length n.
def preprocessListsN : (P:prin) -> (ps:prins) -> int -> (list int){P} -> list int{yao:ps}
def preprocessListsN P ps n xs =
  if n == 0
  then []
  else
    let h = share{yao:P -> ps} (par {P} head xs)
    let ps = preprocessListsN P ps (n - 1) (par {P} tail xs)
    in h :: ps

-- Turn a secret list of elements known to p to a list known to t of secret shared elements by revealing the length of the original list to t.
def preprocessLists : (P:prin) -> (ps:prins) -> (list a){P} -> list a{yao:ps}
def preprocessLists P ps xs =
  let l = par {P} length xs
  let l' = send {P -> ps} l
  --             ^
  --             always a singleton
  in preprocessListsN P ps l' xs

-- Insert an element, x, into a sorted list, xs, using a "less than" function, lt, so that the output list is also sorted.
def insert : (a -> a -> bool) -> a -> list a -> list a
def insert lt x xs = case xs
  { [] -> [x]
  ; (x'::xs') ->
      let lo, hi =
        mux if (lt x x')
             then x, x'
             else x', x
      in
        lo :: insert lt hi xs'
  }

-- Use insertion sort to and a "less than" function, lt, to sort a list of elements.
def sort : (a -> a -> bool) -> list a -> list a
def sort lt = foldr (insert lt) []



-----------------------------------------------------------------------------------

def main : unit ->{inp:A,B;rev:A,B} list int{A,B}
def main () = par {A,B}

  -- Read in inputs as individually secret lists of secret data
  let inputLists : (list int){bundle:A,B}
  let inputLists = solo {A,B} as alpha in read (list ℤ) from "atq-data.txt"

  -- (list int){A}
  -- (list int){B}

  -- Share the elements of each list and reveal the list structures of each party's list
  let sharedLists : list list (int{yao:A,B})
  let sharedLists = fold-f [] (fun P x i -> (preprocessLists P {A,B} x) :: i) inputLists

  -- Combine all lists into one list of all data
  let sharedCombinedList : list int{yao:A,B}
  let sharedCombinedList = concat sharedLists

  -- Sort the list
  let sharedCombinedSortedList : list int{yao:A,B}
  let sharedCombinedSortedList = sort (fun a b -> a ≤ b) sharedCombinedList

  -- Reveal each element in the list
  let revealedCombinedSortedList : (list int{A,B}){A,B}
  let revealedCombinedSortedList = map (fun x -> reveal{A,B} x) sharedCombinedSortedList

  in revealedCombinedSortedList

