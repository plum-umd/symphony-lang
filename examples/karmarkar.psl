-- m : number of constraint parties
def m : nat
def m = 8n

-- Ctr: parties that bring the constraints
principal Ctr[8]

-- party that provides the cost vector:
principal Cost

-- party that gets the output:
principal Out

-- reals: IEEE64
-- def real : type
-- def real = float[64]
-- PSL: support type definitions

-- PSL: BEGIN ops that need to be supported

-- abs i: the magnitude of i and whether it was positive
def absInt : int -> nat * bool

-- ceil x: the ceiling of x
def ceil : real -> int

def exp : float -> float -> float
-- exp: mockup that lets the code run
def exp x y = 0.1

-- nat_to_real n: conversion of n into a real:
def nat_to_real : nat -> real

def bgw_sqrt : real{ bgw : Ctr, Cost } -> real{ bgw : Ctr, Cost }

-- PSL: support SPDZ as a protocol

-- PSL: END ops that need to be supported

-- ctr: the type of constraints. An independent secret vector.
-- def ctr : type
-- def ctr = list (real{ isec : Ctr })

-- costs: the type of cost vectors:
-- def costs : type
-- def costs = list (real{ ssec : Cost })

-- comp_shr: a real secret-shared between all compute parties
-- def comp_shr : type
-- def comp_shr = real{ bgw : Ctr, Cost }

-- def comp_shr_bool : type
-- def comp_shr_bool = bool{ bgw: Ctr, Cost }

-- out_sec: a secret known only to the output party
-- def out_sec : type
-- def out_sec = real{ ssec : Out }

-- shr_cost_w_comp: 
def shr_cost_w_comp : real{ ssec : Cost } -> comp_shr
def shr_cost_w_comp x = share{ bgw : Ctr, Cost } x

def shr_ctr_w_comp : real{ bgw : Ctr } -> comp_shr
def shr_cost_w_comp x = share{ bgw : Ctr, Cost } x

-- shr_pub_w_comp: make shares of a public real
def shr_pub_w_comp : real -> comp_shr
def shr_pub_w_comp x = share{ bgw : Ctr, Cost } x

-- public_bool: booleans known to everyone
-- def public_bool : type
-- def public_bool = bool{ ssec: Ctr, Cost, Out }

-- release_bool: publicly reveal a bool shared between all compute
-- parties
def release_bool : comp_shr_bool -> public_bool
def release_bool x = reveal{ Ctr, Cost, Out } x

-- public_nat: nats known to everyone
-- def public_nat : type 
-- def public_nat = nat{ ssec: Ctr, Cost, Out }

-- release_bool: publicly reveal a nat shared between all compute
-- parties
def release_nat : comp_shr_nat -> public_nat
def release_nat n = reveal{ Ctr, Cost, Out } n

-- point: a point the comp_shrensional space of a constraint
-- def point : type 
-- def point = list comp_shr

-- secretMat: a matrix of additive shares of reals
-- def secretMat : type
-- def secretMat = list point

-- ltMat: a lower-trignular matrix of additive shares of reals in
-- row-major order
-- def ltMat : type
-- def ltMat = list ((list comp_shr) * comp_shr)

-- ltMat: a lower-triangular matrix of additive shares in column-major
-- order
-- def colLtMat : type
-- def colLtMat = list (comp_shr * (list comp_shr))

-- library functions for nat

-- plus: non-infix sum
def plus : nat -> nat -> nat
def plus m n = m + n

-- inc n: increment of n
def inc : nat -> nat
def inc = plus 1n

-- minus: non-infix substraction
def minus : nat -> nat -> nat
def minus m n = m - n

-- dec: decrement
def dec : nat -> nat
def dec (n : nat) = n - 1n

-- elim_nats: form for eliminating (folding over) nats
def elim_nats : nat -> t -> (t -> t) -> t
def elim_nats m z s = 
  if m â‰¡ 0n then z
  else s (elim_nats (dec m) z s)

-- elim_natsl: analog of fold right, for nats
def elim_natsl : nat -> t -> (t -> t) -> t
def eliml_natl n z s = 
  (elim_nats n id (compose s)) z

-- library functions for functions:

def compose : (t0 -> t1) -> (t1 -> t2) -> (t0 -> t2)
def compose f g x = g (f x)

def const : t -> u -> t
def const x y = x

def curry : (a * b -> c) -> (a -> b -> c)
def curry f x y = f (a, b)

def id : t -> t
def id x = x

def uncurry : (a -> b -> c) -> (a * b -> c)
def uncurry f (a, b) = f a b

-- library functions for lists:

-- cons: non-infix list cons
def cons : t -> list t -> list t
def cons x l = x :: l

-- const_vec t a n: a vector of constant a of size n
def const_vec : t -> nat -> list t
def const_vec c n = elim_nats n [ ] (cons c)

-- foldr: right fold, the list eliminator
def foldr : list t -> acc -> (t -> acc -> acc) -> acc
def foldr l acc f = case l
{ [ ] -> acc
; x :: l' -> f x (foldr l' acc f)
}

-- foldr_tl: right fold with access to the tail of the list
def foldr_tl : list t -> acc -> (t -> list t -> acc -> acc) -> acc
def foldr_tl l i f =
  let (_, a) = foldr l ([ ], i) (fun x (l', b) -> (x :: l', f x l' b)) in
  a

def decons_ls : list t -> u -> (t -> list t -> u) -> u
def decons_ls l a0 f = foldr_tl l a0 (fun x ls -> const (f x ls))
  
-- foldl: left fold
def foldl : list t -> acc -> (t -> acc -> acc) -> acc
def foldl l acc f = (foldr l id (fun x -> compose (f x))) acc

def concat : list t -> list t -> list t
def concat l0 l1 = foldr l0 l1 cons

def len : list t -> nat
def len l = foldr l 0 (fun x -> inc)

-- map: map operation for the list functor
def map : (t -> u) -> list t -> list u
def map f l = foldr l [ ] (compose f cons)

-- rev l: the reverse of list l
def rev_ls : list t -> list t
def rev_ls l = foldl l [ ] cons

def snoc : t -> list t -> list t
def snoc x l = foldr l [ x ] cons

-- zip_lists pt0 pt1: the zip of points p0 and p1
def zip_lists : list t -> list u -> list (t * u)
def zip_lists l0 l1 =
  let zip0 = foldr l0
    (const [ ])
    (fun x z0 l -> decons_ls l
       [ ]
       (fun y l' -> (x, y) :: z0 l') ) in
  zip0 l1

-- point_div x pt: divide each entry in pt by x
def point_div : comp_shr -> point -> point
def point_div x = map (fun a -> a / x) 

-- vec_div: divide a vector of reals by a constant
def vec_div : real -> list real -> list real
def vec_div a = map (fun x -> x / a)

-- nzProd a: the product of all non-zero entries in a vector:
def nzProd : list (real{ ssec : p }) -> real{ ssec : p }
def nzProd l = foldr l
  (shr_pub_w_comp 1.0)
  (fun x acc -> if x == 0.0 then acc else x * acc)

-- pt_diff: subtract one point from another
def pt_diff : point -> point -> point
def pt_diff pt0 pt1 = map
  (fun (p0, p1) -> p0 - p1)
  (zip_lists pt0 pt1)

-- pt_dot_prod: take the dot product of two points
def pt_dot_prod : point -> point -> comp_shr
def pt_dot_prod p0 p1 = foldr
  (map (fun (p0, p1) -> p0 * p1) (zip_lists p0 p1))
  0.0
  (fun d acc -> d + acc)

-- pt_cost : evaluate the cost of a point
def pt_cost : costs -> point -> comp_shr
def pt_cost c = pt_dot_prod (map shr_costs_w_comp c)

-- pub_pt_cost: evaluate the cost of a public point
def pub_pt_cost : costs -> list real -> real{ ssec : Cost }
def pub_pt_cost costs pt = foldr
  (map
    (fun (c, p) -> { par : Cost } c0 * p0)
    (zip_lists costs pt))
  0.0
  (fun d acc -> { par : Cost } d + acc)

-- sum: sum of a list of secret reals
def sum : point -> comp_shr
def sum pt = fold pt (shr_pub_w_comp 0.0) (fun x acc -> x + acc)

-- l2norm v: the L2 norm of real vector v
def l2norm : point -> comp_shr
def l2norm pt = bgw_sqrt (sum (map (fun x -> x * x) pt))

-- PSL: what's the type of a constant?

-- zeros_vec: a vector of zeroes
def zeros_vec : nat -> list real
def zeros_vec n = const_vec 0.0 n
-- PSL: support typechecking functions without explicit parameters

-- onesVec: a vector of real ones
def onesVec : nat -> list real
def onesVec n = const_vec 1.0 n

-- shift_major: shift matrix between row major and column major order
def shift_major : nat -> secretMat -> secretMat
def shift_major c m = foldr m
  (const_vec [ ] c)
  (fun v acc -> map cons (zip_lists v acc))

-- BILL: generalize type of shift_major

-- n : parameter: number of variables in the constraint system
def n : nat
def n = 8n

-- row_major: put given matrix in row-major order
def row_major : secretMat -> secretMat
def row_major = shift_major m

-- col_major: put given matrix in column-major order
def col_major : secretMat -> secretMat
def col_major = shift_major n

-- diagonal_matrix p: the diagonal matrix of a point
def diagonal_matrix : point -> secretMat
def diagonal_matrix pt = foldr pt
  [ ]
  (fun d m' ->
    let n' = len pt' in
    (d :: (zeros_vec n')) :: (row_major
      ((zeros_vec n')) :: (col_major (diagonal_matrix pt')))
  )

-- prod_mat_pt : multiply a matrix of secrets and a point
def prod_mat_pt : secretMat -> point -> point
def prod_mat_pt m pt = foldr pt
  [ ]
  (fun f v p -> (map (fun g -> pt_dot_prod v) m1) :: p)

-- prod_mat: product of matrices of secrets
def prod_mat : secretMat -> secretMat -> secretMat
def prod_mat m0 m1 = row_major
  (foldr (col_major m1)
     [ ]
     (fun f c m' -> (prod_mat_pt m0 c) :: m') )

-- prod_mat_rowms: product of two matrices in row-major form
def prod_mat_rowms : secretMat -> secretMat -> secretMat
def prod_mat_rowms m0 m1 = prod_mat m0 (shift_major m1)

-- shr_cost: share a (secret) cost among all non-output parties
def shr_cost : real{ ssec : Cost } -> comp_shr
def shr_cost x = share{ bgw : Ctr, Cost } x

def all_true : list public_bool -> public_bool
def all_true l = foldr l true (fun x acc -> x && acc)

def max : comp_shr -> comp_shr -> comp_shr_bool
def max m n = if m <= n then n else m

-- is_zero_vec v: test if v is the vector of shares of 0
def is_zero_vec : point -> public_bool
def is_zero_vec p = all_true
  (map
    (fun f x -> release_bool (x == (shr_pub_w_comp 0.0)))
    p)

-- transpose m: the transposition of matrix t
def transpose : list (list t) -> list (list t)
def transpose n m = foldr m
  (const_vec [ ] n)
  (fun v acc -> map
    (compose (uncurry cons))
    (zip_lists v acc) )

-- sqMat: square matrix: a matrix with explicit diagonal elements
-- def sqMat : type
-- def sqMat = list (point * comp_shr * point)

-- partition i a l: l partitioned into the first i - elements, ith
-- elt, and the everything after element i. a is a default elt, which
-- should never be used.
def part_ith : nat -> t -> list t -> (list t) * t * (list t)
def part_ith a i l = eliml_nat i
  (fun (hd, tl) -> case tl
     { [ ] -> (rev_ls hd, a, tl)
     ; b :: l' -> (rev_ls hd, b, l')
     })
  ([ ], l)
  (fun (rev_hd, tl) -> case tl
   { [ ] -> (rev_hd, tl)
   ; x :: tl' -> (x :: rev_hd, tl')
   })

-- square m: matrix m coerced into a square matrix
def square : secretMat -> sqMat
def squareMat m =
  let (_, m') = foldl m
    (0, [ ])
    (fun rv (i, acc) -> (inc i, (part_ith (shr_pub_w_comp 0.0) rv i) :: acc)) in
  rev_ls m'

-- cholesky m: the Cholesky decomposition of matrix m, in column-major
-- order, computed using the Cholesky-Crout algorithm
def cholesky : sqMat -> ltMat
def cholesky m =
  let (m', _) = foldl m -- fold over each column in the matrix,
    ([ ], [ ])
    (fun (top, diag, bot) (tri, base) ->
      -- deconstruct the maintained base box 
      let (jth_row', base') = elim_decons base
        ([ ], const_vec [ ] (len bot))
        (fun x tl -> (x, tl)) in
      -- diag': the diagonal elt of the solution
      let diag' = sqrt (diag - (dot_prod jth_row' jth_row')) in
      -- tri': the upper triangle, extended
      let tri' = snoc (diag', [ ])
        (map (fun ((d, tl), jth_elt) -> (d, snoc jth_elt tl))
          (zip_lists tri jth_row')) in
      -- the base box, extended
      let base'' = map 
        (fun (rv', elt) -> snoc ((diag - (dot_prod rv' jth_row')) / diag') rv')
        (zip_lists base' bot) in
      (tri', base'')) in
  m'

def ne_single : t -> (t * list t)
def ne_single x = (x, [ ])

def ne_cons : t -> (t * list t) -> (t * list t)
def ne_cons x (y, l) = (x, y :: l)

def ne_to_list : (t * list t) -> list t
def ne_to_list = uncurry cons

def shr_add_inv : comp_shr -> comp_shr
def shr_add_inv x = (shr_pub_w_comp 0.0) - x

-- col_lt_to_row: convert a row-major LT-matrix to be column major
def col_lt_to_row : colLtMat -> ltMat
-- BILL: define

-- row_lt_to_col: convert a row-major LT-matrix to be column major
def row_lt_to_col : ltMat -> colLtMat
-- BILL: deprecated?

-- lt_inverse m: the inverse of lower-triangular matrix m 
def lt_inverse : ltMat -> ltMat
def lt_inverse l = foldr_tl l -- fold over the LT matrix
  [ ]
  (fun (d, cv) tl -> snoc
    -- fold over the tail of the current column and the rest of the matrix
    (foldl (zip_lists cv (col_lt_to_row tl))
      (d, [ ])
      (fun (x, (rv, y)) cv' ->
        let dprod = dot_prod (cons rv y) ((uncurry cons) cv') in
        snoc ((shr_add_inv dprod) / y) cv' ) ) )

-- BILL: fix defn of lt_inverse

-- lt_lift d l: lower-triangular matrix l, lifted into a matrix by
-- padding copies of default element d
def lt_lift : t -> list (t * (list t)) -> list (list t)
def lt_lift d l =
  let (_, m) = foldl l
    ([ ], [ ])
    (fun (hd, tl) (buf, m) -> (d :: buf, (concat buf (hd :: tl)) :: m) ) in
  rev_ls m

-- inverse m: the inverse matrix of m
def inverse : nat -> secretMat -> secretMat
def inverse n m =
  let l_inv = lt_lift (shr_pub_w_comp 0.0)
    (lt_inverse (cholesky (squareMat (shift_major m)))) in
  prod_mat (transpose linv) l_inv

-- prod_secret: take the product of two shares
def prod_secret : comp_shr -> comp_shr -> comp_shr
def prod_secret x y = x * y

def prod_diag_pt : point -> point -> point
def prod_diag_pt d p = map
  (uncurry prod_secret)
  (zip_lists d p) 

def pfold : âˆ€ A:â˜†,P:â„™. A â†’ ((Q:â„™ | QâŠ†P) â†’ â„¤{Q} â†’ A â†’ A) â†’ â„¤{isec:P} â†’{sec:P} A
def pfold i f xy = case xy
  { âŸªâŸ« â†’ i
  ; âŸªQ.xâŸ«â§ºxyâ€² â†’ f Q x (pfold i f xyâ€²)
  }

-- karmarkar_iter: an iteration of Karmarkar's algorithm
def karmarkar_iter : ctr -> cost -> point -> point
def karmarkar_iter a cost init_pt =
  let nOnes = const_vec 1.0 n in
  let unit_cp =
    -- c': vector: product of diagonal of initial point and cost
    let c' = { par : Cost }
      prod_diag_pt init_pt (map shr_cost cost) in

    -- ad: m * n matrix; product of constraints and diagonal matrix
    let ad = { par : Ctr }
      prod_diag_pt init_pt (map shr_ctr_w_comp a) in

    -- b: (m + 1) * n matrix
    let b = pfold [ nOnes ] (fun Q -> cons) ad in
    -- bt: n * (m + 1) matrix
    let bt = transpose n b in

    -- project c onto b's nullspace
    let cp = pt_diff
      c'
      (prod_mat_rowms
        bt
        (prod_mat_rowms
          (inverse (m + 1) (prod_mat_rowms b bt))
          (prod_mat_pt b c'))) in

    -- test if the projection is the 0 vector:
    if is_zero_vec cp then const_vec (shr_pub_w_comp 0.0) n
    else point_div (l2norm cp) cp in

  -- take a step of 1/3 n in the direction of cp
  let b' = point_diff
    (map shr_pub_w_comp (vec_div (nat_to_real n) nOnes))
    (point_div (shr_pub_w_comp (nat_to_real (3 * n))) unit_cp) in

  let db' = prod_diag_pt init_pt b' in
  point_div (pt_dot_prod (map shr_pub_with_comp nOnes) db') db'

-- Karmarkar's algorithm, main loop:

-- nat_mult: infix multiplication of nats
def nat_mult : nat -> nat -> nat
def nat_mult m n = m * n

-- nat_exp: exponentiation of nats
def nat_exp : nat -> nat -> nat
def nat_exp b a = elim_nats b 1 (nat_mult a)

-- nat_log: logarithm over nats
def nat_log : nat -> nat -> nat
def nat_log b n =
  if n == 1 then 0
  else 1 + (nat_log b (n / 2))

def log_2_ceil : nat -> nat
def log_2_ceil n = 
  let n' = log 2 n in
  let offset = 
    if n == (nat_exp 2 n') then 0
    else 1 in
  n' + offset

def karmarkar_loop : ctr -> costs -> point
def karmarkar_loop a cost =
  -- eps: defines the stopping condition for the loop. Constant
  -- comes from the GFI:
  let eps = exp 10.0 (-8.0) in

  -- init_pt: the initial point:
  let init_pt = vec_div (nat_to_real n) nOnes in
  let shr_init = map shr_pub_w_comp init_pt in

  -- if the initial point is optimal, then return it:
  if shr_cost ((pub_pt_cost cost init_pt) == 0.0) then shr_init
  else
    -- karmarkar_rec: recurse on the number of iterations, which is
    -- pre-computed from the constraints and costs:
    let karmarkar_rec = elim_nats 
      (let nzCostsProd = { par : Cost }
        (foldr l
           1.0 
           (fun x -> if x == 0.0 then id else (float_prod x)) ) in
       let nzCtrProd =
         -- nzs: real{ isec : Ctr }: product of all non-zero entries in
         -- each constraint
         let nzs = { par : Ctr } 
           (foldr a
             1.0
             (fun x -> if x == 0.0 then id else (float_prod x))) in
         pfold
           (shr_pub_w_ctrs 1.0)
           (fun Q pnzs acc -> (share{ bgw : Ctr } pnzs) * acc)
           nzs in
       12 * n *
        ((m + 1) * n +
         (log_2_ceil (absInt (ceil (release_nat (
           (shr_cost_w_comp nzCostsProd) *
           (shr_ctr_w_comp nzCtrProd)))))) +
         n * (log_2_ceil n))
      )
      id
      (fun f kr x ->
        let x' = karmarkar_iter a cost x in
        let stop =
          let score = pt_cost cost x in
            (score - (pt_cost cost x')) / (max 1.0 score) < eps in
        if stop then x'
        else kr x') in

    -- compute from the initial point:
    karmarkar_rec shr_init

-- read_vec (): reads a vector of n input floats from a fixed file
def read_vec : unit -> list float
def read_vec () = read (list float) "in.txt"
  
-- main:
def main : unit ->{ inp : Ctr, Cost; rev : Out } (list out_sec)
def main () =
  -- each constraint party reads its input vector
-- PSL:  let c = { par : Ctr } (read_vec ()) in
  let c = { par : Ctr } [ ] in
  
  -- the cost party reads its input vector
--  PSL: let cost = { par : Cost } (read_vec ()) in
  let cost = { par : Cost } [ ] in

  map (fun x -> reveal{ Out } x) (karmarkar_loop c cost)
