-- m : user parameter: number of constraint parties
def m : nat
def m = 8n

-- n : user parameter: dimension of the constraint system
def n : nat
def n = 8n

-- Node_in[m]: parties that bring the constraints
principal Node_in[8]

-- party that provides the cost vector:
principal Node_c

-- party that gets the output:
principal Node_o

-- comps: the parties that do computation, Node_in and Node_c
def comps = { Node_in, Node_c }

-- aliases of definitions in the standard lib:

-- order: alias for list length
def order = len

-- eq-vecs: alias for vectors
def eq-vecs = eq_lists

-- minux-vecs: alias for subtracting lists
def minus-vecs = zip-map minus-fixed-pt

def zero-vec = zero-ls-fixed-pt
def row-of-ones = one-ls-fixed-pt

-- shr-w-comp x: x, SPDZ-shared with the computation parties
def shr-w-comp sender x = share{ spdz : sender -> comps } x

def zero-vec-shrs n = map (shr-w-comp { Node_c }) (zero-vec n)

-- nz_prod l: the product of non-zero entries in l
def nz-prod-ls l = elim-list l fixed-pt-1
  (fun x -> const (prod (mux if (x == fixed-pt-0) then fixed-pt-1 else x)))

-- nz-prod-mat z u m: product of non-z entries in matrix m with
-- multiplicative unit u.
def nz-prod-mat m = nz-prod-ls (map nz-prod-ls m)

-- Listing 9: Inverse of a lower triangular matrix
def matrix_inverse_lt :
  list ((list float{ spdz : Node_in, Node_c })
          { Node_in, Node_c }){ Node_in, Node_c } ->
  list ((list float{ spdz : Node_in, Node_c })
          { Node_in, Node_c }){ Node_in, Node_c } 
def matrix_inverse_lt l =
  let n = order l in -- order of L
  let l_inv = ref (zero-fixed-pt-mat n) in -- n x n zero matrix
  do (iter (range 0n (n - 1n))
    (fun k ->
      -- For diagonal entries, take the reciprocal
      do l_inv := upd-matrix !l_inv (k, k) (mult-inv-fixed-pt (get-matrix !l_inv (k, k))) in

      -- For non-diagonal entries, solve L * L_inv = I
      iter (range (k + 1n) (n - 1n))
        (fun j ->
          let sum = ref fixed-pt-0 in
          iter (range k (j - 1n))
            (fun i ->
              sum := minus-fixed-pt !sum (mult-fixed-pt (get-matrix l (j, i)) (get-matrix !l_inv (i, k)))
              ) ) ) ) in
  !l_inv


-- Listing 10: Cholesky decomposition of a positive definite Hermitian
-- matrix
def cholesky_decomposition :
  list ((list float{ spdz : Node_in, Node_c })
          { Node_in, Node_c }){ Node_in, Node_c } ->
  list ((list float{ spdz : Node_in, Node_c })
          { Node_in, Node_c }){ Node_in, Node_c } 
def cholesky_decomposition m =
  -- Initialize variables
  let n = order m in -- order of m
  let l = ref (zero-fixed-pt-mat n) in -- n x n zero matrix

  -- Calculate the top diagonal element of L
  do l := upd-matrix !l (0n, 0n) (sqrt-fixed-pt (get-matrix m (0n, 0n))) 

  -- Calculate the rest of the first column of L
  do iter (range 1n (n - 1n))
    (fun j ->
      l := upd-matrix !l (j, 0n) (div-fixed-pt (get-matrix m (j, 0n)) (get-matrix !l (0n, 0n)) ) )

  -- Iterate through the remaining columns
  do iter (range 1n (n - 1n))
    (fun i ->
      -- First calculate the diagonal element for this column
      let sum = ref fixed-pt-0 in
      do iter (range 0n (i - 1n))
        (fun j ->
          sum := plus-fixed-pt !sum (mult-fixed-pt (get-matrix !l (i, j)) (get-matrix !l (i, j)) ))
      do l := upd-matrix !l (i, i) (sqrt-fixed-pt (minus-fixed-pt (get-matrix m (i, i)) !sum)) in
      -- Now fill in the remaining entries in this column
      when (i < n - 1n) then
        (iter (range (i + 1n) (n - 1n))
          (fun j ->
            do sum := fixed-pt-0 in
            iter (range 0n (i - 1n))
              (fun k ->
                sum := plus-fixed-pt !sum (mult-fixed-pt (get-matrix !l (i, k)) (get-matrix !l (j, k)) ) ) ) ) ) in
    !l

-- Listing 8: Inverse of a positive definite Hermitian matrix
def matrix_inverse_pdh : 
  list ((list float{ spdz : Node_in, Node_c })
          { Node_in, Node_c }){ Node_in, Node_c } ->
  list ((list float{ spdz : Node_in, Node_c })
          { Node_in, Node_c }){ Node_in, Node_c } 
def matrix_inverse_pdh m =
  let l = cholesky_decomposition m in
  let l_inv = matrix_inverse_lt l in -- Invert the lower-triangular matrix
  let m_inv = mult-matrices-fixed-pt (transpose l_inv) l_inv in
  m_inv

-- Listing 6: Iteration for Karmarkar's Algorithm
def karmarkar_iteration :
  (list float{ spdz : Node_in, Node_c }){ Node_in, Node_c } ->
  list ((list float{ spdz : Node_in, Node_c })
          { Node_in, Node_c }){ Node_in, Node_c } ->
  (list float{ spdz : Node_in, Node_c }){ Node_in, Node_c } ->
  (list float{ spdz : Node_in, Node_c }){ Node_in, Node_c } 
def karmarkar_iteration a c initial_point =
  let (m, n) = dimensions_of a in
  -- D is a matrix of zeros with the values of initial_point on the
  -- diagonal
  -- Dimensions of D: n x n
  let d = diagonal-matrix-fixed-pt initial_point in
  -- Dimensions of cprime: n x 1
  let cprime = mult-matrix-vec-fixed-pt d c in
  -- Dimensions of AD: m x n
  let ad = mult-matrices-fixed-pt a d in

  -- Construct B
  -- Dimensions of B: (m + 1) x n
  let b = append ad [ row-of-ones n ] in -- append a row of ones onto AD

  -- Dimensions of BBT: (m + 1) x (m + 1)
  let bbt = mult-matrices-fixed-pt b (transpose b) in

  -- Dimensions of BBTInv: (m + 1) x (m + 1)
  let bbtinv = matrix_inverse_pdh bbt in

  -- Project C onto B's nullspace
  -- Dimensions of cp: n x 1
  let cp = minus-vecs cprime
    (mult-matrix-vec-fixed-pt (transpose b)
      (mult-matrix-vec-fixed-pt bbtinv
        (mult-matrix-vec-fixed-pt b cprime) ) ) in

  -- Calculate a unit vector of cp
  -- Dimensions of unitcp: n x 1
  let unit_cp =
    mux if eq-vecs cp (zero-vec n) then -- If cp is the zero vector
      -- If cp is the zero vector, assign it to be 0
      (zero-vec-shrs n)
    else div-fixed-pt-scalar-vec (zero-vec n) (l2norm-fixed-pt cp) in

  -- Take a step of 1/3n in the direction of -cp, row-of-ones(n)/n is
  -- the "transformed" initial point
  -- Dimensions of bprime: n x 1
  let bprime = minus-vecs
    (div-fixed-pt-scalar-vec (row-of-ones n) (to-fixed-pt (int n)))
    (mult-scalar-vec
      (mult-inv-fixed-pt (to-fixed-pt (3 * (int n))))
      unit_cp) in

  -- Transform the point back
  -- Dimensions of b: n x 1
  let b = div-fixed-pt-scalar-vec (mult-matrix-vec-fixed-pt d bprime)
    (dot-prod-fixed-pt (row-of-ones n) (mult-matrix-vec-fixed-pt d bprime)) in
  b


-- Listing 7: Loop for Karmarkar's Algorithm
def karmarkar_loop :
  list ((list float{ spdz : Node_in, Node_c })
          { Node_in, Node_c }){ Node_in, Node_c } ->
  (list float{ spdz : Node_in, Node_c }){ Node_in, Node_c } ->
  (list float{ spdz : Node_in, Node_c }){ Node_in, Node_c } 
def karmarkar_loop a c = proc
  let (m, n) = dimensions_of a in

  -- x is our initial point
  let x = div-fixed-pt-scalar-vec (row-of-ones n) (to-fixed-pt (int n)) in

  -- let num-iters = fun costs ctrs ->
  --   -- product of non-zero entries in c and A
  --   let p = (nz-prod-ls costs) * (nz-prod-mat ctrs) in
  --   let l = (m + 1n) * n +
  --     (abs_val (ceil (log_base_2 (abs-val-flt-shr p)))) +
  --     n * (abs_val (ceil (log_base_2 (to_flt n)))) in
  --   12n * n * l in
  -- let max_iterations = num-iters c a in
  -- let upper-bound = num-iters (max-vec-flt n) (max-mat-flt m n) in
  let num-iters = 10n in

  elim_nat num-iters x (karmarkar_iteration a c)


-- main: entry point; Node_in, Node_c read inputs and run the algorithm,
-- distributes results to Node_o
def main :
  unit
  ->{ inp : Node_in, Node_c; rev : Node_o }
  ((list float{ Node_o }){ Node_o } *
   ((nizk-verify { Node_o, Node_in } bool){ bundle : Node_in }) *
   (nizk-verify { Node_o, Node_c } bool){ Node_c })
def main () =
  let ctrs = solo { Node_in } as c in
    (map to-fixed-pt (read (list int) from "in.txt")) in
  let cost = par { Node_c }
    (map to-fixed-pt (read (list int) from "in.txt")) in
  let shrd-soln = par { Node_in, Node_c, Node_o } (map
    (wrap-reveal { Node_o })
    -- Node_c reveals the structure of the list to out:
    (send-ls { Node_c } { Node_in, Node_c, Node_o }
      -- Node_in and Node_c compute the solution point:
      (par { Node_in, Node_c } karmarkar_loop
        -- read in the matrix of constraints and share them
        (fold-f
          []
          (fun Q ctr -> cons (map (shr-w-comp { Q }) (send-ls { Q } comps ctr)))
          ctrs)
        -- read in the vector of costs and share them
        (map (shr-w-comp { Node_c })
          (send-ls { Node_c } comps cost) ) ) ) ) in
  -- Node_in and Node_c forget the structure of the solution
  par { Node_o } send-ls { Node_o } { Node_o } shrd-soln 
   
