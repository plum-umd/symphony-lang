-- BEGIN definitions appropriate for general-purpose library modules

-- err msg: raise a runtime exception that prints msg
def err msg = msg + 0

-- TODO: define these properly
def log_2_real = id

def magn x = 1n

-- order: alias for list length
def order = len

-- eq-vecs: alias for vectors
def eq-vecs = eq_lists

-- minux-vecs: alias for subtracting lists
def minus-vecs = minus-lists

-- scalar_vec_mult a v: scalar product of a and v
def scalar_vec_mult a = map (mult a)

-- scalar_vec_div: divide a vector of reals by a constant
def div_vec : real -> list real -> list real
def div_vec v a = map (flip div a) v

-- l2norm z v: the L2 norm of a vector of numerics with zero element z
def l2norm : point -> comp_shr
def l2norm z v = babylonian_sqrt (sum (map square v))

-- row_of_ones: a vector of real ones
def row_of_ones : nat -> list real
def row_of_ones = const-ls 1.0

-- mult_mat_vec : multiply a matrix of secrets and a point
def matrix_vec_mult_gen z m pt = map (dot-prod-flt pt) m

-- mult_mat: product of row matrix and column matrix
def matrix_mult_gen z m0 m1 =
  let m1t = transpose m1 in
  map (fun v -> map (dot-prod-flt v) m1t) m0 

-- diagonal_matrix_gen v: the diagonal matrix of vector v, with zero
-- elt z
def diagonal_matrix_gen z v = elim_list v
  [ ]
  (fun x diag -> (x :: (const-ls z (len diag))) :: (map (cons z) diag))

-- END: library code

-- BEGIN: application-specific code

-- m : user parameter: number of constraint parties
def m : nat
def m = 8n

-- n : user parameter: dimension of the constraint system
def n : nat
def n = 8n

-- Ctr[m]: parties that bring the constraints
principal Ctr[8]

-- party that provides the cost vector:
principal Cost

-- party that gets the output:
principal Out

-- comps: the parties that do computation, Ctr and Cost
-- def comps = set(Ctr,Cost)
def comps = { Ctr, Cost }

-- shr-w-comp: share data with the computation parties
def shr-w-comp sender x = share{ spdz : sender -> comps } x

-- shr0, shr1: shares of 0.0 and 1.0 between the computation parties
def shr0 = shr-w-comp { Cost } 0.0 
def shr1 = shr-w-comp { Cost } 1.0 
     
def iter_sec_nat_spdz muxer = iter_sec_nat muxer 

def iter_sec_nat_ls = iter_sec_nat_spdz mux_ls

-- matrix_mult: multiply matrices of SPDZ shares
def matrix_mult = matrix_mult_gen shr0 

-- matrix_vec_mult: multiply matrix and vector of SPDZ shares
def matrix_vec_mult = matrix_vec_mult_gen shr0 

-- dimensions_of m: dimensions of matrix m
def dimensions_of m = case m
  { [ ] -> (0n, 0n)
  ; rv :: m' -> (inc (len m'), len rv)
  }

-- nz_prod z u l: the product of non-z entries in l, with
-- multiplicative unit u
def nz_prod z one l = elim_list l
  one
  (fun x -> mult (mux-wrap (x == z) one x))

def nz_prod_vec = nz_prod shr0 shr1

def nz_prod_mat m = nz_prod_vec (map nz_prod_vec m)

-- diagonal_matrix v: diagonal matrix of vector of SPDZ shares v
def diagonal_matrix = diagonal_matrix_gen shr0

def zero_vec = const-ls shr0 

-- zero_pt: point of zero's
def zero_pt = zero_vec n

-- zero_mat: matrix of zeroes
def zero_mat n = elim_nat n
  [ ]
  (cons (zero_vec n))

-- range m n: the list of elements from m to n
def range m n =
  if n < m then [ ]
  else map (plus m)
    (elim_nat (n - m)
       [ 0n ]
       (fun rng -> snoc (len rng) rng) )

def matrix_get m (i, j) = get (get m i) j

def matrix_set m (i, j) v = upd m i (upd (get m i) j v)

-- Listing 9: Inverse of a lower triangular matrix
def matrix_inverse_lt l =
  let n = order l in -- order of L
  let l_inv = ref (zero_mat n) in -- n x n zero matrix
  do (iter (range 0n (n - 1n))
    (fun k ->
      -- For diagonal entries, take the reciprocal
      do l_inv := matrix_set !l_inv (k, k) (shr1 / (matrix_get !l_inv (k, k))) in

      -- For non-diagonal entries, solve L * L_inv = I
      iter (range (k + 1n) (n - 1n))
        (fun j ->
          let sum = ref shr0 in
          iter (range k (j - 1n))
            (fun i ->
              sum := !sum - (matrix_get l (j, i)) * (matrix_get !l_inv (i, k))
              ) ) ) ) in
  !l_inv


-- Listing 10: Cholesky decomposition of a positive definite Hermitian
-- matrix
def cholesky_decomposition m =
  -- Initialize variables
  let n = order m in -- order of m
  let l = ref (zero_mat n) in -- n x n zero matrix

  -- Calculate the top diagonal element of L
  do l := matrix_set !l (0n, 0n) (sqrt (matrix_get m (0n, 0n))) 

  -- Calculate the rest of the first column of L
  do iter (range 1n (n - 1n))
    (fun j ->
      l := matrix_set !l (j, 0n) ((matrix_get m (j, 0n)) / (matrix_get !l (0n, 0n)) ) )

  -- Iterate through the remaining columns
  do iter (range 1n (n - 1n))
    (fun i ->
      -- First calculate the diagonal element for this column
      let sum = ref shr0 in
      do iter (range 0n (i - 1n))
        (fun j ->
          sum := !sum + (matrix_get !l (i, j)) * (matrix_get !l (i, j)) ) 
      do l := matrix_set !l (i, i) (sqrt ((matrix_get m (i, i)) - !sum)) in
      -- Now fill in the remaining entries in this column
      if-then (i < n - 1n) 
        (iter (range (i + 1n) (n - 1n))
          (fun j ->
            do sum := shr0 in
            iter (range 0n (i - 1n))
              (fun k ->
                sum := !sum + (matrix_get !l (i, k)) * (matrix_get !l (j, k)) ) ) ) ) in
    !l

-- Listing 8: Inverse of a positive definite Hermitian matrix
def matrix_inverse_pdh : num -> matrix -> matrix
def matrix_inverse_pdh m =
  let l = cholesky_decomposition m in
  let l_inv = matrix_inverse_lt l in -- Invert the lower-triangular matrix
  let m_inv = matrix_mult (transpose l_inv) l_inv in
  m_inv

-- Listing 6: Iteration for Karmarkar's Algorithm
def karmarkar_iteration initial_point a c =
  let (m, n) = dimensions_of a in
  -- D is a matrix of zeros with the values of initial_point on the
  -- diagonal
  -- Dimensions of D: n x n
  let d = diagonal_matrix initial_point in
  -- Dimensions of cprime: n x 1
  let cprime = matrix_vec_mult d c in
  -- Dimensions of AD: m x n
  let ad = matrix_mult a d in

  -- Construct B
  -- Dimensions of B: (m + 1) x n
  let b = append ad [ row_of_ones n ] in -- append a row of ones onto AD

  -- Dimensions of BBT: (m + 1) x (m + 1)
  let bbt = matrix_mult b (transpose b) in

  -- Dimensions of BBTInv: (m + 1) x (m + 1)
  let bbtinv = matrix_inverse_pdh bbt in

  -- Project C onto B's nullspace
  -- Dimensions of cp: n x 1
  let cp = minus-vecs cprime
    (matrix_vec_mult (transpose b)
      (matrix_vec_mult bbtinv
        (matrix_vec_mult b cprime) ) ) in

  -- Calculate a unit vector of cp
  -- Dimensions of unitcp: n x 1
  let unit_cp =
    mux_ls (eq-vecs cp zero_pt) -- If cp is the zero vector
      -- If cp is the zero vector, assign it to be 0
      zero_pt
      (div_vec zero_pt (l2norm shr0 cp)) in

  -- Take a step of 1/3n in the direction of -cp, row_of_ones(n)/n is
  -- the "transformed" initial point
  -- Dimensions of bprime: n x 1
  let bprime = minus-vecs
    (div_vec (row_of_ones n) (to_flt n))
    (scalar_vec_mult (1.0 / (3.0 * (to_flt n))) unit_cp) in

  -- Transform the point back
  -- Dimensions of b: n x 1
  let b = div_vec (matrix_vec_mult d bprime)
    (dot-prod-flt (row_of_ones n) (matrix_vec_mult d bprime)) in
  b

-- Listing 7: Loop for Karmarkar's Algorithm
def karmarkar_loop a c =
  let (m, n) = dimensions_of a in
  -- Epsilon is the stopping condition. This value should be close to
  -- 0, so we choose 10^(-8)
  let epsilon = 10.0 ^ -8.0 in

  -- x is our initial point
  let x = ref (div_vec (row_of_ones n) (to_flt n)) in

  -- product of non-zero entries in c and A
  let p = (nz_prod_vec c) * (nz_prod_mat a) in
  let l = (m + 1n) * n +
    (magn (ceil (log_2_real (abs-val-flt-shr p)))) +
    n * (magn (ceil (log_2_real (to_flt n)))) in
  let max_iterations = 12n * n * l in

  -- If this initial point is an optimal solution, return
  mux_ls ((dot-prod-flt c !x) < epsilon) !x
  -- hand-computed bound
  (iter_sec_nat_ls max_iterations 1n (fun i -> 
    let x_new = karmarkar_iteration !x a c in cont_seq'

    -- if we are within the stopping condition in the current
    -- iteration, return
    (if-then-ret-ls 
      ((((dot-prod-flt c !x) - (dot-prod-flt c x_new)) /
         (max-muxable shr1 (dot-prod-flt c !x)) ) < epsilon )
      x_new)
    (x := x_new) )
  x)

-- main: entry point; Ctr, Cost read inputs and run the algorithm,
-- distributes results to Out
def main : unit ->{ inp : Ctr, Cost; rev : Out } (list out_sec)
def main () =
  -- read_vec: reads an input vector on a principal's machine
  -- let read_vec = fun () -> read (list flt) "in.txt" in
  -- TODO: replace with file input
  let read_vec = fun () -> [ 1.0 ; 2.0; 3.0; 4.0; 5.0; 6.0; 7.0; 8.0 ] in 

  -- FANCY MPC: Ctr and Cost send the data in the list to Out. This
  -- may change if the PSL model of isec's changes as a result of
  -- issue #31
  let soln = par { Ctr, Cost, Out } (map
    (reveal-wrap { Out })
    -- Cost reveals the structure of the list to out:
    (send-ls { Cost } { Ctr, Cost, Out }
      -- Ctr and Cost compute the solution point:
      (par { Ctr, Cost } karmarkar_loop
        -- read in the matrix of constraints and share them
        (fold-f
          [ ]
          (fun Q ctr -> cons (map (shr-w-comp { Q }) (send-ls { Q } comps ctr)))
          (solo { Ctr } as c in read_vec ()) )
        -- read in the vector of costs and share them
        (map (shr-w-comp { Cost })
          (send-ls { Cost } comps (par { Cost } read_vec ())) ) ) ) ) in
  -- Ctr and Cost forget the structure of the solution
  par { Out } send-ls { Out } { Out } soln
