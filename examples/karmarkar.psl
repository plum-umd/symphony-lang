-- party that provides the constraint:
principal Ctr

-- party that provides the cost vector:
principal Cost

-- reals: IEEE64
def real : type
def real = float[64]

-- PSL: BEGIN ops that need to be supported
def realneg1 : real

-- ceil x: the ceiling of x
def ceil : real -> int

-- exponentiation: exp a b: a^b
def exp : real -> real -> real

-- logarithms: log b x: the log of x, base b
def log : real -> real -> real

-- nat_to_real n: conversion of n into a real:
def nat_to_real : nat -> real

-- PSL: END ops that need to be supported

-- ctr: the type of constraints
def ctr : type
def ctr = list (real{ sec : Ctr })

-- costs: the type of cost vectors:
def costs : type
def costs = list (real{ sec : Cost })

-- dim: an additive secret share of a dimension in a point
def dim : type
def dim = real{ ashare : Ctr, Cost }

-- mk_dim: lift a plain real value into a secret share
def mk_dim : real -> dim
def mk_dim x = share{ ashare : Ctr, Cost } x

-- point: a point the dimensional space of a constraint
def point : type 
def point = list dim

-- shrRealMat: a matrix of additive shares of reals
def shrRealMat : type
def shrRealMat = list point

-- party that gets the output:
principal Out

-- abs x: absolute value of x
def abs : real -> real
def abs x =
  if x < 0 then realneg1 * x
  else x

-- const_vector t a n: a vector of constant a of size n
def const_vector : real -> nat -> list real
def const_vector x n =
  let const_vec_rec m =
    if m == 0 then [ ]
    else x :: (const_vec_rec (m - 1)) in
  const_vec_rec n

-- foldr: right fold
def foldr : list t -> acc -> (t -> acc -> acc) -> acc
def foldr l acc f = case l
{ [ ] -> acc
; x :: l' -> f x (foldr l' acc f)
}

-- map: map for the list functor
def map : (t -> u) -> list t -> list u
def map f l = foldr l [ ] (\c x l' -> (f x) :: l')

-- point_div x pt: divide each entry in pt by x
def point_div : real{ ashare : Ctr, Cost } -> point -> point
def point_div x = map (\f a -> mpc{yao: Ctr, Cost} (a / x)) pt

-- vec_div: divide a vector by a constant
def vec_div : real -> list real -> list real
def vec_div a = map (\f x -> x / a)

-- nzProd a: the product of all non-zero entries in a vector:
def nzProd : list (real{ sec : p }) -> real{ sec : p }
def nzProd l = foldr l
  (mk_dim 1.0)
  (\f x acc -> if x == 0 then acc else x * acc)

-- zip pt0 pt1: the zip of points p0 and p1
def zip_points : point -> point -> list (dim * dim)
def zip_points l0 l1 = case (l0, l1)
{ [ ], _ -> [ ]
; _, [ ] -> [ ]
; d0 :: l0', d1 :: l1' -> (d0, d1) :: (zip_points l0' l1')
}

-- pt_diff: subtract one point from another
def pt_diff : point -> point -> point
def pt_diff pt0 pt1 = map
  (\f (p0, p1) -> p0 - p1)
  (zip_points pt0 pt1)

-- shr_dot_prod: take the dot product of two points
def shr_dot_prod : point -> point -> dim
def shr_dot_prod p0 p1 = foldr
  (map (\f (p0, p1) -> p0 * p1) (zip_points p0 p1))
  (mk_dim (nat_to_float 0))
  (\f d acc -> d * acc)

-- pt_cost : evaluate the cost of a point
def pt_cost : costs -> point -> dim
def pt_cost c = shr_dot_prod
  (map (\f x -> share{ ashare : Ctr, Cost } x) c)

-- l2norm v: the L2 norm of real vector v
def l2norm : point -> dim
-- BILL: define

-- zeros_vec: a vector of zeroes
def zeros_vec : nat -> list real
def zeros_vec = const_vector (nat_to_real 0) 

-- onesVec: a vector of real ones
def onesVec : nat -> list real
def onesVec = const_vector (nat_to_real 1) 

-- onesRowVec: a row vector of real ones
def onesRowVec : nat -> list real
def onesRowVec = onesVec

-- diagonal_matrix p: the diagonal matrix of a point
def diagonal_matrix : point -> shrRealMat
-- BILL: define

-- prod_mat: product of matrices of shares
def prod_mat : shrRealMat -> shrRealMat -> shrRealMat
-- BILL: define

-- prod_mat_pt : multiply a matrix of shares and a point
def prod_mat_pt : shrRealMat -> point -> point
-- BILL: define

-- n : parameter: dimension of constraint system
def n : nat
-- BILL: define

-- m : number of constraint parties
def m : nat
def m = 1

-- karmarkar_iter: an iteration of Karmarkar's algorithm for exactly
-- one constraint

def karmarkar_iter : point -> ctr -> cost -> point
def karmarkar_iter init_pt a cost =
  -- d: the diagonal matrix of the initial point. For n = 1, just the
  -- initial point.
  let d : shrRealMat = diagonal_matrix init_pt in

  -- vectors of constants:
  let nOnesVec : list real = onesVec n in
  let nOnesRow : list real = onesRowVec n in

  let unit_cp : point =
    let c' : point = prod_mat_pt d c in
    -- construct the B matrix
    -- TODO: translate defns of b and cp to PSL
    let b = append_row (prod_mat a d) nOnesRow in
    -- project c onto b's nullspace
    let cp : point = pt_diff c'
             (b *m
              (inverse (b *m a)) *m
              prod_mat_pt b c') in
    -- test if the projection is the 0 vector:
    -- TODO: which types get equality operations for free?
    if cp == (zeros_vec n) then 0
    else point_div (l2norm cp) cp in

  -- take a step of 1/3 n in the direction of cp
  -- TODO: does 3 have to be cast to a real explicitly?
  let b' : point = point_diff
    (map (\f -> share{ ashare : Ctr, Cost})
      (vec_div (nat_to_real n) nOnesVec))
    (point_div (share{ ashare : Ctr, Cost } 3)) unit_cp in

  point_div
    (shr_dot_prod
      (map (\f -> share{ ashare : Ctr, Cost} f) nOnesRow)
      (prod_mat_pt d b'))
    (prod_mat_pt d b')

-- Karmarkar's algorithm:

-- TODO: this gets messier as we add more constraint parties. Can we
-- keep the code generic by having a matrix be a list of list of
-- reals that are secret to distinct parties?
def karmarkar_loop : ctr -> costs -> point
def karmarkar_loop a cost =
  -- eps: defines the stopping condition for the loop. Constant
  -- comes from the GFI:
  let eps = exp 10 (~8) in

  -- init_pt: the initial point:
  let init_pt = vec_div (nat_to_real n) (onesRowVec n) in

  -- if the initial point is optimal, then return it:
  -- TODO: decide if this conditional check should actually be
  -- included
  if (pt_cost cost init_pt) == 0 then init_pt
  else
    -- karmarkar_rec: recurse on the number of iterations:
    let karmarkar_rec (x : point) (i : nat) = case i 
      -- TODO: can we pattern match on nats? If so, what are the
      -- patterns?
      { 0 -> x ;
        S i' ->
          -- x': the updated point
          let x' : point = karmarkar_iter x a cost in
          -- score: score at the previous point:
          let stop : bool{ ashare : Ctr, Cost } =
            let score : real{ ashare : Ctr, Cost } = pt_cost cost x in
            mpc{ yao : Cost, Ctr }
              (score - (pt_cost cost x')) / (max 1 score) < eps in
          -- TODO: decide if this conditional check should be included
          if stop then x'
          else karmarkar_rec x' i'
      }

    karmarkar_rec
      (share{ ashare : Ctr, Cost } init_pt)
      (-- p: product of non-zero entries in cost and A:
       let p : real{ sec : Ctr, Cost } =
         reveal{ Ctr, Cost } (mpc{ yao : Cost, Ctr }
          (par{ Cost }(nzProd cost)).Cost *
          (par{ Ctr }(nzProd ctr))).Ctr in

       -- TODO: how do we use reveal to make a value public? Is no
       -- qualifier just a shorthand for all principals?
       reveal{ Ctr, Cost, Out } (mpc{ yao : Cost, Ctr }
         (12 * n *
          ((m + 1) * n +
           (ceil (log 2 (abs p))) +
           n * (ceil (log 2 (nat_to_real n)))))
       )
      )

-- main:
def main : unit ->{ inp: Ctr, Cost; rev : Out } (list real{ ssec: Out })
def main () =
  -- constraint and cost parties read in their input vectors:
  -- BILL: replace this with something that iterates on dimension
  let vec = { par: Ctr, Cost } read (list real) in

  -- TODO: is the dot access construct in the docs?
  karmarkar_loop vec.Ctr vec.Cost

  -- TODO: is the reveal construct in the docs?
  map (\(r : real{ ashare : Ctr, Cost } ) -> reveal{ Out } r)
    (karmarkar_loop n vec.Ctr vec.Cost)
