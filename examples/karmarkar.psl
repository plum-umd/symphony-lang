-- party that provides the constraint:
principal Ctr[8]

-- party that provides the cost vector:
principal Cost

-- reals: IEEE64
def real : type
def real = float[64]

-- PSL: BEGIN ops that need to be supported
def realneg1 : real

-- ceil x: the ceiling of x
def ceil : real -> int

-- exponentiation: exp a b: a^b
def exp : real -> real -> real

-- logarithms: log b x: the log of x, base b
def log : real -> real -> real

-- nat_to_real n: conversion of n into a real:
def nat_to_real : nat -> real

def bgw_sqrt : real{ ashare : Ctr, Cost } -> real{ ashare : Ctr, Cost }

-- PSL: END ops that need to be supported

-- ctr: the type of constraints. An independent secret vector.
def ctr : type
def ctr = list (real{ isec : Ctr })

-- costs: the type of cost vectors:
def costs : type
def costs = list (real{ sec : Cost })

-- all_sec: an additive secret share between all parties
def all_sec : type
def all_sec = real{ ashare : Ctr, Cost }

-- out_sec: a secret known only to the output party
def out_sec: type
def out_sec = real{ ssec : Out }

-- mk_all_sec: lift a plain real value into a secret share
def mk_all_sec : real -> all_sec
def mk_all_sec x = share{ ashare : Ctr, Cost } x

-- point: a point the all_secensional space of a constraint
def point : type 
def point = list all_sec

-- secretMat: a matrix of additive shares of reals
def secretMat : type
def secretMat = list point

-- party that gets the output:
principal Out

-- abs x: absolute value of x
def abs : real -> real
def abs x =
  if x < 0 then realneg1 * x
  else x

-- const_vector t a n: a vector of constant a of size n
def const_vec : t -> nat -> list t
def const_vec c n =
  if n == 0 then [ ]
  else c :: (const_vec (m - 1)) 

-- foldr: right fold
def foldr : list t -> acc -> (t -> acc -> acc) -> acc
def foldr l acc f = case l
{ [ ] -> acc
; x :: l' -> f x (foldr l' acc f)
}

-- map: map for the list functor
def map : (t -> u) -> list t -> list u
def map f l = foldr l [ ] (\c x l' -> (f x) :: l')

-- len l: the length of list l
def len : list t -> nat
def len l = case l
{ [ ] -> 0
; _ :: l' -> 1 + (len l')
}

-- point_div x pt: divide each entry in pt by x
def point_div : real{ ashare : Ctr, Cost } -> point -> point
def point_div x = map (\f a -> mpc{bgw: Ctr, Cost} (a / x)) pt

-- PSL: are mpc annotations actually needed now? They don't occur in
-- the current version of ATQ.

-- PSL: bgw is just a standin for SPDZ, which is the protocol
-- specified in the GFI

-- vec_div: divide a vector by a constant
def vec_div : real -> list real -> list real
def vec_div a = map (\f x -> x / a)

-- nzProd a: the product of all non-zero entries in a vector:
def nzProd : list (real{ sec : p }) -> real{ sec : p }
def nzProd l = foldr l
  (mk_all_sec 1.0)
  (\f x acc -> if x == 0 then acc else x * acc)

-- zip_lists pt0 pt1: the zip of points p0 and p1
def zip_lists : list t -> list u -> list (t * u)
def zip_lists l0 l1 = case (l0, l1)
{ [ ], _ -> [ ]
; _, [ ] -> [ ]
; d0 :: l0', d1 :: l1' -> (d0, d1) :: (zip_lists l0' l1')
}

-- pt_diff: subtract one point from another
def pt_diff : point -> point -> point
def pt_diff pt0 pt1 = map
  (\f (p0, p1) -> p0 - p1)
  (zip_lists pt0 pt1)

-- pt_dot_prod: take the dot product of two points
def pt_dot_prod : point -> point -> all_sec
def pt_dot_prod p0 p1 = foldr
  (map (\f (p0, p1) -> p0 * p1) (zip_lists p0 p1))
  (mk_all_sec 0.0)
  (\f d acc -> d + acc)

-- pt_cost : evaluate the cost of a point
def pt_cost : costs -> point -> all_sec
def pt_cost c = pt_dot_prod (map mk_all_sec c)

-- sqrt: square root
def sqrt : all_sec -> all_sec
def sqrt x = bgw_sqrt x 

-- square x: the square of a secret real
def square : all_sec -> all_sec
def square x = x * x

-- sum: sum of a list of secret reals
def sum : point -> all_sec
def sum pt = fold pt (mk_all_sec 0.0) (\f x acc -> x + acc)

-- l2norm v: the L2 norm of real vector v
def l2norm : point -> all_sec
def l2norm pt = sqrt (sum (map square pt))

-- zeros_vec: a vector of zeroes
def zeros_vec : nat -> list real
def zeros_vec = const_vec 0.0

-- onesVec: a vector of real ones
def onesVec : nat -> list real
def onesVec = const_vec 1.0

-- onesRowVec: a row vector of real ones
def onesRowVec : nat -> list real
def onesRowVec = onesVec

-- shift_major: shift matrix between row major and column major order
def shift_major : nat -> secretMat -> secretMat
def shift_major c m = case m
{ [ ] -> const_vec [ ] c
; v :: m' -> map (\c x cv -> x :: cv) (zip_lists v (shift_major m'))
}

-- n : parameter: dimension of constraint system
def n : nat
def n = 1

  -- vectors of constants:
def nOnes : list real
def nOnes = const_vec 1.0 n

-- m : number of constraint parties
def m : nat
def m = 1

-- row_major: put given matrix in row-major order
def row_major : secretMat -> secretMat
def row_major = shift_major m

-- col_major: put given matrix in column-major order
def col_major : secretMat -> secretMat
def col_major = shift_major n

-- diagonal_matrix p: the diagonal matrix of a point
def diagonal_matrix : point -> secretMat
def diagonal_matrix pt = foldr pt
  [ ]
  (\f d m' ->
    let n' = len pt' in
    (d :: (zeros_vec n')) :: (row_major
      ((zeros_vec n')) :: (col_major (diagonal_matrix pt')))
  )

-- prod_mat_pt : multiply a matrix of secrets and a point
def prod_mat_pt : secretMat -> point -> point
def prod_mat_pt m pt = foldr pt
  [ ]
  (\f v p -> (map (\g -> pt_dot_prod v) m1) :: p)

-- prod_mat: product of matrices of secrets
def prod_mat : secretMat -> secretMat -> secretMat
def prod_mat m0 m1 = row_major
  (foldr (col_major m1)
     [ ]
     (\f c m' -> (prod_mat_pt m0 c) :: m')
  )

-- shr_cost: share a (secret) cost among all non-output parties
def shr_cost : real{ ssec : Cost } -> all_sec
def shr_cost x = share{ bgw : Ctr, Cost } x

-- combine: all of the Ctr parties share their constraints as a matrix
def combine : ctr -> secretMat
-- BILL: implement 

-- karmarkar_iter: an iteration of Karmarkar's algorithm for exactly
-- one constraint
def karmarkar_iter : point -> ctr -> cost -> point
def karmarkar_iter init_pt cs cost =
  -- d: the diagonal matrix of the initial point
  let d = diagonal_matrix init_pt in

  let unit_cp =
    let c' = prod_mat_pt d (map shr_cost cost) in
    -- construct the B matrix
    -- BILL: translate defns of b and cp to PSL
    let a = combine cs in
    let b = append_row (prod_mat a d) nOnes in
    -- project c onto b's nullspace
    let cp = pt_diff c'
             (b *m
              (inverse (b *m a)) *m
              prod_mat_pt b c') in
    -- test if the projection is the 0 vector:
    -- TODO: which types get equality tests for free?
    if cp == (zeros_vec n) then 0
    else point_div (l2norm cp) cp in

  -- take a step of 1/3 n in the direction of cp
  let b' : point = point_diff
    (map (\f -> share{ ashare : Ctr, Cost})
      (vec_div (nat_to_real n) nOnes))
    (point_div (share{ ashare : Ctr, Cost } 3.0)) unit_cp in

  point_div
    (pt_dot_prod
      (map (\f -> share{ ashare : Ctr, Cost} f) nOnes)
      (prod_mat_pt d b'))
    (prod_mat_pt d b')

-- Karmarkar's algorithm, main loop:

def karmarkar_loop : ctr -> costs -> point
def karmarkar_loop a cost =
  -- eps: defines the stopping condition for the loop. Constant
  -- comes from the GFI:
  let eps = exp 10.0 (~8.0) in

  -- init_pt: the initial point:
  let init_pt = vec_div (nat_to_real n) nOnes in

  -- if the initial point is optimal, then return it:
  -- TODO: decide if this conditional check should actually be
  -- included
  if (pt_cost cost init_pt) == 0 then init_pt
  else
    -- karmarkar_rec: recurse on the number of iterations, which is
    -- pre-computed from the constraints and costs:
    let karmarkar_rec = \kr x i ->
      if i == 0 then x
      else 
          -- x': the updated point
          let x' = karmarkar_iter x a cost in
          let stop =
            let score = pt_cost cost x in
            mpc{ bgw : Cost, Ctr }
              (score - (pt_cost cost x')) / (max 1 score) < eps in
          -- TODO: this conditional check could be safely ommitted
          if stop then x'
          else kr x' (i - 1)

    karmarkar_rec
      (map mk_all_sec init_pt)
      (let p = -- p: product of non-zero entries in cost and constraints:
         reveal{ Ctr, Cost } (mpc{ bgw : Cost, Ctr }
          (par{ Cost }(nzProd cost)).Cost *
          (par{ Ctr }(nzProd ctr))).Ctr in

       -- TODO: is there a designated party list called all?
       reveal{ Ctr, Cost, Out } (mpc{ bgw : Cost, Ctr }
         (12 * n *
          ((m + 1) * n +
           (ceil (log 2.0 (abs p))) +
           n * (ceil (log 2.0 (nat_to_real n)))))
       )
      )

-- main:
def main : unit ->{ inp: Ctr, Cost; rev : Out } (list out_sec)
def main () =
  -- constraint and cost parties read in their input vectors:
  let vec = { par: Ctr, Cost } read (list real) in

  -- BILL: strengthen to check that length of each read constraint is
  -- n
  map (\f x -> reveal{ Out } x)
    (karmarkar_loop n vec.Ctr vec.Cost)
