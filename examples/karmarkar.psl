-- party that provides the constraint:
principal Ctr[8]

-- party that provides the cost vector:
principal Cost

-- reals: IEEE64
def real : type
-- def real = float[64]
-- PSL: support type aliasing

-- PSL: BEGIN ops that need to be supported

-- int_to_nat i: the magnitude of i and whether it was positive
def abs : int -> nat * bool

-- ceil x: the ceiling of x
def ceil : real -> int

-- exponentiation: exp a b: a^b
def exp : real -> real -> real

-- nat_to_real n: conversion of n into a real:
def nat_to_real : nat -> real

def bgw_sqrt : real{ bgw : Ctr, Cost } -> real{ bgw : Ctr, Cost }

-- PSL: support SPDZ as a protocol

-- PSL: END ops that need to be supported

-- ctr: the type of constraints. An independent secret vector.
def ctr : type
-- def ctr = list (real{ isec : Ctr })

-- costs: the type of cost vectors:
def costs : type
-- def costs = list (real{ ssec : Cost })

-- comp_shr: a real secret-shared between all compute parties
def comp_shr : type
-- def comp_shr = real{ bgw : Ctr, Cost }

def comp_shr_bool : type
def comp_shr_bool = bool{ bgw: Ctr, Cost }

-- out_sec: a secret known only to the output party
def out_sec : type
-- def out_sec = real{ ssec : Out }

-- shr_cost_w_comp: 
def shr_cost_w_comp : real{ ssec : Cost } -> comp_shr
def shr_cost_w_comp x = share{ bgw : Ctr, Cost } x

def shr_ctr_w_comp : real{ bgw : Ctr } -> comp_shr
def shr_cost_w_comp x = share{ bgw : Ctr, Cost } x

-- shr_pub_w_comp: make shares of a public real
def shr_pub_w_comp : real -> comp_shr
def shr_pub_w_comp x = share{ bgw : Ctr, Cost } x

-- public_bool: booleans known to everyone
def public_bool : type
def public_bool = bool{ ssec: Ctr, Cost, Out }

-- release_bool: publicly reveal a bool shared between all compute
-- parties
def release_bool : comp_shr_bool -> public_bool
def release_bool x = reveal{ Ctr, Cost, Out } x

-- public_nat: nats known to everyone
def public_nat : type 
def public_nat = nat{ ssec: Ctr, Cost, Out }

-- release_bool: publicly reveal a nat shared between all compute
-- parties
def release_nat : comp_shr_nat -> public_nat
def release_nat n = reveal{ ssec: Ctr, Cost, Out } n

-- point: a point the comp_shrensional space of a constraint
def point : type 
-- def point = list comp_shr

-- secretMat: a matrix of additive shares of reals
def secretMat : type
-- def secretMat = list point

-- party that gets the output:
principal Out

-- id: the identity function
def id : t -> t
def id x = x

-- compose: function composition
def compose : (t0 -> t1) -> (t1 -> t2) -> (t0 -> t2)
def compose f g = \h x -> g (f x)

-- elim_nat: form for iterating over nats
def elim_nat : nat -> t -> (t -> t) -> t
def elim_nat n z s =
  if n == 0 then z
  else s (elim_nat (n - 1) z s)

-- const_vec t a n: a vector of constant a of size n
def const_vec : t -> nat -> list t
def const_vec c n = elim_nat n [ ] (\s l -> c :: l)

-- foldr: right fold
def foldr : list t -> acc -> (t -> acc -> acc) -> acc
def foldr l acc f = case l
{ [ ] -> acc
; x :: l' -> f x (foldr l' acc f)
}

-- len l: the length of list l
def len : list t -> nat
def len l = foldr l 0 (\a x acc -> 1 + acc)

-- map: map for the list functor
def map : (t -> u) -> list t -> list u
def map f l = foldr l [ ] (\c x l' -> (f x) :: l')

-- zip_lists pt0 pt1: the zip of points p0 and p1
def zip_lists : list t -> list u -> list (t * u)
def zip_lists l0 l1 = case (l0, l1)
{ [ ], _ -> [ ]
; _, [ ] -> [ ]
; d0 :: l0', d1 :: l1' -> (d0, d1) :: (zip_lists l0' l1')
}

-- point_div x pt: divide each entry in pt by x
def point_div : comp_shr -> point -> point
def point_div x = map (\f a -> a / x) pt

-- vec_div: divide a vector by a constant
def vec_div : real -> list real -> list real
def vec_div a = map (\f x -> x / a)

-- nzProd a: the product of all non-zero entries in a vector:
def nzProd : list (real{ ssec : p }) -> real{ ssec : p }
def nzProd l = foldr l
  (shr_pub_w_comp 1.0)
  (\f x acc -> if x == 0.0 then acc else x * acc)

-- pt_diff: subtract one point from another
def pt_diff : point -> point -> point
def pt_diff pt0 pt1 = map
  (\f (p0, p1) -> p0 - p1)
  (zip_lists pt0 pt1)

-- pt_dot_prod: take the dot product of two points
def pt_dot_prod : point -> point -> comp_shr
def pt_dot_prod p0 p1 = foldr
  (map (\f (p0, p1) -> p0 * p1) (zip_lists p0 p1))
  0.0
  (\f d acc -> d + acc)

-- pt_cost : evaluate the cost of a point
def pt_cost : costs -> point -> comp_shr
def pt_cost c = pt_dot_prod (map shr_costs_w_comp c)

-- pub_pt_cost: evaluate the cost of a public point
def pub_pt_cost : costs -> list real -> real{ ssec : Cost }
def pub_pt_cost costs pt = foldr
  (map
    (\f (c, p) -> par{ Cost } c0 * p0)
    (zip_lists costs pt))
  0.0
  (\f d acc -> par{ Cost } d + acc)

-- sum: sum of a list of secret reals
def sum : point -> comp_shr
def sum pt = fold pt (shr_pub_w_comp 0.0) (\f x acc -> x + acc)

-- l2norm v: the L2 norm of real vector v
def l2norm : point -> comp_shr
def l2norm pt = bgw_sqrt (sum (map (\sq x -> x * x) pt))

-- PSL: what's the type of a constant?

-- zeros_vec: a vector of zeroes
def zeros_vec : nat -> list real
def zeros_vec = const_vec 0.0

-- onesVec: a vector of real ones
def onesVec : nat -> list real
def onesVec = const_vec 1.0

-- shift_major: shift matrix between row major and column major order
def shift_major : nat -> secretMat -> secretMat
def shift_major c m = case m
{ [ ] -> const_vec [ ] c
; v :: m' -> map (\c x cv -> x :: cv) (zip_lists v (shift_major m'))
}

-- n : parameter: dimension of constraint system
def n : nat
def n = 1

-- vectors of constants:
def nOnes : list real
def nOnes = const_vec 1.0 n

-- m : number of constraint parties
def m : nat
def m = 1

-- row_major: put given matrix in row-major order
def row_major : secretMat -> secretMat
def row_major = shift_major m

-- col_major: put given matrix in column-major order
def col_major : secretMat -> secretMat
def col_major = shift_major n

-- diagonal_matrix p: the diagonal matrix of a point
def diagonal_matrix : point -> secretMat
def diagonal_matrix pt = foldr pt
  [ ]
  (\f d m' ->
    let n' = len pt' in
    (d :: (zeros_vec n')) :: (row_major
      ((zeros_vec n')) :: (col_major (diagonal_matrix pt')))
  )

-- prod_mat_pt : multiply a matrix of secrets and a point
def prod_mat_pt : secretMat -> point -> point
def prod_mat_pt m pt = foldr pt
  [ ]
  (\f v p -> (map (\g -> pt_dot_prod v) m1) :: p)

-- prod_mat: product of matrices of secrets
def prod_mat : secretMat -> secretMat -> secretMat
def prod_mat m0 m1 = row_major
  (foldr (col_major m1)
     [ ]
     (\f c m' -> (prod_mat_pt m0 c) :: m')
  )

-- shr_cost: share a (secret) cost among all non-output parties
def shr_cost : real{ ssec : Cost } -> comp_shr
def shr_cost x = share{ bgw : Ctr, Cost } x

-- combine: all of the Ctr parties share their constraints as a matrix
def combine : ctr -> secretMat
-- BILL: implement 

def all_true : list public_bool -> public_bool
def all_true l = foldr l true (\a x acc -> x && acc)

def max : comp_shr -> comp_shr -> comp_shr_bool
def max m n = if m < n then n else m

-- is_zero_vec v: test if v is the vector of shares of 0
def is_zero_vec : point -> public_bool
def is_zero_vec p = all_true
  (map
    (\f x -> release_bool (x == (shr_pub_w_comp 0.0)))
    p)

-- karmarkar_iter: an iteration of Karmarkar's algorithm for exactly
-- one constraint
def karmarkar_iter : ctr -> cost -> point -> point
def karmarkar_iter cs cost init_pt =
  -- d: the diagonal matrix of the initial point
  let d = diagonal_matrix init_pt in

  let unit_cp =
    let c' = prod_mat_pt d (map shr_cost cost) in
    -- construct the B matrix
    -- BILL: translate defns of b and cp to PSL
    let a = combine cs in
    -- BILL: define append_row
    let b = append_row (prod_mat a d) nOnes in
    -- project c onto b's nullspace
    let cp = pt_diff c'
             (b *m
              (inverse (b *m a)) *m
              prod_mat_pt b c') in
    -- test if the projection is the 0 vector:
    if is_zero_vec cp then const_vec 0.0 n
    else point_div (l2norm cp) cp in

  -- take a step of 1/3 n in the direction of cp
  let b' = point_diff
    (map shr_pub_w_comp (vec_div (nat_to_real n) nOnes))
    (point_div (shr_pub_w_comp (nat_to_real (3 * n))) unit_cp) in

  point_div
    (pt_dot_prod
      (map shr_pub_with_comp nOnes)
      (prod_mat_pt d b'))
    (prod_mat_pt d b')

-- Karmarkar's algorithm, main loop:

def nat_exp : nat -> nat -> nat
def nat_exp b a = elim_nat b 1 (\s acc -> a * acc)

-- nat_log: logarithm over nats
def nat_log : nat -> nat -> nat
def nat_log b n =
  if n == 1 then 0
  else 1 + (nat_log b (n / 2))

def log_2_ceil : nat -> nat
def log_2_ceil n = 
  let n' = log 2 n in
  let offset = 
    if n == (nat_exp 2 n') then 0
    else 1 in
  n' + offset

def karmarkar_loop : ctr -> costs -> point
def karmarkar_loop a cost =
  -- eps: defines the stopping condition for the loop. Constant
  -- comes from the GFI:
  let eps = exp 10.0 (-8.0) in

  -- init_pt: the initial point:
  let init_pt = vec_div (nat_to_real n) nOnes in
  let shr_init = map shr_pub_w_comp init_pt in

  -- if the initial point is optimal, then return it:
  if shr_cost ((pub_pt_cost cost init_pt) == 0.0) then shr_init
  else
    -- karmarkar_rec: recurse on the number of iterations, which is
    -- pre-computed from the constraints and costs:
    let karmarkar_rec = elim_nat 
      (let nzCostsProd = foldr l
         1.0 
         (\f x acc -> if x == 0.0 then acc else x * acc) in
       let nzCtrProd =
         -- nzs: real{ isec : Ctr }: product of all non-zero entries in
         -- each constraint
         let nzs = par{ Ctr } 
           (foldr a
             1.0
             (\f x acc -> if x == 0.0 then acc else x * acc)) in
         prin_fold{ Ctr }
           (shr_pub_w_ctrs 1.0)
           (\acc -> (share{ bgw : Ctr } nzs) * acc) in
       12 * n *
        ((m + 1) * n +
         (log_2_ceil (abs (ceil (release_nat (
           (shr_cost_w_comp nzCostsProd) *
           (shr_ctr_w_comp nzCtrProd)))))) +
         n * (log_2_ceil n))
      )
      id
      (\f kr x ->
        let x' = karmarkar_iter a cost x in
        let stop =
          let score = pt_cost cost x in
          -- BILL: fix max
            (score - (pt_cost cost x')) / (max (1.0) score) < eps in
        if stop then x'
        else kr x') in

    -- compute from the initial point:
    karmarkar_rec shr_init

-- main:
def main : unit ->{ inp: Ctr, Cost; rev : Out } (list out_sec)
def main () =
  -- each constraint party reads its input vector
  let c = { par: Ctr } read (list real) in
  
  -- the cost party reads its input vector
  let cost = { par: Cost } read (list real) in

  -- BILL: strengthen to check that length of each read constraint is
  -- n
  map (\f x -> reveal{ Out } x) (karmarkar_loop c cost)
