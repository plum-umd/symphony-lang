principal A
principal B

def split : list (ℤ⟨A,B⟩) → list (ℤ⟨A,B⟩) × list (ℤ⟨A,B⟩)
def split = rλ rec xs → case xs
  { [] → [] , []
  ; x∷[] → [] , x∷[]
  ; x₁∷x₂∷xs →
      let xs₁,xs₂ = split xs in
      x₁∷xs₁ , x₂∷xs₂
  }

def merge : 
    CIR{bool:A,B} list (ℤ[gmw:A,B]) 
  → CIR{bool:A,B} list (ℤ[gmw:A,B]) 
  → CIR{bool:A,B} list (ℤ[gmw:A,B])
def merge = rλ rec xs → λ ys → circuit 
  case ⌊xs⌋,⌊ys⌋
  { [] , _ → ys
  ; _ , [] → xs
  ; x∷xs′ , y∷ys′ →
      -- x :[cir] ℤ[gmw:A,B]
      -- y :[cir] ℤ[gmw:A,B]
      -- xs′ :[cir] list (ℤ[gmw:A,B])
      -- ys′ :[cir] list (ℤ[gmw:A,B])
      let z,zs₁,zs₂ =
        if x ≤ y
        then x,xs′,ys
        else y,xs,ys′
      in
      z∷⌊rec ⌈z⌉ ⌈zs₁⌉ ⌈zs₂⌉⌋
  }

def merge-sort : list (ℤ⟨A,B⟩) → CIR{bool:A,B} list (ℤ[gmw:A,B])
def merge-sort = rλ rec xs → case xs 
  { [] → circuit []
  ; x∷[] → circuit 
      if x⟨A⟩ ≤ x⟨B⟩ 
      then x⟨A⟩∷x⟨B⟩∷[]
      else x⟨B⟩∷x⟨A⟩∷[]
  ; x₁∷x₂∷xs′ →
      let xs₁,xs₂ : list (ℤ⟨A,B⟩) × list (ℤ⟨A,B⟩) in
      let xs₁,xs₂ = split xs in

      let ys₁ : CIR{bool:A,B} list (ℤ[gmw:A,B]) in
      let ys₁ = rec xs₁ in

      let ys₁ : CIR{bool:A,B} list (ℤ[gmw:A,B]) in
      let ys₂ = rec xs₂ in

      merge ys₁ ys₂

  }
