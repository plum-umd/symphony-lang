principal A[27] -- Parties who supply just integers
principal B[9] -- Parties who supply both integers and queries

-- Query functions

-- First element because list is sorted
def min : list â„¤{spdz:A,B} â†’ â„¤{spdz:A,B}
def min xs = case xs
  { xâˆ·_ â†’ x
  }

-- Last element because list is sorted
def max : list â„¤{spdz:A,B} â†’ â„¤{spdz:A,B}
def max xs = case xs
  { [x] â†’ x
  ; _âˆ·xs' â†’ max xs'
  }

-- Find the middle element (use the lower middle element if the length is even)
def median : list â„¤{spdz:A,B} â†’ â„¤{spdz:A,B}
def median xs =
  let l = length xs
  let idx = l / 2
  let idx' = ((l % 2) â‰¡ 0) ? (idx - 1) â—‡ idx
  in elem-at idx' xs

-- Recursive helper function for num-unique
def num-unique-rec : list â„¤{spdz:A,B} â†’ â„¤{spdz:A,B} â†’ â„¤{spdz:A,B}
def num-unique-rec xs last = case xs
  { [] â†’ 0
  ; xâˆ·xs' â†’
    let b = x â‰¡ last
    in (num-unique-rec xs' x) + (b ? 0 â—‡ 1)
  }

-- Find the number of unique elements in the integer list
def num-unique : list â„¤{spdz:A,B} â†’ â„¤{spdz:A,B}
def num-unique xs = case xs
  { [] â†’ 0
  ; xâˆ·xs' â†’ (num-unique-rec xs' x) + 1
  }

-- mpc/list manip

def remove-dups :
    list ((â„¤{spdz:A,B} Ã— â„™{spdz:A,B}) + ðŸ™)
  â†’ list ((â„¤{spdz:A,B} Ã— â„™{spdz:A,B}) + ðŸ™)
def remove-dups qs = case qs
  { [] â†’ []
  ; queryOptâˆ·qs' â†’
    let queryOpt' =
      mux if (elem (Î» x y â†’
        mux case x
        { L (x1, x2) â†’
          mux case y
          { L (y1, y2) â†’ (y1 == x1) && (x2 == y2)
          ; R â€¢ â†’ false
          }
        ; R â€¢ â†’ false
        }
        ) queryOpt qs')
      then R â€¢
      else queryOpt
    in queryOpt'::(remove-dups qs')
  }

-- Publishing results

def reveal-results :
    list (â„™{spdz:A,B} Ã— (â„¤{spdz:A,B} Ã— â„¤{spdz:A,B}))
  â†’ (â„¤{bundle:A,B} Ã— â„¤{bundle:A,B})
def reveal-results xs = case xs
  { [] â†’ âŸªâŸ«,âŸªâŸ«
  ; (p,(q, r))âˆ·xs' â†’
    let q' = reveal {p} q
    let r' = reveal {p} r
    let (qs,rs) = reveal-results xs'
    in âŸªp | q'âŸ« â§º qs, âŸªp | r'âŸ« â§º rs
  }

def publish-results :
    list â„¤{spdz:A,B}
  â†’ list ((â„¤{spdz:A,B} Ã— â„™{spdz:A,B}) + ðŸ™)
  â†’ list (â„¤{bundle:A,B} Ã— â„¤{bundle:A,B})
def publish-results results queryTargetOptionals = case queryTargetOptionals
  { [] â†’ []
  ; qtoâˆ·remaining â†’
    let qto' =
      fold-p (Î» l p â†’
        let out = mux case qto
          { L (q, t) â†’ (p â‰¡ t ? q â—‡ -1, p â‰¡ t ? elem-at q results â—‡ -1)
          ; R â€¢ â†’ (-1, -1)
          }
        in (p, out) âˆ· l
      ) [] {A,B}
    let output = reveal-results qto'
    let remainingOutput = publish-results results remaining
    in output âˆ· remainingOutput
  }

def post-process :
    list (â„¤{bundle:A,B} Ã— â„¤{bundle:A,B})
  â†’ (p:â„™)
  â†’ (list (ð•Š{p} Ã— â„¤{p})){p}
def post-process xs Î± = foldl xs [] (Î» (q,r) l â†’
  let q' = q@Î±
  let r' = r@Î±
  if q' â‰¡ -1
  then l
  else
    let s =
      if 0 â‰¡ q' then "Median is " else
      if 1 â‰¡ q' then "Number Unique is " else
      if 2 â‰¡ q' then "Min is " else
      if 3 â‰¡ q' then "Max is " else âŠ¥
    in (s â§» (to_str r')) âˆ· l
  )

-- Verification

def verify inputs medianResult uniqueResult minResult maxResult =
  let mk-wit = fun x -> nizk-witness{ spdz : A,B } x in
  let test-true = mk-wit true in
  let test-false = mk-wit false in
  let wrap-is-signed = fun N x -> is-signed { N } x in
  let input-wits = map mk-wit inputs in
  let median-result-wit = mk-wit medianResult in
  let unique-result-wit = mk-wit uniqueResult in
  let min-result-wit = mk-wit minResult in
  let max-result-wit = mk-wit maxResult in

  let all-inputs-signed = elim-list input-wits
    test-true
    (fun w -> and 
      (elim-prins {A,B}
         test-false
         (fun N -> or (wrap-is-signed N w)) ) ) in

  let correct-median =
    let (lt, eq) = foldr (Î» x (lt, eq) â†’ (x < median-result-wit ? lt + 1 â—‡ lt, x â‰¡ median-result-wit ? eq + 1 â—‡ eq)) (0, 0) input-wits in
    let l = length input-wits
    let idx = l / 2 in
    let idx' = (l % 2) â‰¡ 0 ? idx - 1 â—‡ idx in
    (lt â‰¤ idx') && (idx' â‰¤ eq + lt)

  let correct-unique =
    let seen = replicate (false, -1) (36 * 32) in
    unique-result-wit â‰¡ fst (foldr (Î» x (idx, s) â†’ mux if (elem (Î» (at, av) (bt, bv) â†’ at && bt && (av â‰¡ bv))) (true, x) s then (idx, s) else (idx + 1, update-list (true, x) idx s)) (0, seen) input-wits)

  let correct-min = (foldr (Î» x b â†’ (min-result-wit â‰¤ x) && b) test-true input-wits) && (foldr (Î» x b â†’ min-result-wit â‰¡ x ? test-true â—‡ b) test-false input-wits) in

  let correct-max = (foldr (Î» x b â†’ (x â‰¤ max-result-wit) && b) test-true input-wits) && (foldr (Î» x b â†’ max-result-wit â‰¡ x ? test-true â—‡ b) test-false input-wits) in

  nizk-commit {spdz:A,B} (all-inputs-signed && correct-median && correct-unique && correct-min && correct-max)

-- ATQ

def main : ðŸ™ â†’{inp:A,B;rev:A,B} list â„¤{any}
def main â€¢ = par {A,B}

  -- All parties read in data input
  let inputLists : (list â„¤){bundle:A,B}
  let inputLists = solo {A,B} as Î± in map (wrap-sign Î±) (read (list â„¤) from "atq-data.txt")

  -- Parties in group B read in queries
  let inputQueries : â„¤{bundle:B}
  let inputQueries = solo {B} as Î± in read â„¤ from "atq-query.txt"

  -- Parties in group B read in targets for the previously read in queries
  let inputTargets : (list â„™){bundle:B}
  let inputTargets = solo {B} as Î± in read (list â„™) from "atq-targets.txt"

  -- Secret share the elements of each party's list
  let inputListsShared : list list (â„¤{spdz:A,B})
  let inputListsShared = fold-f [] (Î» P x i â†’ (preprocess-lists-reveal-lengths P {A,B} x) âˆ· i) inputLists

  -- Merge and sort the input lists into a single list
  let dataList : list â„¤{spdz:A,B}
  let dataList = concat inputListsShared

  -- Produce a single sorted list of all input integers
  let dataListSorted : list â„¤{spdz:A,B}
  let dataListSorted = sort (Î» a b â†’ a â‰¤ b) dataList

  -- Find the median of the integer list
  let medianResult : â„¤{spdz:A,B}
  let medianResult = median dataListSorted

  -- Find the number of unique elements in the integer list
  let uniqueResult : â„¤{spdz:A,B}
  let uniqueResult = num-unique dataListSorted

  -- Find the minimum value in the integer list
  let minResult : â„¤{spdz:A,B}
  let minResult = min dataListSorted

  -- Find the maximum value in the integer list
  let maxResult : â„¤{spdz:A,B}
  let maxResult = max dataListSorted

  -- Verify that all inputs are signed and results are correct
  let verification = verify dataList medianResult uniqueResult minResult maxResult

  -- Group results into an indexable data structure
  let results : list â„¤{spdz:A,B}
  let results = [medianResult; uniqueResult; minResult; maxResult]

  -- Pair the input queries and targets up along with a tag denoting that it is not dummy data
  let queriesWithTargets : (list (â„¤{B} Ã— â„™{B})){bundle:B}
  let queriesWithTargets = solo {B} as Î± in (pair-with-list inputQueries@Î± inputTargets@Î±)

  -- Secret share queries and targets without revealing the number of targets each party supplied by setting an upper bound and padding data out with dummy data
  let queriesWithTargetsShared : list list ((â„¤{spdz:A,B} Ã— â„™{spdz:A,B}) + ðŸ™)
  let queriesWithTargetsShared = fold-f [] (Î» P x i â†’ (preprocess-lists-n-pairs P {A,B} 8 x) âˆ· i) queriesWithTargets

  -- Combine queries and targets into one list
  let allQueriesWithTargetsShared : list ((â„¤{spdz:A,B} Ã— â„™{spdz:A,B}) + ðŸ™)
  let allQueriesWithTargetsShared = concat queriesWithTargetsShared

  -- Remove duplicate queries so that recipients will not learn how many times they were targeted
  let finalQueries : list ((â„¤{spdz:A,B} Ã— â„™{spdz:A,B}) + ðŸ™)
  let finalQueries = remove-dups allQueriesWithTargetsShared

  -- For each query from each party in B with duplicates replaced by dummy data, plus dummy padding to achieve upper bounds, publish the results of the query to the target of the query
  let published-results = publish-results results finalQueries

  -- Have each party post-process the output to make things look nice
  let pretty-output = solo {A,B} as Î± in post-process published-results Î±

  in (verification, pretty-output)

