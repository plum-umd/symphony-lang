-- BEGIN definitions appropriate for general-purpose library modules

-- err msg: throw an error message
def err msg = msg + 0

-- BEGIN library for general functions:

def apply f a = f a

def compose : (t0 -> t1) -> (t1 -> t2) -> (t0 -> t2)
def compose f g x = g (f x)

def const : t -> u -> t
def const x y = x

def flip f x y = f y x

def id : t -> t
def id x = x

def uncurry : (a -> b -> c) -> (a * b -> c)
def uncurry f (a, b) = f a b

def pair x y = (x, y)

def fst (x, y) = x

def snd (x, y) = y

def elim_sum f g x = case x
  { L x' -> f x'
  ; R y' -> g y'
  }

-- BEGIN library for security-sensitive operations:

def ite guard tc fc = if guard then tc else fc

def mux guard tc fc = guard ? tc ◇ fc

def pdecons a f xy = case xy
  { ⟪⟫ → a
  ; ⟪Q.x⟫⧺xy′ → f Q x 
  }

def pfold : ∀ A:☆,P:ℙ. A → ((Q:ℙ | Q⊆P) → ℤ{Q} → A → A) → ℤ{isec:P} →{sec:P} A
def pfold i f xy = case xy
  { ⟪⟫ → i
  ; ⟪Q.x⟫⧺xy′ → f Q x (pfold i f xy′)
  }

def reveal_ls P l = 
  case (reveal{ P } l)
  { [ ] -> [ ]
  ; x :: l' -> x :: (reveal_ls P l') 
  }

def reveal_prins P x = reveal{ P } x

-- shr_spdz: a first-order operation that shares over SPDZ
def shr_spdz P x = share{ spdz : P } x

-- BEGIN library for Boolean

-- and: non-infix Boolean conjunction
def and b0 b1 = b0 && b1

def not b = !b

-- BEGIN library for types with equality:

-- eq: non-infix equality test
def eq x y = x == y

-- BEGIN library for a numeric typeclass

-- plus: non-infix sum
def plus m n = m + n

-- minus: non-infix subtraction
def minus m n = m - n

-- mult: non-infix multiplication 
def mult m n = m * n

-- div: non-infix division
def div m n = m / n

-- exp: non-infix exponentiation
def exp m n = m ^ n

-- square: multiple a number with itself:
def square a = a * a

def max muxer a b = muxer (a <= b) b a

def max_spdz = mux

def abs_val_real a = max mux a (-1.0 * a)

-- TODO: define these properly
def log_2_real = id

def magn x = 1n

-- BEGIN library for nats:

-- inc n: increment of nat n
def inc : nat -> nat
def inc = plus 1n

-- def inc n = 1n + n

-- dec n: decrement of nat n
def dec : nat -> nat
def dec n = n - 1n

-- elim_nat: form for eliminating (folding over) nats
def elim_nat : nat -> t -> (t -> t) -> t
def elim_nat m z s = 
  if m ≡ 0n then z
  else s (elim_nat (dec m) z s)

-- eliml_nat: analog of fold right, for nats
-- PSL: add syntactic sugar for this?
def eliml_nat : nat -> t -> (t -> t) -> t
def eliml_nat n z s = (elim_nat n id (compose s)) z

-- monad for building a value and a continuation. Type is
-- cont a b = (a -> a, b)
-- where cont a is a monad.

-- monadic return:
def cont_return a = (id, a)

-- monadic bind:
def cont_bind (f, a) g =
  let (f0, b) = g a in
  (compose f0 f, b)

-- cont_run : cont a a -> a: get an a value:
def cont_run = uncurry apply

def cont_join m = cont_bind (g, a) id

def cont_seq (f, a) v = cont_bind (f, a) (const v)

-- if_then guard tc: an if-then branch 
def if_then guard tc rest = (mux guard tc, rest)

-- eliml_sec_nat: eliminate a secure nat. Just does this by iterating
-- up to some bound.
def max_nat = 0n
def eliml_sec_nat muxer encz encone n z s = cont_run (snd
  (eliml_nat max_nat
    (n, cont_return z)
    (fun (n', v) ->
      (n' - encone, cont_join ((muxer (n' == encz) v), s v)) ) ) )

-- nat_log: logarithm over nats. Diverges at 0n.
def nat_log : nat -> nat -> nat
def nat_log b n =
  if n == 1n then 0n
  else inc (nat_log b (n / b))

def ceil_fn f f_inv n =
  let n' = f n in
  n' + (if n == f_inv n' then 0n else 1n)

def log_2_ceil = ceil_fn (nat_log 2n) (exp 2n)

-- BEGIN library for floats:

-- sqrt: implementation of the Babylonian method for computing sqrt
def sqrt_steps = 5n
def babylonian_sqrt x = eliml_nat sqrt_steps
  1.0
  (fun s -> (s + x / s) / 2.0)

-- BEGIN library for list:

-- cons: non-infix list cons
def cons : t -> list t -> list t
def cons x l = x :: l

-- const_vec t a n: a vector of constant a of size n
def const_vec : t -> nat -> list t
def const_vec c n = elim_nat n [ ] (cons c)

-- foldr: right fold, the list eliminator
def foldr : list t -> acc -> (t -> acc -> acc) -> acc
def foldr l acc f = case l
  { [ ] -> acc
  ; x :: l' -> f x (foldr l' acc f)
  } 

-- filter test l: l, filtered down to elements that satisfy test
def filter test l = foldr l
  [ ]
  (fun x rest -> if test x then x :: rest else rest)

-- foldr_tl: right fold with access to the tail of the list
def foldr_tl : list t -> acc -> (t -> list t -> acc -> acc) -> acc
def foldr_tl l i f = snd
  (foldr l ([ ], i) (fun x (l', b) -> (x :: l', f x l' b)))

-- decons_ls: first-order case syntax 
def decons_ls : list t -> u -> (t -> list t -> u) -> u
def decons_ls l a0 f = case l
  { [ ] -> a0
  ; x :: l' -> f x l'
  }

-- foldl: left fold
-- PSL: add syntactic sugar for this?
def foldl : list t -> acc -> (t -> acc -> acc) -> acc
def foldl l acc0 f = (foldr l id (fun x acc -> compose acc (f x))) acc0

-- concat l0 l1: concatenation of l0 and l1
def concat : list t -> list t -> list t
def concat l0 l1 = foldr l0 l1 cons

-- len l: length of list l
def len : list t -> nat
def len l = foldr l 0n (const inc)

def order = len

-- get i l: the ith element of l
def get l i = eliml_nat i
  l
  (fun l' -> case l'
    { [ ] -> [ ]
    ; x :: l'' -> l''
    })

-- set l i v: list l with the ith element updated to be v
def set l i v = eliml_nat i
  (let rest = case l
   { [ ] -> [ ]
   ; x :: l' -> v :: l'
   })
  (fun l' -> case l'
   { [ ] -> [ ]
   ; x :: l'' -> x :: 
   }
  )
  

-- map: map operation for the list functor
def map : (t -> u) -> list t -> list u
def map f l = foldr l [ ] (compose f cons)

-- rev_ls l: the reverse of list l
def rev_ls : list t -> list t
def rev_ls l = foldl l [ ] cons

def snoc : t -> list t -> list t
def snoc x l = concat l [ x ]

-- zip_lists pt0 pt1: the zip of points p0 and p1
def zip_lists : list t -> list u -> list (t * u)
def zip_lists l0 l1 =
  (foldr l0
    (const [ ])
    (fun x z0 l -> case l
      { [ ] -> [ ]
      ; y :: l' -> (x, y) :: z0 l'
      }) )
    l1

def zip_map : (t -> u -> v) -> list t -> list u -> list v
def zip_map f l0 l1 = map (uncurry f) (zip_lists l0 l1)

-- transpose: shift matrix between row major and column major order
def transpose : list (list t) -> list (list t)
def transpose m = foldr m
  (const_vec [ ]
    (case m
     { [ ] -> 0n
     ; v :: m' -> len v
     }) )
  (zip_map cons)

def all_true : list bool -> bool
def all_true l = foldr l true and

def eq_lists v0 v1 = all_true (zip_map eq v0 v1)

def eq_vecs = eq_lists

-- mux_ls: multiplex over a pair of lists:
def mux_ls guard l0 l1 = zip_map (mux guard) l0 l1

def eliml_sec_nat_ls = eliml_sec_nat mux_ls
  (shr_w_comp 0n) (shr_w_comp 1n) 

-- prod: the product over a list of numerics
def prod v one = foldr v one mult

-- sum: the sum over a list of numerics
def sum v z = foldr v z plus

-- dot_prod: take the dot product of two points
def dot_prod_gen z p0 p1 = sum (zip_map mult p0 p1) z
def dot_prod = dot_prod_gen shr0

-- pt_diff: subtract one point from another
def minus_vecs : point -> point -> point
def minus_vecs v0 v1 = zip_map minus v0 v1 

-- scalar_vec_mult a v: scalar product of a and v
def scalar_vec_mult a = map (mult a)

-- scalar_vec_div: divide a vector of reals by a constant
def div_vec : real -> list real -> list real
def div_vec v a = map (flip div a) v

-- l2norm z v: the L2 norm of a vector of numerics with zero element z
def l2norm : point -> comp_shr
def l2norm z v = babylonian_sqrt (sum (map square v) z)

-- zeros_vec: a vector of floating-point zeroes
def zeros_vec : nat -> list real
def zeros_vec = const_vec 0.0

-- row_of_ones: a vector of real ones
def row_of_ones : nat -> list real
def row_of_ones = const_vec 1.0

-- mult_mat_vec : multiply a matrix of secrets and a point
def matrix_vec_mult_gen z m pt = map (dot_prod z pt) m

-- mult_mat: product of row matrix and column matrix
def matrix_mult_gen z m0 m1 = map (fun v -> map (dot_prod z v) m1) m0 

-- part_ith a i l: l partitioned into the first i - elements, ith elt,
-- and the everything after element i. a is a default elt, which
-- should never be used.
def part_ith : nat -> t -> list t -> (list t) * t * (list t)
def part_ith a i l =
  let (first_i, rem) =
    eliml_nat i
      ([ ], l)
      (fun (front, tl) -> case tl
        { [ ] -> (front, tl) -- should never be used
        ; hd :: tl' -> (hd :: front, tl)
        }) in
  let (ith, tl) = case rem
    { [ ] -> (a, rem) -- should never be used
    ; b :: rem' -> (b, rem')
    } in
  (first_i, ith, tl)

-- squareMat m: matrix m coerced into a square matrix
def squareMat d m = rev_ls (snd
  (foldl m
    (0n, [ ])
    (fun rv (i, acc) -> (inc i, (part_ith d i rv) :: acc)) ) )

-- col_lt_to_row m: LT matrix m in col-major form, converted to
-- row-major form
def col_lt_to_row m = foldr m
  [ ]
  (fun (hd, bot) acc -> ([ ], hd) ::
    (zip_map (fun b (ls, rt) -> (b :: ls, rt)) bot acc) )

-- lt_lift d l: LT matrix l, lifted into a matrix by padding copies of
-- default element d
def lt_lift : t -> list (t * (list t)) -> list (list t)
def lt_lift d l = rev_ls (snd
  (foldl l
    ([ ], [ ])
    (fun (hd, tl) (buf, m) -> (d :: buf, (concat buf (hd :: tl)) :: m) ) ) )

-- diagonal_matrix_gen v: the diagonal matrix of vector v, with zero
-- elt z
def diagonal_matrix_gen z v = foldr v
  [ ]
  (fun x diag -> (x :: (const_vec z (len diag))) :: (map (cons z) diag))

-- END: library code

-- BEGIN: application-specific code

-- m : user parameter: number of constraint parties
def m : nat
def m = 2n

-- n : user parameter: dimension of the constraint system
def n : nat
def n = 2n

-- Ctr[m]: parties that bring the constraints
principal Ctr[2]

-- party that provides the cost vector:
principal Cost

-- party that gets the output:
principal Out

-- comps: the parties that do computation, Ctr and Cost
def comps = set(Ctr,Cost)

-- shr_w_ctrs: share data with the parties performing computation
def shr_w_ctrs = shr_spdz set(Ctr)

-- shr_w_comp: share data with the parties performing computation
def shr_w_comp = shr_spdz comps

-- shr0, shr1: shares of constants that are often reused:
def shr0 = shr_w_comp 0.0 in
def shr1 = shr_w_comp 1.0 in
     
-- matrix_mult: multiply matrices of SPDZ shares
def matrix_mult = matrix_mult_gen shr0 
-- matrix_vec_mult: multiply matrix and vector of SPDZ shares
def matrix_vec_mult = matrix_vec_mult_gen shr0 

def nOnes = row_of_ones n 

-- dimensions_of m: dimensions of matrix m
def dimensions_of m = case m
  { [ ] -> (0, 0)
  ; rv :: m' -> (inc (len m'), len rv)
  }

-- nz_prod z u l: the product of non-z entries in l, with
-- multiplicative unit u
def nz_prod z one l = prod (filter (compose (eq z) not) l) one

def nz_prod_vec = nz_prod shr0 shr1

def nz_prod_mat m = nz_prod_vec (map nz_prod_vec m)

-- diagonal_matrix v: diagonal matrix of vector of SPDZ shares v
def diagonal_matrix = diagonal_matrix_gen shr0

def zero_vec = const_vec shr0 

-- zero_pt: point of zero's
def zero_pt = zero_vec n

-- zero_mat: matrix of zeroes
def zero_mat n = elim_nat n
  [ ]
  (cons (zero_vec n))

-- range m n: the list of elements from m to n
def range m n =
  if n < m then [ ]
  else map (plus m)
    (elim_nat (n - m)
       [ 0 ]
       (fun rng -> (len rng) :: rng))

def matrix_get m (i, j) = get (get m i) j

def matrix_set m (i, j) v = set m i (set (get m i) j v)

-- Listing 9: Inverse of a lower triangular matrix
def matrix_inverse_lt l =
  let n = order l in -- order of L
  let l_inv = ref (zero_mat n) in -- n x n zero matrix
  -- PSL: can we add syntactic sugar for sequencing?
  -- PSL: can we add syntactic sugar for loops? In particular for
  -- loops with no accumulator?
  fold-f ()
    (fun k ->
      -- For diagonal entries, take the reciprocal
      l_inv := matrix_set l_inv (k, k) (matrix_get l_inv (k, k)) ;

      -- For non-diagonal entries, solve L * L_inv = I
      fold-f ()
        (let sum = ref 0n in
          fold-f ()
            (fun i ->
              sum := sum -
                (metrix_get l (j, i)) * (matrix_get l_inv (i, k)) )
            (range k (j - 1n)) )
        (range (k + 1n) (n - 1n)) )
    (range 0 (n - 1n)) ;
  l_inv

-- TODO: replace with list syntax

-- Listing 10: Cholesky decomposition of a positive definite Hermitian
-- matrix
def cholesky_decomposition m =
  -- Initialize variables
  let n = order m in -- order of m
  let l = ref (zero_mat n) in -- n x n zero matrix

  -- Calculate the top diagonal element of L
  l := matrix_set l (0, 0) (sqrt (matrix_get m (0, 0))) ;

  -- Calculate the rest of the first column of L
  fold-f ()
    (fun j ->
      l := matrix_set l (j, 0n)
        ((matrix_get m (j, 0n)) / (matrix_get l (0n, 0n))) )
    (range 1n (n - 1n)) ;

  -- Iterate through the remaining columns
  fold-f ()
    (fun i ->
      -- First calculate the diagonal element for this column
      let sum = ref 0n in
      fold-f ()
        (fun j ->
          sum := sum + (matrix_get l (i, j)) * (matrix_get l (i, j)) )
        (range 0n (i - 1n)) ;

      l := matrix_set (i, i) (sqrt ((matrix_get m (i, i)) - sum)) ;

      -- Now fill in the remaining entries in this column
      if_then (i < n - 1n)
        (fold-f ()
          (fun j ->
            sum := 0n ;
            fold-f ()
              (fun k ->
                sum := sum + (matrix_get l (i, k)) * (matrix_get l (j, k))
              )
              (range 0n (i - 1n))
          )
          (range (i + 1n) (n - 1n))
        )
    )
    (range 1n (n - 1n)) ;
  l

-- Listing 8: Inverse of a positive definite Hermitian matrix
def matrix_inverse_pdh : num -> matrix -> matrix
def matrix_inverse_pdh m =
  let l = cholesky_decomposition m in
  let l_inv = matrix_inverse_lt l in -- Invert the lower-triangular matrix
  let m_inv = matrix_mult (transpose l_inv) l_inv in
  m_inv

-- Listing 6: Iteration for Karmarkar's Algorithm
def karmarkar_iteration initial_point a c =
  let (m, n) = dimensions_of a in
  -- D is a matrix of zeros with the values of initial_point on the
  -- diagonal
  -- Dimensions of D: n x n
  let d = diagonal_matrix initial_point in
  -- Dimensions of cprime: n x 1
  let cprime = matrix_scalar_vec_mult_spdz d c in
  -- Dimensions of AD: m x n
  let ad = matrix_mult_spdz a d in

  -- Construct B
  -- Dimensions of B: (m + 1) x n
  let b = concat ad [ row_of_ones n ] in -- append a row of ones onto AD

  -- Dimensions of BBT: (m + 1) x (m + 1)
  let bbt = matrix_mult_spdz b (transpose b) in
  -- Dimensions of BBTInv: (m + 1) x (m + 1)
  let bbtinv = matrix_inverse_pdh bbt in

  -- Project C onto B's nullspace
  -- Dimensions of cp: n x 1
  let cp = minus_vecs cprime
    (matrix_scalar_vec_mult_spdz (transpose b)
      (matrix_scalar_vec_mult_spdz bbtinv
        (matrix_scalar_vec_mult_spdz b c') ) ) in

  -- Calculate a unit vector of cp
  -- Dimensions of unitcp: n x 1
  let unit_cp =
    mux_ls (eq_vecs cp zero_pt) -- If cp is the zero vector
      -- If cp is the zero vector, assign it to be 0
      zero_pt
      (div_vec zero_pt (l2norm shr0 cp)) in

  -- Take a step of 1/3n in the direction of -cp, row_of_ones(n)/n is
  -- the "transformed" initial point
  -- Dimensions of bprime: n x 1
  let bprime = minus_vecs
    (div_vec (row_of_ones n) (to_flt n))
    (scalar_vec_mult (1.0 / (3.0 * (to_flt n))) unit_cp) in

  -- Transform the point back
  -- Dimensions of b: n x 1
  let b = scalar_vec_div (matrix_scalar_vec_mult_spdz d bprime)
    (dot_prod (row_of_ones n) (matrix_scalar_vec_mult_spdz d bprime)) in
  b

-- Listing 7: Loop for Karmarkar's Algorithm
def karmarkar_loop a c =
  let (m, n) = dimensions_of a in
  -- Epsilon is the stopping condition. This value should be close to
  -- 0, so we choose 10^(-8)
  let epsilon = 10.0 ^ -8.0 in

  -- x is our initial point
  let x = div_vec (row_of_ones n) (to_flt n) in

  -- product of non-zero entries in c and A
  let p = (nz_prod_vec c) * (nz_prod_mat a) in
  let l = (m + 1n) * n +
    (magn (ceil (log_2_real (abs_val_real p)))) +
    n * (magn (ceil (log_2_real (to_flt n)))) in
  let max_iterations = 12n * n * l in
  let max_iterations = shr_w_comp 1n in -- DEBUG CODE

  -- If this initial point is an optimal solution, return
  mux_ls ((dot_prod c x) < epsilon)
    x
  (eliml_sec_nat_ls max_iterations
    x
    (fun x -> 
      let x' = karmarkar_iteration x a c in

      -- if we are within the stopping condition in the current
      -- iteration, return
      if_then 
        ((((dot_prod c x) - (dot_prod c x')) /
           (max_spdz shr1 (dot_prod c x)) ) < epsilon )
        x'
      x') )

-- main: entry point; Ctr, Cost read inputs and run the algorithm,
-- distributes results to Out
def main : unit ->{ inp : Ctr, Cost; rev : Out } (list out_sec)
def main () =
  -- read_vec: reads an input vector on a principal's machine
  let read_vec = fun () -> read (list flt) "in.txt" in
  
  -- FANCY MPC: Ctr and Cost send the data in the list to Out. This
  -- may change if the PSL model of isec's changes as a result of
  -- issue #31
  let soln = { par : Ctr, Cost, Out } (map
    (reveal_prins set(Out))
    -- Ctr and Cost reveal the list structure of the point to Out:
    (reveal_ls set(Ctr,Cost,Out)
      -- Ctr and Cost compute the solution point:
      ({ par : Ctr, Cost } karmarkar_loop
        -- read in the matrix of constraints and share them
        (pfold 
          [ ]
          (fun Q ctr -> cons
            (mult_diag_vec pt
            (map shr_w_comp (reveal_ls comps ctr)) ) )
          ({ par : Ctr } read_vec ()) )
        -- read in the vector of costs and share them
        (map shr_w_comp
          (reveal_ls comps ({ par : Cost } read_vec ())) ) ) ) ) in
  -- Ctr and Cost forget the structure of the solution
  { par : Out } reveal_ls set(Out) soln
