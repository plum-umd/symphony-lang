principal A B C

-- Trivial ORAM is a 3-tuple of âŸ¨index, is_dummy, dataâŸ©

def tr_default = (0n, true, 0n)

def tr_init n = array[n] tr_default

def readable mem hand = Â¬ mem âˆ§ hand

def writable mem hand = mem âˆ§ Â¬ hand

def tr_rr oram idx =
  let sz = nat (size oram) in
  let tr_rr' = Î» [tr_rr'] i acc â†’
    if i == sz then
      acc
    else
      let c                     = oram.i
      let (c_idx, c_dummy  , _) = c
      let (_    , acc_dummy, _) = acc
      let (c', acc')            = mux if (readable c_dummy acc_dummy) âˆ§ (c_idx â‰¡ idx) then (acc, c) else (c, acc) in
      oram.i â† c' â–¶
      tr_rr' (i + 1n) acc'
  in

  let (_, _, v) = tr_rr' 0n tr_default in
  v

def tr_w oram idx v =
  let sz = nat (size oram) in
  let tr_w' = Î» [tr_w'] i acc â†’
    if i == sz then
      ()
    else
      let c                     = oram.i
      let (c_idx, c_dummy  , _) = c
      let (_    , acc_dummy, _) = acc
      let (c', acc')            = mux if (writable c_dummy acc_dummy) then (acc, c) else (c, acc) in
      oram.i â† c' â–¶
      tr_w' (i + 1n) acc'
  in tr_w' 0n (idx, false, v)

def tr_r oram idx =
  let v = tr_rr oram idx in
  tr_w oram idx v â–¶
  v

-- Circuit ORAM

def ck_init n m =
  let r = array[n] âŠ¥ in
  let ck_init' = Î» [ck_init'] i â†’
    if i == n then
      ()
    else
      ()
  in
  ck_init' 0n â–¶
  r

--NOTE(ins): The `depth[i]` in Circuit ORAM paper must contain not only
--           the deepest level of blocks in level `i`, but also the _index_ for
--           that block so that it can be read out later.
--
--           Then, that index is propagated all the way to the `target` array
--           so that it can be read out when evicting.
--
--           See: https://github.com/samee/sqrtOram/blob/9865598228f66936a9759b2221a06b2b1b0263f9/oram/nonrecursive_oram.oc#L147

--def deepest sz p =
--  let r = array[sz] âŠ¥ in
--  let deepest_rec = Î» [deepest_rec] i acc â†’
--    ...
--  in
--  let _ = deepest_rec 1n ... in
--  r

-- TODO

-- Array Library

def eq_array eq_e a1 a2 =
  let sz1 = nat (size a1)
  let sz2 = nat (size a2) in
  if sz1 â‰¡ sz2 then
    let eq_rec = Î» [eq_rec] i acc â†’
      if i â‰¡ sz1 then
        acc
      else
        eq_rec (i + 1n) (acc âˆ§ (eq_e a1.i a2.i))
    in eq_rec 0n true
  else
    false

def app_array arrs =
  let n = nat (size arrs) in
  let len = Î» [len] i acc â†’
    if i == n then
      acc
    else
      len (i + 1n) (acc + nat (size arrs.i))
  in
  let m = len 0n 0n in
  let r = array[m] âŠ¥ in
  let concat = Î» [concat] i j offset â†’
    if i == n then
      ()
    else
      let c = nat (size arrs.i) in
      if j == c then
        concat (i + 1n) 0n (offset + c)
      else
        let a = arrs.i in
        r.(offset + j) â† a.j â–¶
        concat i (j + 1n) offset
  in
  concat 0n 0n 0n â–¶
  r

-- Sorting

-- TODO

-- Binary Search

def cbs arr e =
  let sz = nat (size arr) in
  let bs_rec = Î» [bs_rec] l r â†’
    if l â‰¡ r then
      if arr.l â‰¡ e then (true, l) else (false, 0n)
    else
      let m = (l + r) / 2n in
      if e â‰¤ arr.m then
        bs_rec l m
      else
        bs_rec (m + 1n) r
  in bs_rec 0n (sz - 1n)

-- TODO(ins): Should also assume ORAM size is public, and pass this as argument.
--            Could be made to work with ORAM of private size, but would not be
--            very efficient and I think the typical use-case assumes a public size.
def obs oram e =
  let sz = nat (size oram) in
  let bs_rec = Î» rec (l, r) â†’
    mux if l â‰¡ r then
      let e' = tr_r oram l in
      mux if e â‰¡ e' then (true, l) else (false, 0n)
    else
      let m = (l + r) / 2n in
      let e' = tr_r oram m in
      mux if e â‰¤ e' then
        rec (l, m)
      else
        rec (m + 1n, r)
  in bnd_rec bs_rec (const (false, 0n)) 3n (0n, sz - 1n) -- TODO(ins): replace `3n` with `log_2(sz)`

------------
-- TESTS ---
------------

-- APPEND

def test_append () =
  -- IN: [1], [2; 2], and [3; 3; 3]
  let a    = array[1n] 1n
  let b    = array[2n] 2n
  let c    = array[3n] 3n in

  -- EXPECTED: [1; 2; 2; 3; 3; 3]
  let r = array[6n] âŠ¥ in
  r.0n â† 1n â–¶
  r.1n â† 2n â–¶
  r.2n â† 2n â–¶
  r.3n â† 3n â–¶
  r.4n â† 3n â–¶
  r.5n â† 3n â–¶

  -- [[1]; [2; 2]; [3; 3; 3]]
  let arrs = array[3n] âŠ¥ in
  arrs.0n â† a â–¶
  arrs.1n â† b â–¶
  arrs.2n â† c â–¶

  eq_array (Î» e e' â†’ e â‰¡ e') (app_array arrs) r

-- ORAM

def test_oram () =
  let P = {A,B,C}
  -- Create a new ORAM
  let oram = tr_init 3n

  -- A obliviously adds 10 at index 0, {B,C} cannot see the index or the value
  let si1  = share [yao, â„• : A -> P] (par {A} 0n)
  let sa   = share [yao, â„• : A -> P] (par {A} 10n) in
  tr_w oram si1 sa â–¶

  -- B obliviously adds 20 at index 1, {A,C} cannot see the index or the value
  let si2  = share [yao, â„• : B -> P] (par {B} 1n)
  let sb   = share [yao, â„• : B -> P] (par {B} 20n) in
  tr_w oram si2 sb â–¶

  -- C obliviously adds 30 at index 2, {A,B} cannot see the index or the value
  let si3  = share [yao, â„• : C -> P] (par {C} 2n)
  let sc   = share [yao, â„• : C -> P] (par {C} 30n) in
  tr_w oram si3 sc â–¶

  let t1 = send [â„• : A â†’ P] (reveal [yao, â„• : P â†’ A] (tr_r oram si3)) â‰¡ 30n
  let t2 = send [â„• : A â†’ P] (reveal [yao, â„• : P â†’ A] (tr_r oram si3)) â‰¡ 30n
  let t3 = send [â„• : A â†’ P] (reveal [yao, â„• : P â†’ A] (tr_r oram si1)) â‰¡ 10n
  let t4 = send [â„• : A â†’ P] (reveal [yao, â„• : P â†’ A] (tr_r oram si2)) â‰¡ 20n in
  t1 âˆ§ t2 âˆ§ t3 âˆ§ t4

-- BINARY SEARCH

def found_at (f, i') i = f âˆ§ (i â‰¡ i')

def not_found (f, _) = Â¬ f

def test_cbs_1 () =
  let arr = array[3n] âŠ¥ in
  arr.0n â† 2n â–¶
  arr.1n â† 7n â–¶
  arr.2n â† 43n â–¶

  let t1 = found_at (cbs arr 2n) 0n
  let t2 = found_at (cbs arr 7n) 1n
  let t3 = found_at (cbs arr 43n) 2n
  let t4 = not_found (cbs arr 50n) in
  t1 âˆ§ t2 âˆ§ t3 âˆ§ t4

def test_cbs_2 () =
  let arr = array[4n] âŠ¥ in
  arr.0n â† 2n â–¶
  arr.1n â† 7n â–¶
  arr.2n â† 43n â–¶
  arr.3n â† 77n â–¶

  let t1 = found_at (cbs arr 2n) 0n
  let t2 = found_at (cbs arr 7n) 1n
  let t3 = found_at (cbs arr 43n) 2n
  let t4 = found_at (cbs arr 77n) 3n
  let t5 = not_found (cbs arr 50n) in
  t1 âˆ§ t2 âˆ§ t3 âˆ§ t4 âˆ§ t5

def test_obs () =
  let oram = tr_init 3n in

  -- A's value
  let sai = share [yao, â„• : A â†’ {A,B,C}] (par {A} 0n)
  let sav = share [yao, â„• : A â†’ {A,B,C}] (par {A} 2n) in
  tr_w oram sai sav â–¶

  -- B's value
  let sbi = share [yao, â„• : B â†’ {A,B,C}] (par {B} 1n)
  let sbv = share [yao, â„• : B â†’ {A,B,C}] (par {B} 7n) in
  tr_w oram sbi sbv â–¶

  -- C's value
  let sci = share [yao, â„• : C â†’ {A,B,C}] (par {C} 2n)
  let scv = share [yao, â„• : C â†’ {A,B,C}] (par {C} 43n) in
  tr_w oram sci scv â–¶

  let t1 = found_at (send [ğ”¹ Ã— â„• : A â†’ {A,B,C}] (reveal [yao, ğ”¹ Ã— â„• : {A,B,C} â†’ A] (obs oram 2n))) 0n
  let t2 = found_at (send [ğ”¹ Ã— â„• : A â†’ {A,B,C}] (reveal [yao, ğ”¹ Ã— â„• : {A,B,C} â†’ A] (obs oram 7n))) 1n
  let t3 = found_at (send [ğ”¹ Ã— â„• : A â†’ {A,B,C}] (reveal [yao, ğ”¹ Ã— â„• : {A,B,C} â†’ A] (obs oram 43n))) 2n
  let t4 = not_found (send [ğ”¹ Ã— â„• : A â†’ {A,B,C}] (reveal [yao, ğ”¹ Ã— â„• : {A,B,C} â†’ A] (obs oram 50n))) in
  t1 âˆ§ t2 âˆ§ t3 âˆ§ t4

def main () = par {A,B,C}
  -- Tests
  trace (test_append ()) in
  trace (test_oram ()) in
  trace (test_cbs_1 ()) in
  trace (test_cbs_2 ()) in
  trace (test_obs ()) in
  ()
