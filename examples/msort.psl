principal A
principal B
principal C[2]
principal E

def list-cond : 
    ğ”¹{yao:C} 
  â†’ list â„¤{yao:C}
  â†’ list â„¤{yao:C} 
  â†’ list â„¤{yao:C}
def list-cond b xs ys = case xs,ys
  { [],_ â†’ ys
  ; _,[] â†’ xs
  ; xâˆ·xsâ€²,yâˆ·ysâ€² â†’ b ? x â—‡ y âˆ· list-cond b xsâ€² ysâ€²
  }

def split : list â„¤{isec:A,B} â†’ list â„¤{isec:A,B} Ã— list â„¤{isec:A,B}
def split xs = case xs
  { [] â†’ [] , []
  ; [x] â†’ [] , [x]
  ; xâ‚âˆ·xâ‚‚âˆ·xs â†’
      let xsâ‚,xsâ‚‚ = split xs 
      in xâ‚âˆ·xsâ‚,xâ‚‚âˆ·xsâ‚‚
  }

def merge : 
    list â„¤{yao:C}
  â†’ list â„¤{yao:C}
  â†’ list â„¤{yao:C}
def merge xs ys = case xs,ys
  { [],_ â†’ ys
  ; _,[] â†’ xs
  ; xâˆ·xsâ€²,yâˆ·ysâ€² â†’
      list-cond (x â‰¤ y)
                (x âˆ· merge xsâ€² ys)
                (y âˆ· merge xs ysâ€²)
  }

def msort : list â„¤{isec:A,B} â†’ list â„¤{yao:C}
def msort xs = case xs 
  { [] â†’ []
  ; [xy] â†’
      let x = share{yao:C} xy.A
      let y = share{yao:C} xy.B
      let b = x â‰¤ y
      in [ b ? x â—‡ y ; b ? y â—‡ x ]
  ; xâ‚âˆ·xâ‚‚âˆ·xsâ€² â†’
      let xsâ‚,xsâ‚‚ = split xs

      let ysâ‚ : list â„¤{yao:C}
      let ysâ‚ = msort xsâ‚

      let ysâ‚ : list â„¤{yao:C}
      let ysâ‚‚ = msort xsâ‚‚

      in merge ysâ‚ ysâ‚‚
  }

def map f xs = case xs
  { [] â†’ []
  ; xâˆ·xsâ€² â†’ f xâˆ·map f xsâ€²
  }

def main : ğŸ™ â†’{inp:A,B;rev:E} list â„¤{ssec:E}
def main â€¢ = 
  let xsys : list â„¤{isec:A,B}
  let xsys = {par:A,B} read (list â„¤) "msort-input.txt"
  in map (Î» x â†’ reveal{E} x) (msort xsys)
