principal A
principal B
principal C[2]
principal E

def list-cond : 
    𝔹{yao:C} 
  → list ℤ{yao:C}
  → list ℤ{yao:C} 
  → list ℤ{yao:C}
def list-cond b xs ys = case xs,ys
  { [],_ → ys
  ; _,[] → xs
  ; x∷xs′,y∷ys′ → b ? x ◇ y ∷ list-cond b xs′ ys′
  }

def split : list ℤ{isec:A,B} → list ℤ{isec:A,B} × list ℤ{isec:A,B}
def split xs = case xs
  { [] → [] , []
  ; [x] → [] , [x]
  ; x₁∷x₂∷xs →
      let xs₁,xs₂ = split xs 
      in x₁∷xs₁,x₂∷xs₂
  }

def merge : 
    list ℤ{yao:C}
  → list ℤ{yao:C}
  → list ℤ{yao:C}
def merge xs ys = case xs,ys
  { [],_ → ys
  ; _,[] → xs
  ; x∷xs′,y∷ys′ →
      list-cond (x ≤ y)
                (x ∷ merge xs′ ys)
                (y ∷ merge xs ys′)
  }

def msort : list ℤ{isec:A,B} → list ℤ{yao:C}
def msort xs = case xs 
  { [] → []
  ; [xy] →
      let x = share{yao:C} xy.A
      let y = share{yao:C} xy.B
      let b = x ≤ y
      in [ b ? x ◇ y ; b ? y ◇ x ]
  ; x₁∷x₂∷xs′ →
      let xs₁,xs₂ = split xs

      let ys₁ : list ℤ{yao:C}
      let ys₁ = msort xs₁

      let ys₁ : list ℤ{yao:C}
      let ys₂ = msort xs₂

      in merge ys₁ ys₂
  }

def map f xs = case xs
  { [] → []
  ; x∷xs′ → f x∷map f xs′
  }

def obliv-head : ∀ P:☆. ℤ → (list ℤ){isec:P} → ℤ{isec:P}
def obliv-head P i xs = {P} case xs
  { [] → i
  ; x∷_ → x
  }

def obliv-tail : ∀ P:☆. (list ℤ){isec:P} → (list ℤ){isec:P}
def obliv-tail P xs = {P} case xs
  { [] → []
  ; _∷xs′ → xs′
  }

def preprocess-lists : (P:ℙ) → ℕ → ℤ → (list ℤ){isec:P} → list ℤ{isec:P}
def preprocess-lists P n i xs =
  if n <= 0 
  then []
  else
    let x′ : ℤ{isec:P}
    let x′ = obliv-head P i xs
    let xs′ : list ℤ{isec:P}
    let xs′ = preprocess-lists P (n - 1) i (obliv-tail P xs)
    in 
    x′ ∷ xs′

def main : 𝟙 →{inp:A,B;rev:E} list ℤ{ssec:E}
def main • = 
  let xys-pre : (list ℤ){isec:A,B}
  let xys-pre = {par:A,B} read (list ℤ) "msort-input.txt"
  let xys : list ℤ{isec:A,B}
  let xys = preprocess-lists set(A,B) 2 0 xys-pre
  in 
  map (λ x → reveal{E} x) (msort xys)
