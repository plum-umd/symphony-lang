principal A
principal B
principal C[2]
principal E

def list-cond : 
    bool{yao:C} 
  -> list int{yao:C}
  -> list int{yao:C} 
  -> list int{yao:C}
def list-cond b xs ys = case (xs,ys)
  { ([], _) -> ys
  ; (_, []) -> xs
  ; (x :: xs', y :: ys') -> b ? x >< y :: list-cond b xs' ys'
  }

def split : list int{bundle:A,B} -> list int{bundle:A,B} * list int{bundle:A,B}
def split xs = case xs
  { [] -> [] , []
  ; [x] -> [] , [x]
  ; x1 :: x2 :: xs ->
      let xs1,xs2 = split xs
      in x1 :: xs1, x2 :: xs2
  }

def merge :
     list int{yao:C}
  -> list int{yao:C}
  -> list int{yao:C}
def merge xs ys = case (xs,ys)
  { ([], _) -> ys
  ; (_, []) -> xs
  ; (x :: xs', y :: ys') ->
      list-cond (x <= y)
                (x :: merge xs' ys)
                (y :: merge xs ys')
  }

def msort : list int{bundle:A,B} -> list int{yao:C}
def msort xs = case xs
  { [] -> []
  ; [xy] ->
      let x = share{yao:A -> C} xy@A
      let y = share{yao:B -> C} xy@B
      let b = x <= y
      in [ b ? x >< y ; b ? y >< x ]
  ; x1::x2::xs' ->
      let xs1,xs2 = split xs

      let ys1 : list int{yao:C}
      let ys1 = msort xs1

      let ys2 : list int{yao:C}
      let ys2 = msort xs2

      in merge ys1 ys2
  }

def map f xs = case xs
  { [] -> []
  ; x::xs' -> f x::map f xs'
  }

def main : unit -> {inp:A,B;rev:E} list int{E}
def main () =
  let xys-pre : (list int){bundle:A,B}
  let xys-pre = solo {A,B} as a in read (list int) from "msort-input.txt"
  let xys : list int{bundle:A,B}
  let xys = preprocess-lists {A,B} 5 0 xys-pre
  in map (fun x -> reveal{E} x) (msort xys)
