principal A
principal B
principal C[2]
principal E

def split : list ‚Ñ§{bundle:A,B} ‚Üí list ‚Ñ§{bundle:A,B} √ó list ‚Ñ§{bundle:A,B}
def split xs = case xs
  { [] ‚Üí [] , []
  ; [x] ‚Üí [] , [x]
  ; x‚ÇÅ‚à∑x‚ÇÇ‚à∑xs ‚Üí
      let xs‚ÇÅ,xs‚ÇÇ = split xs 
      in x‚ÇÅ‚à∑xs‚ÇÅ,x‚ÇÇ‚à∑xs‚ÇÇ
  }

def merge : 
    list ‚Ñ§{yao:C}
  ‚Üí list ‚Ñ§{yao:C}
  ‚Üí list ‚Ñ§{yao:C}
def merge xs ys = case xs,ys
  { [],_ ‚Üí ys
  ; _,[] ‚Üí xs
  ; x‚à∑xs‚Ä≤,y‚à∑ys‚Ä≤ ‚Üí
      mux if x ‚â§ y
      then x ‚à∑ merge xs‚Ä≤ ys
      else y ‚à∑ merge xs ys‚Ä≤
  }

def msort : list ‚Ñ§{bundle:A,B} ‚Üí list ‚Ñ§{yao:C}
def msort xs = case xs 
  { [] ‚Üí []
  ; [xy] ‚Üí
      let x = share{yao:A -> C} xy@A
      let y = share{yao:B -> C} xy@B
      let b = x ‚â§ y
      in [ b ? x ‚óá y ; b ? y ‚óá x ]
  ; x‚ÇÅ‚à∑x‚ÇÇ‚à∑xs‚Ä≤ ‚Üí
      let xs‚ÇÅ,xs‚ÇÇ = split xs

      let ys‚ÇÅ : list ‚Ñ§{yao:C}
      let ys‚ÇÅ = msort xs‚ÇÅ

      let ys‚ÇÅ : list ‚Ñ§{yao:C}
      let ys‚ÇÇ = msort xs‚ÇÇ

      in merge ys‚ÇÅ ys‚ÇÇ
  }

def map f xs = case xs
  { [] ‚Üí []
  ; x‚à∑xs‚Ä≤ ‚Üí f x‚à∑map f xs‚Ä≤
  }

def main : ùüô ‚Üí{inp:A,B;rev:E} list ‚Ñ§{E}
def main ‚Ä¢ = 
  let xys-pre : (list ‚Ñ§){bundle:A,B}
  let xys-pre = solo {A,B} as Œ± in read (list ‚Ñ§) from "msort-input.txt"
  let xys : list ‚Ñ§{bundle:A,B}
  let xys = preprocess-lists {A,B} 5 0 xys-pre
  in map (Œª x ‚Üí reveal{E} x) (msort xys)

