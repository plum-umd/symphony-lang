principal A
principal B
principal C[2]
principal E

def list-cond : 
    ğ”¹{yao:C} 
  â†’ list â„¤{yao:C}
  â†’ list â„¤{yao:C} 
  â†’ list â„¤{yao:C}
def list-cond b xs ys = case xs,ys
  { [],_ â†’ ys
  ; _,[] â†’ xs
  ; xâˆ·xsâ€²,yâˆ·ysâ€² â†’ b ? x â—‡ y âˆ· list-cond b xsâ€² ysâ€²
  }

def split : list â„¤{isec:A,B} â†’ list â„¤{isec:A,B} Ã— list â„¤{isec:A,B}
def split xs = case xs
  { [] â†’ [] , []
  ; [x] â†’ [] , [x]
  ; xâ‚âˆ·xâ‚‚âˆ·xs â†’
      let xsâ‚,xsâ‚‚ = split xs 
      in xâ‚âˆ·xsâ‚,xâ‚‚âˆ·xsâ‚‚
  }

def merge : 
    list â„¤{yao:C}
  â†’ list â„¤{yao:C}
  â†’ list â„¤{yao:C}
def merge xs ys = case xs,ys
  { [],_ â†’ ys
  ; _,[] â†’ xs
  ; xâˆ·xsâ€²,yâˆ·ysâ€² â†’
      list-cond (x â‰¤ y)
                (x âˆ· merge xsâ€² ys)
                (y âˆ· merge xs ysâ€²)
  }

def msort : list â„¤{isec:A,B} â†’ list â„¤{yao:C}
def msort xs = case xs 
  { [] â†’ []
  ; [xy] â†’
      let x = share{yao:C} xy.A
      let y = share{yao:C} xy.B
      let b = x â‰¤ y
      in [ b ? x â—‡ y ; b ? y â—‡ x ]
  ; xâ‚âˆ·xâ‚‚âˆ·xsâ€² â†’
      let xsâ‚,xsâ‚‚ = split xs

      let ysâ‚ : list â„¤{yao:C}
      let ysâ‚ = msort xsâ‚

      let ysâ‚ : list â„¤{yao:C}
      let ysâ‚‚ = msort xsâ‚‚

      in merge ysâ‚ ysâ‚‚
  }

def map f xs = case xs
  { [] â†’ []
  ; xâˆ·xsâ€² â†’ f xâˆ·map f xsâ€²
  }

def obliv-head : âˆ€ P:â˜†. â„¤ â†’ (list â„¤){isec:P} â†’ â„¤{isec:P}
def obliv-head P i xs = {P} case xs
  { [] â†’ i
  ; xâˆ·_ â†’ x
  }

def obliv-tail : âˆ€ P:â˜†. (list â„¤){isec:P} â†’ (list â„¤){isec:P}
def obliv-tail P xs = {P} case xs
  { [] â†’ []
  ; _âˆ·xsâ€² â†’ xsâ€²
  }

def preprocess-lists : (P:â„™) â†’ â„• â†’ â„¤ â†’ (list â„¤){isec:P} â†’ list â„¤{isec:P}
def preprocess-lists P n i xs =
  if n <= 0 
  then []
  else
    let xâ€² : â„¤{isec:P}
    let xâ€² = obliv-head P i xs
    let xsâ€² : list â„¤{isec:P}
    let xsâ€² = preprocess-lists P (n - 1) i (obliv-tail P xs)
    in 
    xâ€² âˆ· xsâ€²

def main : ğŸ™ â†’{inp:A,B;rev:E} list â„¤{ssec:E}
def main â€¢ = 
  let xys-pre : (list â„¤){isec:A,B}
  let xys-pre = {par:A,B} read (list â„¤) "msort-input.txt"
  let xys : list â„¤{isec:A,B}
  let xys = preprocess-lists set(A,B) 2 0 xys-pre
  in 
  map (Î» x â†’ reveal{E} x) (msort xys)
