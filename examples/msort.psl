principal A
principal B
principal C[2]
principal E

def list-cond : 
    ùîπ{yao:C} 
  ‚Üí list ‚Ñ§{yao:C}
  ‚Üí list ‚Ñ§{yao:C} 
  ‚Üí list ‚Ñ§{yao:C}
def list-cond b xs ys = case xs,ys
  { [], _ ‚Üí ys
  ; _, [] ‚Üí xs
  ; x ‚à∑ xs‚Ä≤,y ‚à∑ ys‚Ä≤ ‚Üí b ? x ‚óá y ‚à∑ list-cond b xs‚Ä≤ ys‚Ä≤
  }

def split : list ‚Ñ§{isec:A,B} ‚Üí list ‚Ñ§{isec:A,B} √ó list ‚Ñ§{isec:A,B}
def split xs = case xs
  { [] ‚Üí [] , []
  ; [x] ‚Üí [] , [x]
  ; x‚ÇÅ ‚à∑ x‚ÇÇ ‚à∑ xs ‚Üí
      let xs‚ÇÅ,xs‚ÇÇ = split xs
      in x‚ÇÅ ‚à∑ xs‚ÇÅ, x‚ÇÇ ‚à∑ xs‚ÇÇ
  }

def merge :
    list ‚Ñ§{yao:C}
  ‚Üí list ‚Ñ§{yao:C}
  ‚Üí list ‚Ñ§{yao:C}
def merge xs ys = case xs,ys
  { [], _ ‚Üí ys
  ; _, [] ‚Üí xs
  ; x ‚à∑ xs‚Ä≤, y ‚à∑ ys‚Ä≤ ‚Üí
      list-cond (x ‚â§ y)
                (x ‚à∑ merge xs‚Ä≤ ys)
                (y ‚à∑ merge xs ys‚Ä≤)
  }

def msort : list ‚Ñ§{isec:A,B} ‚Üí list ‚Ñ§{yao:C}
def msort xs = case xs 
  { [] ‚Üí []
  ; [xy] ‚Üí
      let x = share{yao:A -> C} xy@A
      let y = share{yao:B -> C} xy@B
      let b = x ‚â§ y
      in [ b ? x ‚óá y ; b ? y ‚óá x ]
  ; x‚ÇÅ‚à∑x‚ÇÇ‚à∑xs‚Ä≤ ‚Üí
      let xs‚ÇÅ,xs‚ÇÇ = split xs

      let ys‚ÇÅ : list ‚Ñ§{yao:C}
      let ys‚ÇÅ = msort xs‚ÇÅ

      let ys‚ÇÅ : list ‚Ñ§{yao:C}
      let ys‚ÇÇ = msort xs‚ÇÇ

      in merge ys‚ÇÅ ys‚ÇÇ
  }

def map f xs = case xs
  { [] ‚Üí []
  ; x‚à∑xs‚Ä≤ ‚Üí f x‚à∑map f xs‚Ä≤
  }

def main : ùüô ‚Üí{inp:A,B;rev:E} list ‚Ñ§{ssec:E}
def main ‚Ä¢ = 
  let xys-pre : (list ‚Ñ§){isec:A,B}
  let xys-pre = solo {A,B} as Œ± in read (list ‚Ñ§) from "msort-input.txt"
  let xys : list ‚Ñ§{isec:A,B}
  let xys = preprocess-lists {A,B} 5 0 xys-pre
  in map (Œª x ‚Üí reveal{E} x) (msort xys)
