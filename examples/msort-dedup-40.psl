principal A[40]
principal Central

-- alias names of operations that are already defined in stdlib:
-- def concat = uncurry append
def concat = uncurry cons

-- Listing 2: Pseudocode for merge sort
def merge_dedup (a, b) =
  let alen = len a in
  let blen = len b in
    if alen < 1n then sub-list b 1n blen
    else if blen < 1n then sub-list a 1n alen
    else if (reveal { A, Central } (arr_get a 1n) == (arr_get b 1n)) then
      merge_dedup (sub-list a 1n alen, sub-list b 2n blen)
    else mux if (arr_get a 1n) < (arr_get b 1n) then
      concat (arr_get a 1n,
              merge_dedup (sub-list a 2n alen, sub-list b 1n blen) )
    else mux when ((arr_get a 1n) > (arr_get b 1n)) then
      concat (arr_get b 1n,
              merge_dedup (sub-list a 1n alen, sub-list b 2n blen) )

-- Let A be an array data structure with index values starting with 1
def merge_sort_dedup a =
  let n = len a in
  if n > 1n then
    let m = n / 2n in
    merge_dedup (merge_sort_dedup (sub-list a 1n m),
                 merge_sort_dedup (sub-list a (m + 1n) n) )
  else [ arr_get a 1n ]

def main () =
  let inputs = solo { A } as a in read (int) from "msort-dedup-in.txt" in
  let input_ls =
    fold-f
      [ ]
      (fun Q input -> cons (share{bgv : Q -> A, Central } input)) inputs in
  let out = par { A, Central }
    (map (wrap-reveal { A }) (merge_sort_dedup input_ls)) in
  out
  -- par { A } send-ls A[0n] { A } out
