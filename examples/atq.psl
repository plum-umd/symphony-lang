principal A[96] -- Parties who supply just integers
principal B[32] -- Parties who supply both integers and queries

-- Query functions

-- First element because list is sorted
def min : list ℤ{bgw:A,B} → ℤ{bgw:A,B}
def min xs = case xs
  { x∷_ → x
  }

-- Last element because list is sorted
def max : list ℤ{bgw:A,B} → ℤ{bgw:A,B}
def max xs = case xs
  { [x] → x
  ; _∷xs' → max xs'
  }

-- Find the middle element (use the lower middle element if the length is even)
def median : list ℤ{bgw:A,B} → ℤ{bgw:A,B}
def median xs =
  let l = length xs
  let idx = l / 2
  let idx' = ((l % 2) ≡ 0) ? (idx - 1) ◇ idx
  in elem-at idx' xs

-- Recursive helper function for num-unique
def num-unique-rec : list ℤ{bgw:A,B} → ℤ{bgw:A,B} → ℤ{bgw:A,B}
def num-unique-rec xs last = case xs
  { [] → 0
  ; x∷xs' →
    let b = x ≡ last
    in (num-unique-rec xs' x) + (b ? 0 ◇ 1)
  }

-- Find the number of unique elements in the integer list
def num-unique : list ℤ{bgw:A,B} → ℤ{bgw:A,B}
def num-unique xs = case xs
  { [] → 0
  ; x∷xs' → (num-unique-rec xs' x) + 1
  }

-- mpc/list manip

def remove-dups :
    list ((ℤ{bgw:A,B} × ℙ{bgw:A,B}) + 𝟙)
  → list ((ℤ{bgw:A,B} × ℙ{bgw:A,B}) + 𝟙)
def remove-dups qs = case qs
  { [] → []
  ; queryOpt∷qs' →
    let queryOpt' =
      mux if (elem (λ x y →
        mux case x
        { L (x1, x2) →
          mux case y
          { L (y1, y2) → (y1 == x1) && (x2 == y2)
          ; R • → false
          }
        ; R • → false
        }
        ) queryOpt qs')
      then R •
      else queryOpt
    in queryOpt'::(remove-dups qs')
  }

-- Publishing results

def reveal-results :
    list (ℙ{bgw:A,B} × (ℤ{bgw:A,B} × ℤ{bgw:A,B}))
  → (ℤ{bundle:A,B} × ℤ{bundle:A,B})
def reveal-results xs = case xs
  { [] → ⟪⟫,⟪⟫
  ; (p,(q, r))∷xs' →
    let q' = reveal {p} q
    let r' = reveal {p} r
    let (qs,rs) = reveal-results xs'
    in ⟪p | q'⟫ ⧺ qs, ⟪p | r'⟫ ⧺ rs
  }

def publish-results :
    list ℤ{bgw:A,B}
  → list ((ℤ{bgw:A,B} × ℙ{bgw:A,B}) + 𝟙)
  → list (ℤ{bundle:A,B} × ℤ{bundle:A,B})
def publish-results results queryTargetOptionals = case queryTargetOptionals
  { [] → []
  ; qto∷remaining →
    let qto' =
      fold-p (λ l p →
        let out = mux case qto
          { L (q, t) → (p ≡ t ? q ◇ -1, p ≡ t ? elem-at q results ◇ -1)
          ; R • → (-1, -1)
          }
        in (p, out) ∷ l
      ) [] {A,B}
    let output = reveal-results qto'
    let remainingOutput = publish-results results remaining
    in output ∷ remainingOutput
  }

def post-process :
    list (ℤ{bundle:A,B} × ℤ{bundle:A,B})
  → (p:ℙ)
  → (list (𝕊{p} × ℤ{p})){p}
def post-process xs α = foldl xs [] (λ (q,r) l →
  let q' = q@α
  let r' = r@α
  if q' ≡ -1
  then l
  else
    let s =
      if 0 ≡ q' then "Median is " else
      if 1 ≡ q' then "Number Unique is " else
      if 2 ≡ q' then "Min is " else
      if 3 ≡ q' then "Max is " else ⊥
    in (s ⧻ (to_str r')) ∷ l
  )

-- ATQ

def main : 𝟙 →{inp:A,B;rev:A,B} list ℤ{any}
def main • = par {A,B}

  -- All parties read in data input
  let inputLists : (list ℤ){bundle:A,B}
  let inputLists = solo {A,B} as α in read (list ℤ) from "atq-data.txt"

  -- Parties in group B read in queries
  let inputQueries : ℤ{bundle:B}
  let inputQueries = solo {B} as α in read ℤ from "atq-query.txt"

  -- Parties in group B read in targets for the previously read in queries
  let inputTargets : (list ℙ){bundle:B}
  let inputTargets = solo {B} as α in read (list ℙ) from "atq-targets.txt"

  -- Secret share the elements of each party's list
  let inputListsShared : list list (ℤ{bgw:A,B})
  let inputListsShared = fold-f [] (λ P x i → (preprocess-lists-reveal-lengths P {A,B} x) ∷ i) inputLists

  -- Merge and sort the input lists into a single list
  let dataList : list ℤ{bgw:A,B}
  let dataList = concat inputListsShared

  -- Produce a single sorted list of all input integers
  let dataListSorted : list ℤ{bgw:A,B}
  let dataListSorted = sort (λ a b → mux if a ≤ b then true else false) dataList

  -- Find the median of the integer list
  let medianResult : ℤ{bgw:A,B}
  let medianResult = median dataListSorted

  -- Find the number of unique elements in the integer list
  let uniqueResult : ℤ{bgw:A,B}
  let uniqueResult = num-unique dataListSorted

  -- Find the minimum value in the integer list
  let minResult : ℤ{bgw:A,B}
  let minResult = min dataListSorted

  -- Find the maximum value in the integer list
  let maxResult : ℤ{bgw:A,B}
  let maxResult = max dataListSorted

  -- Group results into an indexable data structure
  let results : list ℤ{bgw:A,B}
  let results = [medianResult; uniqueResult; minResult; maxResult]

  -- Pair the input queries and targets up along with a tag denoting that it is not dummy data
  let queriesWithTargets : (list (ℤ{B} × ℙ{B})){bundle:B}
  let queriesWithTargets = solo {B} as α in (pair-with-list inputQueries@α inputTargets@α)

  -- Secret share queries and targets without revealing the number of targets each party supplied by setting an upper bound and padding data out with dummy data
  let queriesWithTargetsShared : list list ((ℤ{bgw:A,B} × ℙ{bgw:A,B}) + 𝟙)
  let queriesWithTargetsShared = fold-f [] (λ P x i → (preprocess-lists-n-pairs P {A,B} 8 x) ∷ i) queriesWithTargets

  -- Combine queries and targets into one list
  let allQueriesWithTargetsShared : list ((ℤ{bgw:A,B} × ℙ{bgw:A,B}) + 𝟙)
  let allQueriesWithTargetsShared = concat queriesWithTargetsShared

  -- Remove duplicate queries so that recipients will not learn how many times they were targeted
  let finalQueries : list ((ℤ{bgw:A,B} × ℙ{bgw:A,B}) + 𝟙)
  let finalQueries = remove-dups allQueriesWithTargetsShared

  -- For each query from each party in B with duplicates replaced by dummy data, plus dummy padding to achieve upper bounds, publish the results of the query to the target of the query
  let published-results = publish-results results finalQueries

  -- Have each party post-process the output to make things look nice
  in solo {A,B} as α in post-process published-results α

