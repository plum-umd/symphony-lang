principal A[2] -- Parties who supply just integers
principal B[2] -- Parties who supply both integers and queries
principal NONE

-- basic functions

def length :
    list â„¤{bgw:A,B}
  â†’ â„¤{bgw:A,B}
def length xs = case xs
  { [] â†’ 0
  ; xâˆ·xs' â†’ length xs' + 1
  }

def elem :
    â„¤{bgw:A,B}
  â†’ list â„¤{bgw:A,B}
  â†’ ğ”¹{bgw:A,B}
def elem y xs = case xs
  { [] â†’ share{bgw:A,B} false
  ; xâˆ·xs â†’
    let b = x == y
    in b ? (share{bgw:A,B} true) â—‡ (elem y xs)
  }

def elem-pair :
    (â„¤{bgw:A,B} Ã— â„™{bgw:A,B})
  â†’ list (â„¤{bgw:A,B} Ã— â„™{bgw:A,B})
  â†’ ğ”¹{bgw:A,B}
def elem-pair y xs = case (xs,y)
  { ([],_) â†’ share{bgw:A,B} false
  ; ((a,b)âˆ·xs,(a',b')) â†’
    let b = (a == a') && (b == b')
    in b ? (share{bgw:A,B} true) â—‡ (elem-pair y xs)
  }

def elem-at :
    â„¤{bgw:A,B}
  â†’ list â„¤{bgw:A,B}
  â†’ â„¤{bgw:A,B}
def elem-at i xs = case xs
  { [] â†’ share{bgw:A,B} -1
  ; xâˆ·xs' â†’
    let b = i â‰¡ (share{bgw:A,B} 0)
    in b ? x â—‡ (elem-at (i - (share{bgw:A,B} 1)) xs')
  }


-- query functions

def min : list â„¤{bgw:A,B} â†’ â„¤{bgw:A,B}
def min xs = case xs
  { [x] â†’ x
  ; xâˆ·xs' â†’
    let y = min xs'
    let b = ((x â‰¥ 0) && (x < y)) || (y < 0)
    in b ? x â—‡ y
  }


def max : list â„¤{bgw:A,B} â†’ â„¤{bgw:A,B}
def max xs = case xs
  { [x] â†’ x
  ; xâˆ·xs' â†’
    let y = max xs'
    let b = ((x â‰¥ 0) && (x > y)) || (y < 0)
    in b ? x â—‡ y
  }


def median : list â„¤{bgw:A,B} â†’ â„¤{bgw:A,B}
def median xs = share{bgw:A,B} 0 -- not implemented


def num-unique-rec : list â„¤{bgw:A,B} â†’ list â„¤{bgw:A,B} â†’ â„¤{bgw:A,B} â†’ â„¤{bgw:A,B}
def num-unique-rec xs seen = case xs
  { [] â†’ length seen
  ; xâˆ·xs â†’
    let b = (x < 0) || (elem x seen)
    in b ? num-unique-rec xs seen â—‡ num-unique-rec xs (xâˆ·seen)
  }

def num-unique : list â„¤{bgw:A,B} â†’ â„¤{bgw:A,B}
def num-unique xs = num-unique-rec xs []

-- mpc/list manip

def pfold : âˆ€ A:â˜†,P:â„™. â„¤ â†’ ((Q:â„™ | QâŠ†P) â†’ â„¤{Q} â†’ A â†’ A) â†’ â„¤{isec:P} â†’{sec:P} A
def pfold i f xy = case xy
  { âŸªâŸ« â†’ i
  ; âŸªQ.xâŸ«â§ºxyâ€² â†’ f Q x (pfold i f xyâ€²)
  }

def obliv-head : âˆ€ P:â„™. â„¤ â†’ (list â„¤){isec:P} â†’ â„¤{isec:P}
def obliv-head P i xs = {P} case xs
  { [] â†’ i
  ; xâˆ·_ â†’ x
  }

def obliv-tail : âˆ€ P:â„™. (list â„¤){isec:P} â†’ (list â„¤){isec:P}
def obliv-tail P xs = {P} case xs
  { [] â†’ []
  ; _âˆ·xsâ€² â†’ xsâ€²
  }

def preprocess-lists : (P:â„™) â†’ â„• â†’ â„¤ â†’ (list â„¤){isec:P} â†’ list â„¤{isec:P}
def preprocess-lists P n i xs =
  if n <= 0 
  then []
  else
    let xâ€² : â„¤{isec:P}
    let xâ€² = obliv-head P i xs
    let xsâ€² : list â„¤{isec:P}
    let xsâ€² = preprocess-lists P (n - 1) i (obliv-tail P xs)
    in 
    xâ€² âˆ· xsâ€²

def append :
    list â„¤{bgw:A,B}
  â†’ list â„¤{bgw:A,B}
  â†’ list â„¤{bgw:A,B}
def append xs ys = case xs
  { [] â†’ ys
  ; (xâˆ·xs) â†’ append xs (xâˆ·ys)
  }

def combine-lists : list â„¤{isec:A,B} â†’ list â„¤{bgw:A,B}
def combine-lists xs = case xs
  { [] â†’ []
  ; xâˆ·xs' â†’ append (pfold [] (Î» Q x' i â†’ (share{bgw:A,B} x') âˆ· i) x) (combine-lists xs')
  }

def zip xs ys = case (xs,ys)
  { ([],_) â†’ []
  ; (_,[]) â†’ []
  ; (xâˆ·xs',yâˆ·ys') â†’ (x,y)âˆ·(zip xs' ys')
  }

def remove-dups :
    list (â„¤{bgw:A,B} Ã— â„™{bgw:A,B})
  â†’ list (â„¤{bgw:A,B} Ã— â„™{bgw:A,B})
def remove-dups qs = case qs
  { [] â†’ []
  ; (q,t)âˆ·qs' â†’
    let b = Â¬(elem-pair (q,t) qs')
    let h1 = b ? q â—‡ share{bgw:A,B} (-1)
    let h2 = b ? t â—‡ share{bgw:A,B} set(NONE)
    in (h1,h2)âˆ·(remove-dups qs')
  }

-- atq

def run-queries :
    list â„¤{bgw:A,B}
  â†’ list â„¤{bgw:A,B}
def run-queries xs = (min xs) âˆ· (max xs) âˆ· (median xs) âˆ· (num-unique xs) âˆ· []

def send-result :
    (t : â„™{ssec:A,B})
  â†’ list â„¤{bgw:A,B}
  â†’ â„¤{bgw:A,B}
  â†’ â„¤{ssec:t}
def send-result t results q =
  reveal{t} (elem-at q results)

def send-results :
    list â„¤{bgw:A,B}
--  â†’ list (â„¤{bgw:A,B},â„™{bgw:A,B})
  â†’ list â„¤{ssec:any}
def send-results results ps = case ps
  { [] â†’ []
  ; (q,t)âˆ·ps' â†’ (send-result (reveal{A,B} t) results q) âˆ· (send-results results ps')
  }

def main : ğŸ™ â†’{inp:A,B;rev:A,B} list â„¤{ssec:any}
def main â€¢ =
  let xs-pre : (list â„¤){isec:A,B}
  let xs-pre = {par:A,B} read (list â„¤) "atq-data.txt"
  let qs-pre : (list â„¤){isec:B}
  let qs-pre = {par:B} read (list â„¤) "atq-queries.txt"
  let ts-pre : (list â„™){isec:B}
  let ts-pre = {par:B} read (list â„™) "atq-targets.txt"
  
  let xs : list â„¤{isec:A,B}
  let xs = preprocess-lists set(A,B) 2 -1 xs-pre
  let qs : list â„¤{isec:B}
  let qs = preprocess-lists set(B) 3 -1 qs-pre
  let ts : list â„™{isec:B}
  let ts = preprocess-lists set(B) 3 set(NONE) ts-pre

  let xs' : list â„¤{bgw:A,B}
  let xs' = combine-lists xs
  let qs' : list â„¤{bgw:A,B}
  let qs' = combine-lists qs
  let ts' : list â„™{bgw:A,B}
  let ts' = combine-lists ts

  let ps : list (â„¤{bgw:A,B} Ã— â„™{bgw:A,B})
  let ps = zip qs' ts'
  let ps' : list (â„¤{bgw:A,B} Ã— â„™{bgw:A,B})
  let ps' = remove-dups ps

  let results : list â„¤{bgw:A,B}
  let results = run-queries xs'

  in {par:A,B} send-results results ps'
