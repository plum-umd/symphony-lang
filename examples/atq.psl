principal A[2] -- Parties who supply just integers
principal B[2] -- Parties who supply both integers and queries
principal Dummy

-- basic functions

def elem-triple :
    (𝔹{bgw:A,B} × (ℤ{bgw:A,B} × ℙ{bgw:A,B}))
  → list (𝔹{bgw:A,B} × (ℤ{bgw:A,B} × ℙ{bgw:A,B}))
  → 𝔹{bgw:A,B}
def elem-triple y xs = case (xs,y)
  { ([],_) → false
  ; ((_,(a,b))∷xs,(a',b')) →
    let b = (a == a') && (b == b')
    in b ? true ◇ (elem-triple y xs)
  }

def elem-at :
    ℤ{bgw:A,B}
  → list ℤ{bgw:A,B}
  → ℤ{bgw:A,B}
def elem-at i xs = case xs
  { [] → -1
  ; x∷xs' →
    let b = i ≡ 0
    in b ? x ◇ (elem-at (i - 1) xs')
  }

-- query functions

def min : list ℤ{bgw:A,B} → ℤ{bgw:A,B}
def min xs = case xs
  { x∷_ → x
  }

def max : list ℤ{bgw:A,B} → ℤ{bgw:A,B}
def max xs = case xs
  { [x] → x
  ; _∷xs' → max xs'
  }

def median : list ℤ{bgw:A,B} → ℤ{bgw:A,B}
def median xs =
  let l = length xs
  let idx = l / 2
  let idx' = ((l % 2) ≡ 0) ? (idx - 1) ◇ idx
  in elem-at idx' xs

def num-unique-rec : list ℤ{bgw:A,B} → ℤ{bgw:A,B} → ℤ{bgw:A,B}
def num-unique-rec xs last = case xs
  { [] → 0
  ; x∷xs' →
    let b = x ≡ last
    in (num-unique-rec xs' x) + (b ? 0 ◇ 1)
  }

def num-unique : list ℤ{bgw:A,B} → ℤ{bgw:A,B}
def num-unique xs = case xs
  { [] → 0
  ; x∷xs' → (num-unique-rec xs' x) + 1
  }

-- mpc/list manip

def remove-dups :
    list (𝔹{bgw:A,B} × (ℤ{bgw:A,B} × ℙ{bgw:A,B}))
  → list (𝔹{bgw:A,B} × (ℤ{bgw:A,B} × ℙ{bgw:A,B}))
def remove-dups qs = case qs
  { [] → []
  ; (a,(q,t))∷qs' →
    let b = elem-triple (q,t) qs'
    let a' = b ? false ◇ a
    let q' = b ? -1 ◇ q
    let t' = b ? {Dummy} ◇ t
    in (a',(q',t'))∷(remove-dups qs')
  }

def pair-with-list v xs = case xs
  { [] → []
  ; x∷xs' → (v, x)∷(pair-with-list v xs')
  }

def share-triple p t x = case x
  { (v₁,(v₂,v₃)) → (share{bgw:p → t} v₁, (share{bgw:p → t} v₂, share{bgw:p → t} v₃))
  }

def get-head-or-default p ys d =
  par {p} case ys
    { [] → d
    ;y∷_ → y
    }

def p-lists-n-triples p t len zs d =
  if len == 0
  then []
  else
    let v = get-head-or-default p zs d
    let b = par {p} fst v
    let q = par {p} fst (snd v)
    let tr = par {p} snd (snd v)
    in (share{bgw:p → t} b, (share{bgw:p → t} q, share{bgw:p → t} tr)) ∷ (p-lists-n-triples p t (len - 1) (par {p} tail zs) d)

def p-lists-n p t len zs d =
  if len == 0
  then []
  else (share{bgw:p → t} (get-head-or-default p zs d)) ∷ (p-lists-n p t (len - 1) (par {p} tail zs) d)

def p-lists p t xs d =
  let l = par {p} length xs
  let l' = send {p → t} l
  in p-lists-n p t l' xs d

-- atq

def run-queries :
    list ℤ{bgw:A,B}
  → list ℤ{bgw:A,B}
def run-queries xs = (min xs) ∷ (max xs) ∷ (median xs) ∷ (num-unique xs) ∷ []

def send-result :
    ℙ{bgw:A,B}
  → (t : ℙ{ssec:A,B})
  → ℤ{bgw:A,B}
  → 𝔹{bgw:A,B}
  → list (𝔹{ssec:t} × ℤ{ssec:t}) --Not an accurate type
def send-result P t r a = case P
  { {} → []
  ; {p}∪P' →
    let b = a ? (t ≡ p) ◇ false
    let v = a ? ((t ≡ p) ? r ◇ -1) ◇ -1
    in (reveal {p} b, reveal {p} v) ∷ (send-result P' t r a)
  }

def send-results :
    list ℤ{bgw:A,B}
  → list (𝔹{bgw:A,B} × (ℤ{bgw:A,B} × ℙ{bgw:A,B}))
  → list ℤ{ssec:any}
def send-results results ps = case ps
  { [] → []
  ; (a,(q,t))∷ps' → (send-result {A,B} (reveal{A,B} t) (elem-at q results) a) ∷ (send-results results ps')
  }

def main : 𝟙 →{inp:A,B;rev:A,B} list ℤ{ssec:any}
def main • =
  let xs-pre : (list ℤ){isec:A,B}
  let xs-pre = solo {A,B} as α in read (list ℤ) from "atq-data.txt"
  let qs-pre : (list ℤ){isec:B}
  let qs-pre = solo {B} as α in read (list ℤ) from "atq-queries.txt"
  let ts-pre : (list ℙ){isec:B}
  let ts-pre = solo {B} as α in read (list ℙ) from "atq-targets.txt"

  let xs : list ℤ{bgw:A,B}
  let xs = par {A,B} msort (concat (fold-f [] (λ P x i → (p-lists P {A,B} x 0) ∷ i) xs-pre))
  let results : list ℤ{bgw:A,B}
  let results = par {A,B} run-queries xs

  let qs = solo {B} as α in (pair-with-list true (zip qs-pre@α ts-pre@α))
  let qs' = concat (fold-f [] (λ P x i → (p-lists-n-triples P {A,B} 3 x (false,(-1,{Dummy}))) ∷ i) qs)

  let qs'' : list (ℤ{bgw:A,B} × ℙ{bgw:A,B})
  let qs'' = remove-dups qs'

  in par {A,B} send-results results qs''

