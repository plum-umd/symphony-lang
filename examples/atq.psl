principal A[2] -- Parties who supply just integers
principal B[2] -- Parties who supply both integers and queries
principal Dummy

-- basic functions

def elem-triple :
    (ğ”¹{bgw:A,B} Ã— (â„¤{bgw:A,B} Ã— â„™{bgw:A,B}))
  â†’ list (ğ”¹{bgw:A,B} Ã— (â„¤{bgw:A,B} Ã— â„™{bgw:A,B}))
  â†’ ğ”¹{bgw:A,B}
def elem-triple y xs = case (xs,y)
  { ([],_) â†’ false
  ; ((_,(a,b))âˆ·xs,(a',b')) â†’
    let b = (a == a') && (b == b')
    in b ? true â—‡ (elem-triple y xs)
  }

def elem-at :
    â„¤{bgw:A,B}
  â†’ list â„¤{bgw:A,B}
  â†’ â„¤{bgw:A,B}
def elem-at i xs = case xs
  { [] â†’ -1
  ; xâˆ·xs' â†’
    let b = i â‰¡ 0
    in b ? x â—‡ (elem-at (i - 1) xs')
  }

-- query functions

def min : list â„¤{bgw:A,B} â†’ â„¤{bgw:A,B}
def min xs = case xs
  { xâˆ·_ â†’ x
  }

def max : list â„¤{bgw:A,B} â†’ â„¤{bgw:A,B}
def max xs = case xs
  { [x] â†’ x
  ; _âˆ·xs' â†’ max xs'
  }

def median : list â„¤{bgw:A,B} â†’ â„¤{bgw:A,B}
def median xs =
  let l = length xs
  let idx = l / 2
  let idx' = ((l % 2) â‰¡ 0) ? (idx - 1) â—‡ idx
  in elem-at idx' xs

def num-unique-rec : list â„¤{bgw:A,B} â†’ â„¤{bgw:A,B} â†’ â„¤{bgw:A,B}
def num-unique-rec xs last = case xs
  { [] â†’ 0
  ; xâˆ·xs' â†’
    let b = x â‰¡ last
    in (num-unique-rec xs' x) + (b ? 0 â—‡ 1)
  }

def num-unique : list â„¤{bgw:A,B} â†’ â„¤{bgw:A,B}
def num-unique xs = case xs
  { [] â†’ 0
  ; xâˆ·xs' â†’ (num-unique-rec xs' x) + 1
  }

-- mpc/list manip

def remove-dups :
    list (ğ”¹{bgw:A,B} Ã— (â„¤{bgw:A,B} Ã— â„™{bgw:A,B}))
  â†’ list (ğ”¹{bgw:A,B} Ã— (â„¤{bgw:A,B} Ã— â„™{bgw:A,B}))
def remove-dups qs = case qs
  { [] â†’ []
  ; (a,(q,t))âˆ·qs' â†’
    let b = elem-triple (q,t) qs'
    let a' = b ? false â—‡ a
    let q' = b ? -1 â—‡ q
    let t' = b ? {Dummy} â—‡ t
    in (a',(q',t'))âˆ·(remove-dups qs')
  }

def pair-with-list v xs = case xs
  { [] â†’ []
  ; xâˆ·xs' â†’ (v, x)âˆ·(pair-with-list v xs')
  }

def share-triple p t x = case x
  { (vâ‚,(vâ‚‚,vâ‚ƒ)) â†’ (share{bgw:p â†’ t} vâ‚, (share{bgw:p â†’ t} vâ‚‚, share{bgw:p â†’ t} vâ‚ƒ))
  }

def get-head-or-default p ys d =
  par {p} case ys
    { [] â†’ d
    ;yâˆ·_ â†’ y
    }

def p-lists-n-triples p t len zs d =
  if len == 0
  then []
  else
    let v = get-head-or-default p zs d
    let b = par {p} fst v
    let q = par {p} fst (snd v)
    let tr = par {p} snd (snd v)
    in (share{bgw:p â†’ t} b, (share{bgw:p â†’ t} q, share{bgw:p â†’ t} tr)) âˆ· (p-lists-n-triples p t (len - 1) (par {p} tail zs) d)

def p-lists-n p t len zs d =
  if len == 0
  then []
  else (share{bgw:p â†’ t} (get-head-or-default p zs d)) âˆ· (p-lists-n p t (len - 1) (par {p} tail zs) d)

def p-lists p t xs d =
  let l = par {p} length xs
  let l' = send {p â†’ t} l
  in p-lists-n p t l' xs d

-- atq

def run-queries :
    list â„¤{bgw:A,B}
  â†’ list â„¤{bgw:A,B}
def run-queries xs = (min xs) âˆ· (max xs) âˆ· (median xs) âˆ· (num-unique xs) âˆ· []

def send-result :
    â„™{bgw:A,B}
  â†’ (t : â„™{ssec:A,B})
  â†’ â„¤{bgw:A,B}
  â†’ ğ”¹{bgw:A,B}
  â†’ list (ğ”¹{ssec:t} Ã— â„¤{ssec:t}) --Not an accurate type
def send-result P t r a = case P
  { {} â†’ []
  ; {p}âˆªP' â†’
    let b = a ? (t â‰¡ p) â—‡ false
    let v = a ? ((t â‰¡ p) ? r â—‡ -1) â—‡ -1
    in (reveal {p} b, reveal {p} v) âˆ· (send-result P' t r a)
  }

def send-results :
    list â„¤{bgw:A,B}
  â†’ list (ğ”¹{bgw:A,B} Ã— (â„¤{bgw:A,B} Ã— â„™{bgw:A,B}))
  â†’ list â„¤{ssec:any}
def send-results results ps = case ps
  { [] â†’ []
  ; (a,(q,t))âˆ·ps' â†’ (send-result {A,B} (reveal{A,B} t) (elem-at q results) a) âˆ· (send-results results ps')
  }

def main : ğŸ™ â†’{inp:A,B;rev:A,B} list â„¤{ssec:any}
def main â€¢ =
  let xs-pre : (list â„¤){isec:A,B}
  let xs-pre = solo {A,B} as Î± in read (list â„¤) from "atq-data.txt"
  let qs-pre : (list â„¤){isec:B}
  let qs-pre = solo {B} as Î± in read (list â„¤) from "atq-queries.txt"
  let ts-pre : (list â„™){isec:B}
  let ts-pre = solo {B} as Î± in read (list â„™) from "atq-targets.txt"

  let xs : list â„¤{bgw:A,B}
  let xs = par {A,B} msort (concat (fold-f [] (Î» P x i â†’ (p-lists P {A,B} x 0) âˆ· i) xs-pre))
  let results : list â„¤{bgw:A,B}
  let results = par {A,B} run-queries xs

  let qs = solo {B} as Î± in (pair-with-list true (zip qs-pre@Î± ts-pre@Î±))
  let qs' = concat (fold-f [] (Î» P x i â†’ (p-lists-n-triples P {A,B} 3 x (false,(-1,{Dummy}))) âˆ· i) qs)

  let qs'' : list (â„¤{bgw:A,B} Ã— â„™{bgw:A,B})
  let qs'' = remove-dups qs'

  in par {A,B} send-results results qs''

