principal Node_in[24]
principal External


-- Listing 4: Pseudocode for quick sort partition
def partition (a, lo, hi) =
  -- In order to avoid deterministic worst case behaviour pick the
  -- pivot element at random and put it in the alst position (HI)

  -- random (LO, HI) selects a random integer between LO and HI,
  -- inclusively
  do swap a (rand-range nat{ spdz:Node_in } (lo, hi)) hi

  -- Now use A[HI] as the pivot value

  -- Elements in positions below I will be known to be less than the
  -- pivot value
  let i = ref lo 

  -- Compare each element of A with the pivot value A[HI], and if less
  -- than the pivot value, move it to the beginning of the list
  do sec-iter [ a ; i ] lo hi (len !a) (fun j ->
      upd-if [ a ; i ] ((sec-get !a j) < (sec-get !a hi)) (fun () ->
        (do swap a !i j in
         i := !i + 1n) ) )

  -- Move the pivot value into its right place
  do swap a !i hi in

  -- Now the pivot value is in A[I] and all the elements smaller than
  -- the pivot are before it in A[]

  -- Return the pivot index I
  !i


-- Listing 3: Pseudocode for quick sort
def sec quick_sort (a, lo, hi) = 
    upd-if [ a ] (lo < hi) (fun () ->
      -- Find PIVOT: e < PIVOT <=> A[e] < A[PIVOT]; e > PIVOT <=> A[e]
      -- > A[PIVOT]
      let pivot = partition (a, lo, hi)

      -- Recursively sort the elements smaller than PIVOT
      do quick_sort (a, lo, sec-dec pivot) in

      -- Recursively Sort the elements larger than PIVOT
      quick_sort (a, pivot + 1n, hi) )


-- verify inputs result: NIZK proof that result has signed inputs from
-- each party and is sorted
def verify inputs result =
  let mk-wit = fun x -> nizk-witness{ spdz : Node_in } x in
  let mk-const-wit = fun c ->
    mk-wit (share{ spdz : Node_in.0 -> Node_in} c) in
  let test-true = mk-const-wit true in
  let test-false = mk-const-wit false in
  let test-zero = mk-const-wit 0n in
  let test-one = mk-const-wit 1n in
  let test-ub = mk-const-wit 8n in

  -- input-wits: bundle of witnesses built from signed inputs:
  let input-wits = map mk-wit inputs in

  -- all-inputs-signed: test that each input is signed
  let all-inputs-signed = elim-list input-wits
    test-true
    (fun w -> and 
      (elim-prins Node_in
         test-false
         (fun N -> or (wrap-is-signed N w)) ) ) in

  let test-count = fun p l -> elim-list l
    test-zero
    (fun x -> plus (mux if p x then test-one else test-zero) ) in

  -- bounded-sig-nums: number of inputs signed by each party is in bounds
  let bounded-sig-nums = elim-prins Node_in
    test-true
    (fun P -> and
       ((test-count (fun x -> wrap-is-signed P x) input-wits) <= test-ub) ) in

  -- res-wits: witnesses from the sorted result
  let res-wits = map (fun x -> nizk-witness{ spdz : Node_in } x) result in

  -- res-is-perm: test that unsignature of each input is in result:
  let res-is-perm =
    let unsigned = map wrap-unsign input-wits in
    elim-list unsigned
      test-true
      (fun i -> and
         (let i-count = test-count (eq i) in
          (i-count unsigned) == (i-count res-wits) ) ) in

  -- test-is-sorted: test that the list is sorted:
  let res-is-sorted =
    let test-is-sorted = elim-list res-wits
      (L ())
      (fun x acc -> R
         (x,
          case acc
          { L _ -> test-true
          ; R (x', is-sorted') -> and (x <= x') is-sorted'
          }) ) in
    case test-is-sorted
      { L _ -> test-true
      ; R (_, t) -> t
      } in

  -- commit to witness for all tests
  nizk-commit { spdz : Node_in }
    (all-inputs-signed &&
     bounded-sig-nums &&
     res-is-perm &&
     res-is-sorted)


def main () =
  let (sorted, corr-pf) = par{ Node_in }
    -- inputs: shares of the inputs
    let inputs = fold-f
      [ ]
      (fun N l -> append 
        (map (fun x -> share{ spdz : N -> Node_in } x)
           (send-ls { N } { Node_in } l) ) )
      (solo { Node_in } as N in
         map (wrap-sign N) (read (list flt) from "quick-sort-in.txt") ) in
    let unsigned-inputs = map wrap-unsign inputs in

    -- run the sorting function:
    let n = len unsigned-inputs in
    let ls-ref = ref unsigned-inputs in
    do eval-upto quick_sort n (ls-ref, 0n, n - 1n) in
    let sorted = !ls-ref in
    (map (wrap-reveal Node_in) sorted, verify inputs sorted) in
  (sorted, send { Node_in.0 -> External } corr-pf)
