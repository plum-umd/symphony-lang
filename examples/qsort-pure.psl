principal A
principal B

-- TODO
-- generalize to 64 players
-- why does random selection not work?


def swap-indexes i j arr =
  let _, l = vec-read i arr
  let _, r = vec-read j arr
  in
    vec-write i r (vec-write j l arr)


def partLoop n i j hi arr =
  if n == 0
  then
    arr, i
  else
    let _, x = vec-read j arr
    let _, y = vec-read hi arr
    let arr, i' =
      mux if (x < y)
           then swap-indexes i j arr, i + 1
           else arr, i
    let j' = mux if (j < hi) then j + 1 else j
    in
      partLoop (n - 1) i' j' hi arr


def partition n lo hi arr =
  -- TODO why do the following lines not work?
  -- let r = rand-range int{bgw:this} (lo,hi) in
  -- let arr = swap-indexes r hi arr in
  let arr', pivot = partLoop n lo lo hi arr
  in (swap-indexes pivot hi arr', pivot)


def quickSort n lo hi arr =
  if n == 0
  then arr
  else
    let partitioned, pivot = partition n lo hi arr
    in
      mux if (lo >= hi)
           then arr
           else
             quickSort (n - 1) (pivot + 1) hi
               (quickSort (n - 1) lo (pivot - 1) partitioned)

def main : unit -> {inp:A,B ; rev:A,B} (list flt)
def main () =
  par {A,B}
    let sbool = fun P -> (fun x -> share{bgw:P -> this} x)
    let sflt = fun P -> (fun x -> share{bgw:P -> this} x)
    let rflt = fun f -> reveal {this} f

    let a = share-as-vec A (sbool A) (sflt A) 0.0 10
      (par {A} read (list flt) from "qsort-input.txt")
    let b = share-as-vec B (sbool B) (sflt B) 0.0 10
      (par {B} read (list flt) from "qsort-input.txt")

    let inps = vec-append a b

    let n = vec-capacity inps
    in
      vec-reveal rflt (quickSort n 0 (n - 1) inps)
