principal A
principal B

-- TODO
-- generalize to 64 players
-- why does random selection not work?


-- def swap-indexes
--    : bool{bgw:this}
--   -> nat{bgw:this}
--   -> nat{bgw:this}
--   -> vec{bgw:this} flt
--   -> vec{bgw:this} flt
def swap-indexes cond i j arr =
  let _, l = vec-read i arr
  let _, r = vec-read j arr
  in
    vec-cond-write cond i r (vec-cond-write cond j l arr)


-- def partLoop
--   : nat -- remaining iterations
--   -> nat{bgw:this}
--   -> nat{bgw:this}
--   -> nat{bgw:this}
--   -> vec{bgw:this} flt
--   -> vec{bgw:this} flt * nat{bgw:this}
def partLoop n i j hi arr =
  if n == 0
  then
    arr, i
  else
    let _, x = vec-read j arr
    let _, y = vec-read hi arr
    let cond = x < y
    let arr = swap-indexes cond i j arr
    let i' = i + (cond ? 1 >< 0)
    let j' = (j < hi) ? j + 1 >< j
    in
      partLoop (n - 1) i' j' hi arr


-- def partition
--   : nat -- the size of the entire list
--   -> nat{bgw:this}
--   -> nat{bgw:this}
--   -> vec{bgw:this} flt
--   -> vec{bgw:this} flt * nat{bgw:this}
def partition n lo hi arr =
  -- TODO why do the following lines not work?
  -- let r = rand-range int{bgw:this} (lo,hi) in
  -- let arr = swap-indexes true r hi arr in
  let arr', pivot = partLoop n lo lo hi arr
  in (swap-indexes true pivot hi arr', pivot)


-- def quickSort
--   : nat -- iterations remaining
--   -> nat{bgw:this} -- lo
--   -> nat{bgw:this} -- hi
--   -> vec{bgw:this} flt
--   -> vec{bgw:this} flt
def quickSort n lo hi arr =
  if n == 0
  then arr
  else
    let partitioned, pivot = partition n lo hi arr
    let sorted =
      quickSort (n - 1) (pivot + 1) hi
        (quickSort (n - 1) lo (pivot - 1) partitioned)
    in
      vec-swap (lo >= hi) arr sorted


def main : unit -> {inp:A,B ; rev:A,B} (list flt)
def main () =
  par {A,B}
    let sbool = fun P -> (fun x -> share{bgw:P -> this} x)
    let sflt = fun P -> (fun x -> share{bgw:P -> this} x)
    let rflt = fun f -> reveal {this} f

    let a = share-as-vec A (sbool A) (sflt A) 0.0 flt-swap 10
      (par {A} read (list flt) from "qsort-input.txt")
    let b = share-as-vec B (sbool B) (sflt B) 0.0 flt-swap 10
      (par {B} read (list flt) from "qsort-input.txt")

    let inps = vec-append a b

    let n = vec-capacity inps
    in
      vec-reveal rflt (quickSort n 0 (n - 1) inps)
