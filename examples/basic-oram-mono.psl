principal A B

{-
==============================================
================ TRIVIAL ORAM ================
==============================================
-}

{-
type client-data = ℕ{yao:A,B}
-}

def default-client-data : 𝟙 → client-data
def default-client-data • = 0

{-
type block = { occupied : 𝔹{yao:A,B}
             ; idx      : ℕ{yao:A,B}
             ; data     : client-data
             }
-}

def default-block : 𝟙 → block
def default-block • = (false, 0, default-client-data •)

{-
type trivial = block array
-}

{- Read and Remove on a Trivial ORAM.

   Takes a Trivial ORAM `oram` and looks up the block at `idx`. The `real` parameter
   indicates if this operation is a real operation, or just a dummy being used to preserve
   obliviousness. The purpose of this argument is so that we may call `rr-rec` with
   an index that actually exists in the ORAM but not remove it. -}

def rr-rec : trivial → 𝔹{yao:A,B} → ℕ{yao:A,B} → block
def rr-rec oram real idx =
  -- iter : block → ℕ → block
  let iter =
    λ [iter] acc i →
      if i == nat (size oram) then
        acc
      else
        let c          = oram.i
        let (_,idx',_) = c
        let swap       = real && idx == idx'
        let (c',acc')  = mux if ¬ swap then (c, acc) else (acc, c)
        let _          = oram.i ← c' in
        iter acc' (i + 1n)
  in
  iter (default-block •) 0n

def rr : trivial → ℕ{yao:A,B} → client-data
def rr oram idx =
  let (_,_,result) = rr-rec oram true idx in
  result

{- Add on a Trivial ORAM.

   Takes a Trivial ORAM `oram` and adds the block `blk` to the first empty cell. -}

def add-rec : trivial → 𝔹{yao:A,B} → block → 𝟙
def add-rec oram real blk =
  -- iter : block → ℕ → 𝟙
  let iter =
    λ [iter] acc i →
      if i == nat (size oram) then
        •
      else
        let c               = oram.i
        let (occupied',_,_) = c.occupied
        let swap            = real && ¬ occupied'
        let (c', acc')      = mux if ¬ swap then (c, acc) else (acc, c)
        let _               = oram.i ← c' in
        iter acc' (i + 1n)
  in
  iter blk 0n

def add : trivial → ℕ{yao:A,B} → client-data → 𝟙
def add oram idx v =
  let blk = (true, idx, v) in
  add-rec oram true blk

{- Initialize a new Trivial ORAM. -}

def initialize : ℕ → trivial
def initialize n = array[n] (λ _ → default-block •)

{-

{-
===========================================
================ TREE ORAM ================
===========================================
-}

type α pos = { pos  : ℕ{yao:A,B}
             ; data : α{yao:A,B}
             }

instance Default α => Default (α pos) where
  default ∙ = { pos  = rand ℕ
              ; data = default ∙
              }

{- A Tree ORAM is (complete) tree of Trivial ORAMs, known as buckets. Each block
   contains an extra piece of data called the position tag which represents the
   path through the tree on which that block should appear. The tree
   is represented in a standard array style, in which the left and right children
   of the node at index `n` are at indices `2n` and `2n + 1` respectively. -}

type α tree = ((α pos) trivial) array

{- Read and Remove on a Tree ORAM.

   Takes a Tree ORAM `oram` and looks up the block at `idx`, which lives on the path specified by `pos`. -}

def tree-rr-rec : ∀ α : ☆ . Default α ⇒ α tree → 𝔹{yao:A,B} → ℕ{yao:A,B} → ℕ → (α pos) block
def tree-rr-rec oram real idx pos =
  let size  = nat (size oram)
  let depth = log₂ (size + 1n) in
  def loop : ∀ α : ☆ . (α pos) block → ℕ → (α pos) block
  def loop acc i =
    if i == depth then
      acc
    else
      let base   = 2n ** i - 1n
      let bucket = oram.(base + (pos & base))
      let result = rr-rec bucket real idx
      let swap   = real && result.occupied
      let acc'   = mux if ¬ swap then acc else result in
      loop acc' (i + 1n)
  in
  loop (default ∙) 0n

def tree-rr : ∀ α : ☆ . Default α ⇒ α trivial → ℕ{yao:A,B} → ℕ → α{yao:A,B}
def rr oram idx pos =
  let result = tree-rr-rec oram true idx pos in
  result.data.data

{- Add on a Tree ORAM.

   Takes a Tree ORAM `oram` and adds the block `blk` to the root node of the tree. The tree is evicted
   afterward. -}

def tree-add-rec : ∀ α : ☆ . α tree → 𝔹{yao:A,B} → (α pos) block → ∙
def tree-add-rec oram real blk =
  let _ = add-rec oram[0] real blk in
  evict oram

def tree-add : ∀ α : ☆ . α tree → ℕ{yao:A,B} → ℕ{yao:A,B} → α{yao:A,B} → ∙
def tree-add oram idx pos v =
  let blk = { occupied = true
            ; idx      = idx
            ; data     = { pos  = pos
                         ; data = v
                         }
            } in
  tree-add-rec oram true blk

{- Evict a Tree ORAM.

   There are many different schemes one could use, but they all maintain the invariant that every block is
   placed on a path through the tree consistent with that block's position tag. We omit a concrete implementation
   for now until we have more evidence for what a reasonable eviction procedure is in the MPC setting. -}

def evict : ∀ α : ☆ . Default α ⇒ α tree → ∙
def evict oram = ...

{- Initialize a new Tree ORAM. -}

def initialize : ∀ α : ☆ . Default α ⇒ ℕ → ℕ → α tree
def initialize n m = array[n] (λ _ . array[m] (λ _ . default ∙))

{-
================================================
================ RECURSIVE ORAM ================
================================================
-}

{- A Recursive ORAM is a position map paired up with Tree ORAM.

   The position map is a sequence of Tree ORAMs, terminating in a
   Trivial ORAM. Each ORAM holds the position tags for the next ORAM
   in the sequence. The last ORAM in the sequence holds the position
   tags for Tree ORAM which holds the client's data.

   For example, the Trivial ORAM might be size 2 with each subsequent
   position map Tree ORAM being size 2^i for i = 2...log₂(N). -}

type position-map = ℕ trivial * (ℕ tree) array

type α recursive = position-map * α tree

-}

def main • =
  let a = array[20n] (λ i → i + 1n#∞) in
  a.1n