-- input parties
principal A B 
-- compute parties
principal C D 
-- output party
principal E

-- assumptions: 
-- â€£ a > b
def euclid-rec : â„• â†’ â„¤{yao:C,D} â†’ â„¤{yao:C,D} â†’ â„¤{yao:C,D}
def euclid-rec n a b =
  if n â‰¡ 0n
  then b
  else
    b â‰¡ 0
    ? a
    â—‡ euclid-rec (n - 1n) b (a % b)

-- assumptions:
-- â€£ a > 0
-- â€£ b > 0
def euclid : â„¤{yao:C,D} â†’ â„¤{yao:C,D} â†’ â„¤{yao:C,D}
def euclid a b =
  -- worst case is neighboring fibbinocci sequence numbers, with one iteration
  -- per sequence position, and 64 bit max bound is less than the 93rd fib
  -- number
  let n = 93n
  in
  a > b
  ? euclid-rec n a b
  â—‡ euclid-rec n b a

def main : ğŸ™ â†’ {inp:A,B;rev:E} â„¤{ssec:E}
def main â€¢ =
  let ab = {par:A,B} read â„¤ "euclid.txt"
  reveal{E} euclid (share{yao:C,D} ab.A) (share{yao:C,D} ab.B)
