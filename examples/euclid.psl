-- input parties
principal A B 
-- compute parties
principal C D 
-- output party
principal E

-- assumptions: 
-- ‣ a > b
def euclid-rec : ℕ → ℤ{yao:C,D} → ℤ{yao:C,D} → ℤ{yao:C,D}
def euclid-rec n a b =
  if n ≡ 0n
  then b
  else
    b ≡ 0
    ? a
    ◇ euclid-rec (n - 1n) b (a % b)

-- assumptions:
-- ‣ a > 0
-- ‣ b > 0
def euclid : ℤ{yao:C,D} → ℤ{yao:C,D} → ℤ{yao:C,D}
def euclid a b =
  -- worst case is neighboring fibbinocci sequence numbers, with one iteration
  -- per sequence position, and 64 bit max bound is less than the 93rd fib
  -- number
  let n = 93n
  in
  a > b
  ? euclid-rec n a b
  ◇ euclid-rec n b a

def main : 𝟙 → {inp:A,B;rev:E} ℤ{ssec:E}
def main • =
  let ab = {par:A,B} read ℤ "euclid.txt"
  reveal{E} euclid (share{yao:C,D} ab.A) (share{yao:C,D} ab.B)
