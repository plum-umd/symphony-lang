principal A B

def init_column table len =
  let ic_rec = fun [ic_rec] i ->
    if i == len + 1n then
      ()
    else
      let _ = table.(len * i) <- (int i) in
      ic_rec (i + 1n)
  in ic_rec 0n

def init_row table len =
  let ir_rec = fun [ir_rec] i ->
    if i == len + 1n then
      ()
    else
      let _ = table.(i) <- (int i) in
      ir_rec (i + 1n)
  in ir_rec 0n

-- edit-dist: classical dynamic programming algorithm
def edit-dist strA strB len =
  let sz = (len + 1n) * (len + 1n) in
  let table = array[sz] 0 in
  let _ = init_column table len in
  let _ = init_row table len in

  let edit_rec = fun [edit_rec] i j ->
    if i == len + 1n then
      ()
    else
      if j == len + 1n then
        edit_rec (i + 1n) 1n
      else
        let insert = table.(len * (i - 1n) + j) + 1 in
        let delete = table.(len * i + (j - 1n)) + 1 in
        let sub    = table.(len * (i - 1n) + (j - 1n)) + (mux if strA.(i - 1n) == strB.(j - 1n) then 0 else 1) in
        let _ = table.(len * i + j) <- min-muxable (min-muxable insert delete) sub in
        edit_rec i (j + 1n)
  in

  let _ = edit_rec 1n 1n in
  table.(len * len + len)

def main () = par {{A,B}}
  let inputA  = par {{A}} snd (read (ℕ#32 × array[{1}] ℤ#32) from "edit-distance-input-{1}.txt") in
  let inputB  = par {{B}} snd (read (ℕ#32 × array[{1}] ℤ#32) from "edit-distance-input-{1}.txt") in

  let strA = share [{0}, array[{1}] ℤ#32 : A → {{A,B}}] inputA in
  let strB = share [{0}, array[{1}] ℤ#32 : B → {{A,B}}] inputB in
  let _    = par {{B}} flush [A] in

  reveal [{0}, ℕ#32 : {{A,B}} → A] (edit-dist strA strB {1}n)
