principal A B

-- CCS21 BENCHMARK

def main () = par {{A,B}}
  let inputA  = par {{A}} snd (read (ℕ#32 × array[{1}] (ℤ#32 × ℤ#32)) from "db-analytics-input-{1}.txt") in
  let inputB  = par {{B}} snd (read (ℕ#32 × array[{1}] (ℤ#32 × ℤ#32)) from "db-analytics-input-{1}.txt") in

  let sharedA = share [{0}, array[{1}] (ℤ#32 × ℤ#32) : A → {{A,B}}] inputA in
  let sharedB = share [{0}, array[{1}] (ℤ#32 × ℤ#32) : B → {{A,B}}] inputB in
  let _       = par {{B}} flush [A] in

  let len = {1}n in

  let union-len = 2n * len in

  let concatCol0 = array[union-len] 0 in
  let concatCol1 = array[union-len] 0 in

  let concat_rec = fun [concat_rec] i ->
    if i == len then
      ()
    else
      let _ = concatCol0.i         <- fst sharedA.i in
      let _ = concatCol0.(len + i) <- fst sharedB.i in

      let _ = concatCol1.i         <- snd sharedA.i in
      let _ = concatCol1.(len + i) <- snd sharedB.i in
      concat_rec (i + 1n)
  in
  let _ = concat_rec 0n in

  let union_sum_rec = fun [union_sum_rec] i acc ->
    if i == union-len then
      acc
    else
      union_sum_rec (i + 1n) (acc + concatCol1.i)
  in
  let union-sum = union_sum_rec 0n 0 in
  let union-mean = union-sum / (int union-len) in

  let union_var_rec = fun [union_var_rec] i acc ->
    if i == union-len then
      acc
    else
      let d = concatCol1.i - union-mean in
      union_var_rec (i + 1n) (acc + (d * d))
  in
  let union-dev = union_var_rec 0n 0 in
  let union-var = union-dev / (int union-len) in

  let join-len = len * len in

  let joinCol  = array[join-len] 0 in
  let isActual = array[join-len] false in

  let join_rec = fun [join_rec] i j ->
    if i == len then
      ()
    else
      if j == len then
        join_rec (i + 1n) 0n
      else
        let actual = mux if (concatCol0.i == concatCol0.(len + j)) then true else false in
        let _ = isActual.(i * len + j) <- actual in
        let _ = joinCol.(i * len + j) <- concatCol1.i in
        join_rec i (j + 1n)
  in
  let _ = join_rec 0n 0n in

  let actuals_rec = fun [actuals_rec] i acc ->
    if i == join-len then
      acc
    else
      actuals_rec (i + 1n) (acc + (mux if isActual.i then 1 else 0))
  in
  let num-actuals = actuals_rec 0n 0 in

  let join_sum_rec = fun [join_sum_rec] i acc ->
    if i == join-len then
      acc
    else
      join_sum_rec (i + 1n) (acc + (mux if isActual.i then joinCol.i else 0))
  in
  let join-sum = join_sum_rec 0n 0 in
  let join-mean = join-sum / num-actuals in

  let join_var_rec = fun [join_var_rec] i acc ->
    if i == join-len then
      acc
    else
      let d = joinCol.i - join-mean in
      join_var_rec (i + 1n) (acc + (mux if isActual.i then d * d else 0))
  in
  let join-dev = join_var_rec 0n 0 in
  let join-var = join-dev / num-actuals in

  (reveal [{0}, ℤ#32 : {{A,B}} → A] union-mean,
   reveal [{0}, ℤ#32 : {{A,B}} → A] union-var,
   reveal [{0}, ℤ#32 : {{A,B}} → A] join-mean,
   reveal [{0}, ℤ#32 : {{A,B}} → A] join-var)
