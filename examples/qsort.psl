principal A
principal B

-- TODO
-- not yet working with interpreter, something with case expressions?
-- merge lists together
-- replace nat by real

def index
  : nat{bgw:A,B}
  -> list nat{bgw:A,B}
  -> nat{bgw:A,B}
def index i xs =
  case xs
  { [] -> 0
  ; x::xs ->
    if i == 0
    then x
    else index (i-1) xs
  }

def replace
  : nat{bgw:A,B} -- index
  -> nat{bgw:A,B} -- to insert
  -> list nat{bgw:A,B}
  -> list nat{bgw:A,B}
def replace ix x arr =
  case arr
  { [] -> []
  ; y::ys ->
    if ix == 0
    then x::ys
    else y::(replace (ix - 1) x ys)
  }

-- Swap the two indices in the array iff the condition is true
def condSwap
  : bool{bgw:A,B}
  -> nat{bgw:A,B}
  -> nat{bgw:A,B}
  -> list nat{bgw:A,B}
  -> list nat{bgw:A,B}
def condSwap cond i j arr =
  if cond
  then
    let l = index i arr
    in let r = index j arr
    in replace i r (replace j l arr)
  else arr

def boolToInt : bool{bgw:A,B} -> nat{bgw:A,B}
def boolToInt b = if b then 1 else 0

def partLoop
  : nat -- remaining iterations
  -> nat{bgw:A,B}
  -> nat{bgw:A,B}
  -> nat{bgw:A,B}
  -> list nat{bgw:A,B}
  -> list nat{bgw:A,B} * nat{bgw:A,B}
def partLoop n i lo hi arr =
  if n == 0
  then i, arr
  else
    let cond = index lo arr < index hi arr
    in let arr = condSwap cond lo hi arr
    in let i' = i + boolToInt cond
    in partLoop (n - 1) i' (lo+1) hi arr

def partition
  : nat -- the size of the entire list
  -> nat{bgw:A,B}
  -> nat{bgw:A,B}
  -> list nat{bgw:A,B}
  -> list nat{bgw:A,B} * nat{bgw:A,B}
def partition n lo hi arr =
  let r = rand-range nat{bgw:A,B} (lo,hi) in
  let arr = condSwap true r hi arr in
  partLoop n lo lo hi arr

def quickSort
  : nat -- iterations remaining
  -> nat{bgw:A,B} -- lo
  -> nat{bgw:A,B} -- hi
  -> list nat{bgw:A,B}
  -> list nat{bgw:A,B}
def quickSort n lo hi arr =
  if n == 0
  then arr
  else
    let partitioned, pivot = partition lo hi arr
    in
      quickSort (n - 1) (pivot + 1) hi (quickSort (n - 1) lo (pivot - 1) partitioned)
arr

def main : unit -> {inp:A,B;rev:A,B} list nat{bgw:A,B}
def main () =
  let xys-pre : (list ℤ){isec:A,B}
  let xys-pre = {par:A,B} read (list ℤ) "qsort-input.txt"
  in

  -- TODO how to merge lists? Is this what preprocess-lists does in msort?

  let n = 10 -- TODO this should be the length of the merged list
  in

  quickSort n 0 0 xys-pre
