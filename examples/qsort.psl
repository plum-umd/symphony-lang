principal A
principal B

-- TODO
-- generalize to 64 players


def swap-indexes i j arr =
  let _, l = vec-read i arr
  let _, r = vec-read j arr
  in
    vec-write i r (vec-write j l arr)

def partition n lo hi arr =
  let r = rand-range int{bgw:this} (lo,hi) in
  let arr = swap-indexes r hi arr in

  let go = fun [go] n i j hi arr ->
    if n == 0
    then
      arr, i
    else
      let arr, i' =
        mux if (snd (vec-read j arr) < snd (vec-read hi arr))
             then swap-indexes i j arr, i + 1
             else arr, i
      let j' = mux if (j < hi) then j + 1 else j
      in
        go (n - 1) i' j' hi arr

  let arr', pivot = go n lo lo hi arr
  in (pivot, swap-indexes pivot hi arr')


def quickSort n a lo hi =
  if n == 0
  then a
  else mux if (lo < hi)
  then
    -- find pivot: e < pivot <=> a[e] < a[pivot]; e > pivot <=> a[e] > a[pivot]
    let pivot, a = partition n lo hi a

    -- recursively sort the elements smaller than pivot
    let a = quickSort (n - 1) a lo (pivot - 1)

    -- recursively sort the elements larger than pivot
    in quickSort (n - 1) a (pivot + 1) hi
  else
    a


def main : unit -> {inp:A,B ; rev:A,B} (list flt)
def main () =
  par {A,B}
    let sbool = fun P -> (fun x -> share{bgw:P -> this} x)
    let sflt = fun P -> (fun x -> share{bgw:P -> this} x)
    let rflt = fun f -> reveal {this} f

    let a = share-as-vec A (sbool A) (sflt A) 0.0 10
      (par {A} read (list flt) from "qsort-input.txt")
    let b = share-as-vec B (sbool B) (sflt B) 0.0 10
      (par {B} read (list flt) from "qsort-input.txt")

    let inps = vec-append a b

    let n = vec-capacity inps
    in
      vec-reveal rflt (quickSort n inps 0 (n - 1))
      -- vec-reveal rflt (partition n 0 (n - 1) inps)
