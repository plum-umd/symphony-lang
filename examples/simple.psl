principal A
principal B
principal C
principal D
principal E

trust A,B,C,D,E -- TODO say things like "A trusts B semi-honest, but B trusts A malicious"

security A ⫫ B --
security C ⫫ D -- TODO relax to say some number of corruptions

-- TODO: look at Fabric

-- delegate thing as a function

-- tracks who participates, also checks C,D
def compareInline : ℤ{A} → ℤ{B} → MPC{A,B ⪫ C,D} 𝔹[yao:E,F]
def compareInline = λ a → λ b → mpc{yao:C,D} circuit a < b [yao:E,F]

-- just tracks who participates
def compareCIR : ℤ{A} → ℤ{B} → CIR{bool:A,B} 𝔹
def compareCIR = λ a → λ b → circuit a < b

def compareMPC : ℤ{A} → ℤ{B} → MPC{A,B ⪫ C,D} 𝔹[yao:E,F]
def compareMPC = λ a → λ b →
  do c ← mpc{yao:C,D} compareCIR a b [yao:E,F];
  return c

def send : ℤ{A} → MPC{A⪫} 𝔹{B}
def send = λ a →
  do b ← mpc{none:} circuit a {B};
  return b

def send : ℤ{A} → MPC{A⪫} 𝔹{B}
def send = λ a →
  return a {B}

def distribute : ℤ{A} → MPC{A⪫} ℤ[yao:B,C]
def distribute = λ a →
  do bc ← mpc{none:} circuit a {B,C};
  return bc

def combine : ℤ[bgw:A,B] → MPC{A⪫} ℤ{C}
def combine = λ ab →
  do c ← mpc{none:} circuit ab {C};
  return c

def split : ℤ{A} → MPC{A⪫} ℤ[yao:B,C] × ℤ[bgw:C,D]
def split = λ a →
  do bc,cd ← mpc{none:} circuit a [yao:B,C] , a [bgw:C,D];
  return bc,cd

-- def split2 : ℤ{A} → MPC{A} ℤ{yao:B,C|bgw:C,D}
-- def split2 = λ a →
--   c ← mpc circuit a {B,C|C,D};
--   return c;

def swap : ℤ[yao:A,B] → ℤ[bgw:A,C] → MPC{A,B,C⪫} ℤ[bgw:A,C] × ℤ[yao:A,B]
def swap = λ ab → λ ac →
  do ra,rb ← mpc{none:} circuit ab [bgw:A,C] , ac [yao:A,B];
  return ra,rb

def compareConstInline : ℤ{B,C} → ℤ{A} → MPC{A ⪫ B,C} 𝔹{D}
def compareConstInline = λ x → λ a →
  do c ← mpc{gmw:B,C} circuit x < a {D};
  retun c

def compareConstCIR : ℤ → ℤ{A} → CIR{bool:A} 𝔹{D}
def compareConstCIR = λ x → λ a → circuit x < a {D}

def compareConstMPC : ℤ → ℤ{A} → MPC{A ⪫ B,C} 𝔹{D}
def compareConstMPC = λ x → λ a →
  do c ← mpc{gmw:B,C} compareConstCIR a b {D};
  return c
