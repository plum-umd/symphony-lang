principal A B

-- edit-dist: dynamic programming algorithm
def edit-dist rowsWord colsWord =
  let (topFirst, topLast) = elim-list rowsWord
    (map inc (reverse (range-nat (len colsWord))), 0n)
    (fun rowChar (prevSolnRow, prevLast) ->
       let curLast = inc prevLast in
       let (curFirst, _) = elim-list (zip prevSolnRow colsWord)
         ([ ], prevLast)
         (fun (prevRowCost, colChar) (curRow, diagCost) ->
           let prevColCost = head curLast curRow in
           let choice0 = min-muxable prevRowCost prevColCost in
           let (choice1, addCost) = mux if (choice0 >= diagCost)
             then (diagCost, (mux if (rowChar == colChar) then 0n else 1n))
             else (choice0, 1n) in
           (choice1::curRow, prevRowCost)) in
       (curFirst, curLast)) in
  head topLast topFirst

def main () = par{A, B}
--let wordA = map (fun x -> share {yao: A -> A, B} x)
--    (send-ls {A} {A, B}
--     (par {A} (read list int from "edit-dist-input.txt"))) in
--let wordB = map (fun x -> share {yao: B -> A, B} x)
--    (send-ls {B} {A, B}
--     (par {B} (read list int from "edit-dist-input.txt"))) in
  let wordA0 = [ par {A:int} 0 ; par {A:int} 1 ; par {A:int} 2 ; par {A:int} 3 ] in
  let wordA  = map (fun x -> share {yao: A -> A, B} x) wordA0 in
  let wordB0 = [ par {B:int} 0 ; par {B:int} 1 ; par {B:int} 2 ; par {B:int} 3 ] in
  let wordB  = map (fun x -> share {yao: B -> A, B} x) wordB0 in
  reveal{yao:A, B -> A, B} edit-dist wordA wordB
