principal A[96] -- Parties who supply just integers
principal B[32] -- Parties who supply both integers and queries
principal Dummy

-- Query functions

-- First element because list is sorted
def min : list int{bgw:A,B} -> int{bgw:A,B}
def min xs = case xs
  { x :: _ -> x
  }

-- Last element because list is sorted
def max : list int{bgw:A,B} -> int{bgw:A,B}
def max xs = case xs
  { [x] -> x
  ; _ :: xs' -> max xs'
  }

-- Find the middle element (use the lower middle element if the length is even)
def median : list int{bgw:A,B} -> int{bgw:A,B}
def median xs =
  let l = length xs
  let idx = l / 2
  let idx' = ((l % 2) == 0) ? (idx - 1) >< idx
  in elem-at idx' xs

-- Recursive helper function for num-unique
def num-unique-rec : list int{bgw:A,B} -> int{bgw:A,B} -> int{bgw:A,B}
def num-unique-rec xs last = case xs
  { [] -> 0
  ; x :: xs' ->
    let b = x == last
    in (num-unique-rec xs' x) + (b ? 0 >< 1)
  }

-- Find the number of unique elements in the integer list
def num-unique : list int{bgw:A,B} -> int{bgw:A,B}
def num-unique xs = case xs
  { [] -> 0
  ; x :: xs' -> (num-unique-rec xs' x) + 1
  }

-- mpc/list manip

def remove-dups :
     list (bool{bgw:A,B} * (int{bgw:A,B} * prin{bgw:A,B}))
  -> list (bool{bgw:A,B} * (int{bgw:A,B} * prin{bgw:A,B}))
def remove-dups qs = case qs
  { [] -> []
  ; (b,query) :: qs' ->
    let h = mux if (elem-triple query qs')
            then (false, (-1,Dummy))
            else (b,query)
    in h :: (remove-dups qs')
  }

-- Publishing results

def publish-result :
    prin{bgw:A,B}
  -> (t : prin)
  -> int{bgw:A,B}
  -> bool{bgw:A,B}
  -> list (bool{ssec:various} * int{ssec:various})
def publish-result allParties target value isValid = case allParties
  { {} -> []
  ; {currentParty} \/ remainingParties ->
    let validTag = isValid ? (target == currentParty) >< false
    let valueOutput = isValid ? ((target == currentParty) ? value >< -1) >< -1
    let output = reveal {currentParty} validTag, reveal {currentParty} valueOutput
    let remainingOutput = publish-result remainingParties target value isValid
    in output :: remainingOutput
  }

def publish-results :
    list int{bgw:A,B}
  -> list (bool{bgw:A,B} * (int{bgw:A,B} * prin{bgw:A,B}))
  -> list list (bool{ssec:various} * int{ssec:various})
def publish-results results queryTargetOptionals = case queryTargetOptionals
  { [] -> []
  ; (isValid,(query,target)) :: remaining ->
    let output = publish-result {A,B} (reveal{A,B} target) (elem-at query results) isValid
    let remainingOutput = publish-results results remaining
    in output :: remainingOutput
  }

-- ATQ

def main : unit -> {inp:A,B;rev:A,B} list int{ssec:any}
def main () = par {A,B}

  -- All parties read in data input
  let inputLists : (list int){isec:A,B}
  let inputLists = solo {A,B} as a in read (list int) from "atq-data.txt"

  -- Parties in group B read in queries
  let inputQueries : int{isec:B}
  let inputQueries = solo {B} as a in read int from "atq-query.txt"

  -- Parties in group B read in targets for the previously read in queries
  let inputTargets : (list prin){isec:B}
  let inputTargets = solo {B} as a in read (list prin) from "atq-targets.txt"

  -- Secret share the elements of each party's list
  let inputListsShared : list list (int{bgw:A,B})
  let inputListsShared = fold-f [] (fun P x i -> (preprocess-lists-reveal-lengths P {A,B} x 0) :: i) inputLists

  -- Merge and sort the input lists into a single list
  let dataList : list int{bgw:A,B}
  let dataList = concat inputListsShared

  -- Produce a single sorted list of all input integers
  let dataListSorted : list int{bgw:A,B}
  let dataListSorted = sort (fun a b -> mux if a <= b then (a, b) else (b, a)) dataList

  -- Find the median of the integer list
  let medianResult : int{bgw:A,B}
  let medianResult = median dataListSorted

  -- Find the number of unique elements in the integer list
  let uniqueResult : int{bgw:A,B}
  let uniqueResult = num-unique dataListSorted

  -- Find the minimum value in the integer list
  let minResult : int{bgw:A,B}
  let minResult = min dataListSorted

  -- Find the maximum value in the integer list
  let maxResult : int{bgw:A,B}
  let maxResult = max dataListSorted

  -- Group results into an indexable data structure
  let results : list int{bgw:A,B}
  let results = [medianResult; uniqueResult; minResult; maxResult]

  -- Pair the input queries and targets up along with a tag denoting that it is not dummy data
  let queriesWithTargets : (list (bool{ssec:B} * (int{ssec:B} * prin{ssec:B}))){isec:B}
  let queriesWithTargets = solo {B} as a in (pair-with-list true (pair-with-list inputQueries@a inputTargets@a))

  -- Secret share queries and targets without revealing the number of targets each party supplied by setting an upper bound and padding data out with dummy data
  let queriesWithTargetsShared : list list (bool{bgw:A,B} * (int{bgw:A,B} * prin{bgw:A,B}))
  let queriesWithTargetsShared = fold-f [] (fun P x i -> (preprocess-lists-n-triples P {A,B} 8 x (false,(-1,Dummy))) :: i) queriesWithTargets

  -- Combine queries and targets into one list
  let allQueriesWithTargetsShared : list (bool{bgw:A,B} * (int{bgw:A,B} * prin{bgw:A,B}))
  let allQueriesWithTargetsShared = concat queriesWithTargetsShared

  -- Remove duplicate queries so that recipients will not learn how many times they were targeted
  let finalQueries : list (bool{bgw:A,B} * (int{bgw:A,B} * prin{bgw:A,B}))
  let finalQueries = remove-dups allQueriesWithTargetsShared

  -- For each query from each party in B with duplicates replaced by dummy data, plus dummy padding to achieve upper bounds, publish the results of the query to the target of the query
  in concat (publish-results results finalQueries)

