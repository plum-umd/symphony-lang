principal A B C D E

-- Library

-- Is this right?
-- âˆ€ A : â˜…, Î¼ : ğ‘ƒ(â„™) â‡’ ğ”¹@Î¼ Î¼â†’ A Î¼â†’ A Î¼â†’ A
def cond-if g a b = if g then a else b


-- Q: Can an A be a subtype of a share of A? Can any context that accepts a share of A also accept a cleartext A?
--    It would be helpful if this were the case, because then we could give a type to `max` which says it takes a share
--    but use it with cleartext things when necessary by appeals to subsumption.
-- Is this right? Need to somehow establish âŠ¢Î¼ Ïˆ to typecheck successfully, does this mean we need polymorphic encryption tags?
-- âˆ€ A : â˜†, Ïˆ : ğ”¼, Î¼ : ğ‘ƒ(â„™) . [ âŠ¢Î¼ Ïˆ ] â‡’ ğ”¹â¸¤Ïˆâ¸¥@Î¼ Î¼â†’ Aâ¸¤Ïˆâ¸¥@Î¼ Î¼â†’ Aâ¸¤Ïˆâ¸¥@Î¼ Î¼â†’ Aâ¸¤Ïˆâ¸¥@Î¼
def cond-mux g a b = mux if g then a else b

def max cond a b = cond (a <= b) b a

def foldr f acc xs = case xs
  { []      â†’ acc
  ; x âˆ· xs' â†’ f x (foldr f acc xs')
  }

def solo-f P f = case P
  { {}       â†’ âŸªâŸ«
  ; {Ï} âŠ P' â†’ âŸª Ï | par {Ï} f Ï âŸ« â§º solo-f P' f
  }

def map-prins P f = case
  { {}       â†’ []
  ; {Ï} âŠ P' â†’ f Ï âˆ· map-prins P' f
  }

-- This should establish that it returns a single party in P, for `elect` to typecheck
def randParty P =
  let id = (rand P â„•) % (size P) in
  let rec randParty' i Q =
    case Q
    { {}       â†’ âŠ¥  -- Impossible
    ; {Ï} âŠ Q' â†’ if i < id then randParty' (i + 1n) Q' else Ï
    }
  in randParty' 0n P

-- Application

def bundleInputs P = solo-f P (Î» _ â†’ read â„•)

-- BUG/PROBLEM: Function doesn't terminate if `k` is greater than size of `P`
-- Î  (P : ğ‘ƒ(â„™)@P) Pâ†’ â„•@P Pâ†’ (R : ğ‘ƒ(â„™)@P | R âŠ† P)
def elect P k =
  -- (C : ğ‘ƒ(â„™)@P | C âŠ† P) Pâ†’ (R : ğ‘ƒ(â„™)@P | R âŠ† P)
  let rec elect' C =
    if (size C) == k then C
    else let Ï = randParty P in elect' ({p} âˆª C)
  in elect' {}

-- âˆ€ A,B : â˜… â‡’ Î  (P : ğ‘ƒ(â„™)@P) Pâ†’ Î  (C : ğ‘ƒ(â„™)@P | C âŠ† P) Pâ†’ AâŸªPâŸ«@P Pâ†’ ([A#C@C] Câ†’ B#C@C) Pâ†’ B@P
def delegate P C input sc =
  let shareToC Ï =
    let pInput = par {Ï} input@Ï in
    par ({Ï} âˆª C) share [gmw : Ï â†’ C] pInput
  in
  let shares = mapPrins P shareToC in
  reveal [gmw : C â†’ P] (par C (sc shares))

def main () =
  let P = {A,B,C,D,E} in
  par P
    let input = bundleInputs P in                         -- â„•âŸªPâŸ«@P
    let C     = elect P 3n in                             -- (C : ğ‘ƒ(â„™)@P | C âŠ† P)
    delegate P C input (par C (foldr (max cond-mux) 0n))  -- â„•@P
    â€¦
