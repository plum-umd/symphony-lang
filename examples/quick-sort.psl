principal Node_in[3]

-- TODO
-- generalize to 64 players

def partition (a, lo, hi) =
  -- In order to avoid deterministic worst case behaviour pick the
  -- pivot element at random and put it in the alst position (HI)

  -- random (LO, HI) selects a random integer between LO and HI,
  -- inclusively
  let r = rand-range nat{bgw:this} (lo, hi)
  let r = hi -- DEBUG:
  do swap a r hi

  -- Now use A[HI] as the pivot value

  -- Elements in positions below I will be known to be less than the
  -- pivot value
  let i = ref lo 

  -- Compare each element of A with the pivot value A[HI], and if less
  -- than the pivot value, move it to the beginning of the list
  do sec-iter [ a ; i ] lo hi (len !a) (fun j ->
      upd-if [ a ; i ] ((sec-get !a j) < (sec-get !a hi)) (fun () ->
        (do swap a !i j in
         i := !i + 1n) ) )

  -- Move the pivot value into its right place
  do swap a !i hi in

  -- Now the pivot value is in A[I] and all the elements smaller than
  -- the pivot are before it in A[]

  -- Return the pivot index I
  !i

def sec quick_sort (a, lo, hi) = 
    upd-if [ a ] (lo < hi) (fun () ->
      -- Find PIVOT: e < PIVOT <=> A[e] < A[PIVOT]; e > PIVOT <=> A[e]
      -- > A[PIVOT]
      let pivot = partition (a, lo, hi)

      -- Recursively sort the elements smaller than PIVOT
      do quick_sort (a, lo, sec-dec pivot) in

      -- Recursively Sort the elements larger than PIVOT
      quick_sort (a, pivot + 1n, hi) )


-- verify inputs result: NIZK proof that result has signed inputs from
-- each party and is sorted
def verify inputs result =
  let shr-w-nodes = fun N x ->
    nizk-witness{ bgw : Node_in } (share{ bgw : N -> Node_in } x) in
  let test-const = shr-w-nodes Node_in.0 in
  let test-true = test-bool true in
  let test-false = test-bool false in

  -- input-wits: bundle of witnesses built from signed inputs:
  let input-wits = bundle-map shr-w-nodes inputs in

  -- all-inputs-signed: test that each input is signed
  let all-inputs-signed = fold-f
    test-true
    (fun N w -> and (is-signed { N } w))
    input-wits in

  -- res-wits: witnesses from the sorted result
  let res-wits = map (fun x -> nizk-witness{ bgw : Node_in } x) result in

  -- res-is-inj: test that unsignature of each input is in result:
  let res-is-inj = fold-f
    test-true
    (const and)
    (bundle-map
      (fun N i ->
         let unsign-wit = unsign { N } i in
         elim_list res-wits
           test-false
           (fun r -> or (unsign-wit == r)) )
      input-wits) in

  -- test-is-sorted: test that the list is sorted:
  let test-is-sorted =
    let res-is-sorted = foldr
      (L ())
      (fun x acc -> R
         (x,
          case acc
          { L _ -> test-true
          ; R (x', is-sorted') -> and (x <= x') is-sorted'
          }) )
      res-wits in
    case res-is-sorted
      { L _ -> test-true
      ; R (_, t) -> t
      } in

  -- commit to witness for all tests
  nizk-commit { bgw : Node_in }
    all-inputs-signed &&
    res-is-inj &&
    res-is-sorted


def main () = par{ Node_in }
  -- inputs: read the inputs
  let inputs = solo { Node_in } as N in
    map (wrap-sign N) (read (list flt) from "quick-sort-in.txt") in

  -- input-ls: share the inputs
  let input-ls = fold-f
    [ ]
    (fun N l -> append 
      (map (fun x -> share{ bgw : N -> Node_in } x)
         (send-ls { N } { Node_in } l) ) )
    inputs in

  -- run the sorting function:
  let n = len input-ls in
  let ls-ref = ref input-ls in
  do eval-upto quick_sort n (ls-ref, 0n, n - 1n) in
  !ls-ref

  -- TODO: add verification code
