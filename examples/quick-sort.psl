principal Nodes

-- TODO
-- generalize to 64 players

def partition (a, lo, hi) =
  -- In order to avoid deterministic worst case behaviour pick the
  -- pivot element at random and put it in the alst position (HI)

  -- random (LO, HI) selects a random integer between LO and HI,
  -- inclusively
  let r = rand-range nat{bgw:this} (lo, hi)
  let r = hi -- DEBUG:
  do swap a r hi

  -- Now use A[HI] as the pivot value

  -- Elements in positions below I will be known to be less than the
  -- pivot value
  let i = ref lo 

  -- Compare each element of A with the pivot value A[HI], and if less
  -- than the pivot value, move it to the beginning of the list
  do sec-iter [ a ; i ] lo hi (len !a) (fun j ->
      upd-if [ a ; i ] ((sec-get !a j) < (sec-get !a hi)) (fun () ->
        (do swap a !i j in
         i := !i + 1n) ) )

  -- Move the pivot value into its right place
  do swap a !i hi in

  -- Now the pivot value is in A[I] and all the elements smaller than
  -- the pivot are before it in A[]

  -- Return the pivot index I
  !i

def sec quick_sort (a, lo, hi) = 
    upd-if [ a ] (lo < hi) (fun () ->
      -- Find PIVOT: e < PIVOT <=> A[e] < A[PIVOT]; e > PIVOT <=> A[e]
      -- > A[PIVOT]
      let pivot = partition (a, lo, hi)

      -- Recursively sort the elements smaller than PIVOT
      do quick_sort (a, lo, sec-dec pivot) in

      -- Recursively Sort the elements larger than PIVOT
      quick_sort (a, pivot + 1n, hi) )


-- verify inputs result: NIZK proof that result has signed inputs from
-- each party and is sorted
def verify inputs result =
  let shr-w-nodes = fun x -> share{ bgw : Nodes } x in
  let test-bool b = nizk-witness{ bgw : Nodes } (shr-w-nodes b) in
  let test-true = test-bool true in
  let test-false = test-bool false in

  -- input-wits: bundle of witnesses built from signed inputs:
  let input-wits = bundle-map
    (fun i -> nizk-witness{ bgw : Nodes } (shr-w-nodes i))
    inputs in

  -- all-inputs-signed: test that each input is signed
  let all-inputs-signed = fold-f
    test-true
    (fun N w -> and (is-signed { N } w))
    input-wits in

  -- res-wits: witnesses from the sorted result
  let res-wits = map (fun x -> nizk-witness{ bgw : Nodes} x) result in

  -- res-is-inj: test that unsignature of each input is in result:
  let res-is-inj = fold-f
    test-true
    (const and)
    (bundle-map
      (fun N i ->
         let unsign-wit = unsign { N } i in
         elim_list res-wits
           test-false
           (fun r -> or (unsign-wit == r)) )
      input-wits) in

  -- test-is-sorted: test that the list is sorted:
  let test-is-sorted =
    let res-is-sorted = foldr
      (L ())
      (fun x acc -> R
         (x,
          case acc
          { L _ -> test-true
          ; R (x', is-sorted') -> and (x <= x') is-sorted'
          }) )
      res-wits in
    case res-is-sorted
      { L _ -> test-true
      ; R (_, t) -> t
      } in

  -- commit to witness for all tests
  nizk-commit { bgw : Nodes }
    all-inputs-signed &&
    res-is-inj &&
    res-is-sorted


def main : unit -> {inp:A,B ; rev:A,B} (list flt)
def main () =
  par {A,B}
    let sbool = fun P -> (fun x -> share{bgw:P -> this} x)
    let sflt = fun P -> (fun x -> share{bgw:P -> this} x)
    let rflt = fun f -> reveal {this} f

    let a = share-as-vec A (sbool A) (sflt A) 0.0 10
      (par {A} read (list flt) from "qsort-input.txt")
    let b = share-as-vec B (sbool B) (sflt B) 0.0 10
      (par {B} read (list flt) from "qsort-input.txt")

    let inps = ref (map (fun x -> share{ bgw : A -> A, B } x) [ 2.0 ; 1.0 ; 3.0 ])
    let n = len !inps 
    in
    do eval-upto quick_sort n (inps, 0n, n - 1n) in
    !inps
--      vec-reveal rflt (eval-upto quick_sort n (inps, 0n, (n - 1n)))
      -- vec-reveal rflt (partition n 0 (n - 1) inps)
