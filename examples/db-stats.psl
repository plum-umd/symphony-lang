principal Hosts[128]
principal C[2]

principal A
principal B

def key-eql a b =
  let (sa, ta) = a
  let (sb, tb) = b
  in (sa == sb) && (ta == tb)

def db-init n = map-init (0, 0) (vec-init (0, 0) 10) n

def singleton-row v =
  vec-push v (vec-init (0, 0) 10)

def med vec = snd (vec-median (fun x y -> x < y) vec)

def mean xs = to_flt (vec-int-sum xs) / to_flt (vec-length xs)

def meanf xs = (vec-flt-sum xs) / to_flt (vec-length xs)


def stddev xs =
  let m = mean xs
  let square = fun x -> x * x
  let diffs = vec-map (fun x -> square (to_flt x - m)) xs
  in sqrt (meanf diffs)


def process-data data values =
  let (s, l), key1, key2 = values
  in
    map-insert-with key-eql vec-append (key1, key2) (singleton-row (s, l)) data

def update : Key -> Value -> Database -> Database
def update k v db =
  map-insert-with key-eql (flip vec-append) k (singleton-row v) db


def threshold = 5

-- This takes key1 and key2 as a key into the database data
def stats-report data key1 key2 =
  -- Separate out the records to use in the report
  let _, record_subset = map-read key-eql (key1, key2) data
  -- Record the number of records matching the key
  let n_records = vec-length record_subset
  -- Ensure that it is above the threshold
  mux if n_records > threshold
  then
    -- Collect the S values
    let s_list = vec-map fst record_subset
    -- Collect the L values
    let s_list = vec-map snd record_subset
    -- Collect the statistics
    let s_median = med s_list
    let s_mean = mean s_list
    let s_stddev = stddev s_list
    let l_median = med s_list
    let l_mean = mean s_list
    let l_stddev = stddev s_list

    in (key1, key2, n_records, s_median, s_mean, s_stddev, l_median, l_mean, l_stddev)

  else
    _|_


def handler key1 key2 input db =
  let is-query, v = input
  in mux if (is-query)
          then db, stats-report db key1 key2
          else process-data db (v, key1, key2), _|_

def num-keys = 20


{-
-- Main function for database statistics
-- A loop handles inputs one at a time
-- Each input attempts to add a record to the databse or requests a query
def database_stats_main inputs =

  -- The structure holding the data
  let data = db-init num-keys

  -- At each loop iteration, process one input
  foldl inputs data (fun input ->
    -- io-name is the principal sending the input
    -- label is the input label of the input
    -- values contains the data (e.g., the keys)
    let io-name, label, values = input

    -- Process the input based on its input label
    -- Send an acknowledgement to the sender
    )
    -}


def main : unit -> list float
def main () =
  par {A,B}
    let db = db-init 20
    let k1 = share {bgv:A -> A,B} (par {A} 2)
    let k2 = share {bgv:A -> A,B} (par {A} 4)
    let db, _ = handler k1 k2 (share {bgv:A -> this} (par {A} (false, (10, 999)))) db
    let db, _ = handler k1 k2 (share {bgv:A -> this} (par {A} (false, (15, 25)))) db
    let db, _ = handler k1 k2 (share {bgv:A -> this} (par {A} (false, (44, 35)))) db
    let db, _ = handler k1 k2 (share {bgv:A -> this} (par {A} (false, (13, 404)))) db
    let db, _ = handler k1 k2 (share {bgv:A -> this} (par {A} (false, (29, 5)))) db
    let db, _ = handler k1 k2 (share {bgv:A -> this} (par {A} (false, (13, 19)))) db
    let _, r = handler k1 k2 (share {bgv:A -> this} (par {A} (true, (0, 0)))) db
    in reveal {A} r
