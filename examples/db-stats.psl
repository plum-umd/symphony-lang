principal Hosts[128]
principal C[2]

-- using yao for now until further clarification on how to specify closer

-- type Key1 = int{yao:C}
-- type Key2 = int{yao:C}
-- type Key = (Key1, Key2)

-- type S = int{yao:C}
-- type L = int{yao:C}

-- type Value = (S, L)

-- type Count = int{yao:C}
-- type Median = int{yao:C}
-- type Mean = float{yao:C}
-- type StdDev = float{yao:C}

-- type Stats = Stats Median Mean StdDev

-- data Response = Summary Count Stats Stats
--               | ThresholdNotMet
--               | Success

-- def thresholdNotMet : Response
-- bug, must add argument to this function
-- def thresholdNotMet _ = R (L ())

-- def summary : Count -> Stats -> Stats -> Response
-- def summary c s0 s1 = L (c, s0, s1)

-- def success : Response
-- bug, must add argument to this function
-- def success _ = R (R ())


-- data Input = Query Key | Insert Key Value

-- type Database = [(Key, [Value])]

def threshold : int
def threshold = 5

def update : Key -> Value -> Database -> Database
def update k v db = case db
  { [] -> (k, v::[])
  ; (k', vs)::rest ->
      if k == k'
      then (k, v::vs)::rest
      else (k', vs)::update k v rest
  }

def median : list int{yao:C} -> int{yao:C}
def median = median

-- def mean : list int#32{yao:C} -> Mean

-- def stdDev : list int#32{yao:C} -> StdDev

-- def stats : list int#32{yao:C} -> Stats
-- def stats xs = (median xs, mean xs, stdDev xs)

def query : Key -> Database -> Response
def query k db = case db
  { [] -> thresholdNotMet
  ; (k', vs)::rest ->
    let count = length vs
    in if and (k == k') (count > threshold)
       then summary count (stats (map fst vs))
                          (stats (map snd vs))
       else if k == k'
            then thresholdNotMet
            else query k rest
  }

-- def respond : Response -> Database -> Database
-- def respond = respond
-- How do we handle IO?

def handler : Input -> Database -> (Database * Response)
-- Bug: the following is commented out because it does not compile due to parser
def handler input db = case input
  { L x -> (update k x db, success _)
  ; _ -> (db, query k db)
  }

def main : unit -> list float
def main () =
  -- let l = 100 :: 2 :: 3 :: 4 :: 5 :: 1000 :: 8 :: 9 :: 99 :: []
  let l = 1.0 :: 2.0 :: 3.0 :: 4.0 :: 5.0 :: 6.0 :: 7.0 :: 8.0 :: 9.0 :: 10.0 :: []
  -- in sort natminmax l
  in stddev l
