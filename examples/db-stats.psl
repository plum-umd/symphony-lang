principal Hosts[128]
principal C[2]

principal A
principal B

def key-eql a b =
  let (sa, ta) = a
  let (sb, tb) = b
  in (sa == sb) && (ta == tb)

def key-default = (0, 0)

def cell-default = (0, 0)

def val-default =
  vec-init cell-default 10

def db-init n = map-init key-default val-default n

def singleton-row v =
  vec-push v (vec-init cell-default 10)

def thresholdNotMet : Response
def thresholdNotMet = R (L ())

def summary : Count -> Stats -> Stats -> Response
def summary c s0 s1 = L (c, s0, s1)

def success : Response
def success = R (R ())

def threshold : int
def threshold = 5


-- def med : vec{bgv:C} int -> int{bgv:C}
def med vec =
  let t, r = vec-median (fun x y -> x < y) vec
  in t ? r >< 0


-- def mean : vec{bgv:C} int -> vec{bgv:C} flt{bgv:C}
def mean xs = to_flt (vec-int-sum xs) / to_flt (vec-length xs)


-- def meanf : vec{bgv:C} flt -> vec{bgv:C} flt{bgv:C}
def meanf xs = (vec-flt-sum xs) / to_flt (vec-length xs)


-- def stddev : vec{bgv:C} int -> flt{bgv:C}
def stddev xs =
  let m = mean xs
  let square = fun x -> x * x
  let diffs = vec-map (fun x -> square (to_flt x - m)) xs
  in sqrt (meanf diffs)


def update : bool -> Key -> Value -> Database -> Database
def update cond k v db =
  map-cond-insert-with
    key-eql
    (fun new old -> vec-append old new)
    cond
    k (singleton-row v) db


def sharePair : int{A} * int{A} -> int{bgv:this} * int {bgv:this}
def sharePair p =
  let x = (par {A} fst p)
  let y = (par {A} snd p)
  in share{bgv:A -> this} x, share{bgv:A -> this} y


def stats-default : Stats
def stats-default = (0, 0.0, 0.0)

def stats-swap b x y =
  let medx, meanx, stdevx = x
  let medy, meany, stdevy = y
  in (b ? medx >< medy, b ? meanx >< meany, b ? stdevx >< stdevy)

def stats-reveal P x =
  let md, mn, std = x
  in (reveal {P} md, reveal {P} mn, reveal {P} std)

def response-reveal P x =
  let (c, s, t) = x
  in (reveal {P} c, stats-reveal P s, stats-reveal P t)

def response-default : Count * Stats * Stats
def response-default = 0, stats-default, stats-default

def response-swap b x y =
  let cx, sx, tx = x
  let cy, sy, ty = y
  in (b ? cx >< cy, stats-swap b sx sy, stats-swap b tx ty)

-- output is pair of tag (threshold achieved?) and response
def output-swap b x y =
  let tx, rx = x
  let ty, ry = y
  in (b ? tx >< ty, response-swap b rx ry)

-- def stats : vec{bgv:C} int -> Stats{bgv:C}
def stats vec =
  (med vec, mean vec, stddev vec)


def query : Key -> Database -> Response
def query k db =
  let t, xs = map-read key-eql k db
  let n = vec-length xs
  let threshold-met = n >= threshold
  in
    threshold-met,
    response-swap threshold-met
      (vec-length xs,
        stats (vec-map fst xs),
        stats (vec-map snd xs))
      response-default


def handler : Key -> Input -> Database -> (Database * Response)
def handler k input db =
  let is-query, v = input
  in mux if (is-query)
          then -- (db, query k db)
                db, query k db
          else -- (update (not is-query) k v db, _|_)
                update (neg is-query) k v db, _|_

  -- let db' = update (not is-query) k v db
  -- let qr = query k db
  -- in
    -- (db', mux if is-query
               -- then qr
               -- else (false, response-default))

def share-key x =
  share {bgv:A -> A,B} (par {A} fst x),
  share {bgv:A -> A,B} (par {A} snd x)


def share-query x =
  share {bgv:A -> A,B} (par {A} fst x),
  ( share {bgv:A -> A,B} (par {A} fst (snd x))
  , share {bgv:A -> A,B} (par {A} snd (snd x))
  )


def main : unit -> list float
def main () =
  par {A,B}
    let m = map-init 0 0 10
    -- in m
    -- in map-read (fun x y -> x == y) 0 m
    let db = db-init 20
    let kA = share-key (par {A} (2, 4))
    let db, _ = handler kA (share-query (par {A} (false, (10, 999)))) db
    let db, _ = handler kA (share-query (par {A} (false, (15, 25)))) db
    let db, _ = handler kA (share-query (par {A} (false, (44, 35)))) db
    let db, _ = handler kA (share-query (par {A} (false, (13, 404)))) db
    let db, _ = handler kA (share-query (par {A} (false, (29, 5)))) db
    let _, (t, r) = handler kA (share-query (par {A} (true, (0, 0)))) db
    in response-reveal A r
