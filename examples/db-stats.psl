principal Hosts[128]
principal C[2]

principal A
principal B

def key-eql a b =
  let (sa, ta) = a
  let (sb, tb) = b
  in (sa == sb) && (ta == tb)

def empty-row = vec-init (0, 0) 10
def singleton-row v = vec-push v empty-row

def init n = map-init (0, 0) (vec-init (0, 0) 10) n
def has k db = map-has (key-eql k) db
def insert k v db = map-insert key-eql k v db
def append k v data = map-insert-with key-eql vec-append k (singleton-row v) data
def db-read k db = snd (map-read key-eql k db)

def med vec = snd (vec-median (fun x y -> x < y) vec)


def mean values =
  let sum = ref 0
  do vec-for values (fun value ->
    sum := !sum + value)
  in to_flt !sum / to_flt (vec-length values)


def stdev values =
  -- Ensure we don't divide by zero
  mux if vec-length values < 2
  then 0.0
  else
    let mean_value = mean values

    let sum = ref 0.0
    do vec-for values (fun value ->
      let diff = to_flt value - mean_value
      in sum := !sum + (diff * diff))
    let sigma_squared = !sum / to_flt (vec-length values - 1)
    in sqrt sigma_squared


-- def split values =
--   let lst = ref empty-row
--   let blocks = ref (vec-init empty-row 10)
--   do vec-for values (fun element ->
--     do lst := vec-push element !lst
--     in mux if vec-length lst == 5 then
--       do (
--         blocks := vec-push lst !blocks
--         -- in lst := ref empty-row
--         )
--     else
--       ())
-- 
--   -- If the length of values was not divisible by 5, the last block will have < 5 elements
--   if vec-length !lst > 0
--   then
--     do blocks := vec-push lst !blocks
--   else
--     ()
--   in !blocks



-- Parse data insertion request from raw request
def parse_data values =
  mux case values
  { L (s, l, key1, key2) -> true, s, l, key1, key2
  ; a -> false, 0, 0, 0, 0
  }


-- Parse query request from raw request
def parse_query values =
  mux case values
  { R (q_id, key1, key2) -> true, q_id, key1, key2
  ; a -> false, 0, 0, 0
  }


-- This function adds a data record to the database
-- data is the database before the new record is added
-- values contains the new input to be added
def process_data data values =
  -- Attempt to parse the given values as a data record
  let success, s, l, key1, key2 = parse_data values

  -- If the data record is well formed, add it to the databse
  in mux if success
  then
    -- Add the data record to the database
    let data = mux if not (has (key1, key2) data)
    then
      -- Each pair of key1 and key2 is its own unique key
      -- Create an empty list if that key has not been used
      insert (key1, key2) empty-row data
    else
      data

    -- Add the value to the list of other values with the same keys
    in true, append (key1, key2) (s, l) data
  else
    false, _|_


def THRESHOLD = 5

-- This takes key1 and key2 as a key into the database data
def stats-report data key1 key2 =

  -- Separate out the records to use in the report
  let record_subset = db-read (key1, key2) data

  -- Record the number of records matching the key
  let N_RECORDS = vec-length record_subset

  -- Ensure that it is above the threshold
  in mux if N_RECORDS > THRESHOLD
  then
    -- Collect the S values
    let S_list = vec-map fst record_subset
    -- Collect the L values
    let L_list = vec-map snd record_subset
    -- Collect the statistics
    let S_MEDIAN = med S_list
    let S_MEAN = mean S_list
    let S_STDDEV = stdev S_list
    let L_MEDIAN = med L_list
    let L_MEAN = mean L_list
    let L_STDDEV = stdev L_list

    in key1, key2, N_RECORDS, S_MEDIAN, S_MEAN, S_STDDEV, L_MEDIAN, L_MEAN, L_STDDEV

  else
    _|_


-- Generate a report in reponse to a value for key1 and a value for key2
def process_query data values =
  -- Attempt to parse the given values as a query with two keys
  let success, q_id, key1, key2 = parse_query values
  mux if success
  then
    -- Return data if present, or a failure code otherwise
    mux if has (key1, key2) data
      then
        let report = stats-report data key1 key2
        in true, q_id, report
      else
        false, q_id, _|_

  -- Ignore the submitted query if it is not well formed
  else
    false, q_id, _|_


def handler input data =
  let _, db' = process_data data input
  let _, q = process_query data input
  in db', q


def num-keys = 20

def DATA = false
def KEYED_QUERY = true


-- Write the output value to a private file on a per player basis
def publish io_name label value =
  let value' = reveal {io_name} value
  in
    par {io_name} (write value' to "output.txt")


-- Main function for database statistics
-- A loop handles inputs one at a time
-- Each input attempts to add a record to the databse or requests a query
def database_stats_main inputs =

  -- The structure holding the data
  let data = init num-keys

  -- At each loop iteration, process one input
  do foldl inputs data (fun input data ->
    -- io_name is the node sending the input
    -- label is the input label of the input
    -- values contains the data (e.g., the keys)
    -- This call sets the three values
    let io_name, label, values = input

    -- Process the input based on its input label
    -- Send an acknowledgement to sender
    in mux if label == DATA
      then
        let success, data = process_data data values
        do publish io_name label success
        in data

      -- process a query with keys and send the report to the sender
      else mux if label == KEYED_QUERY
      then
        let result = process_query data values
        -- do publish io_name label result
        in data
      else
        let result = (false, 0, 0)
        do publish io_name label result
        in data)
  in ()



def main : unit -> list float
def main () =
  par {A,B}
    let db = init 20
    let k1 = par {A} 2
    let k2 = par {A} 4

    let inputs =
      [ A, share {bgv:A -> this} DATA, share {bgv:A -> this} (par {A} L (10, 999, k1, k2))
      ; A, share {bgv:A -> this} DATA, share {bgv:A -> this} (par {A} L (15, 25, k1, k2))
      ; A, KEYED_QUERY, share {bgv:A -> this} (par {A} R (17, k1, k2))
      ]
    in database_stats_main inputs

--    let db, _ = handler (share {bgv:A -> this} ()) db
--    let db, _ = handler (share {bgv:A -> this} (par {A} L (15, 25, k1, k2))) db
--    let db, _ = handler (share {bgv:A -> this} (par {A} L (44, 35, k1, k2))) db
--    let db, _ = handler (share {bgv:A -> this} (par {A} L (13, 404, k1, k2))) db
--    let db, _ = handler (share {bgv:A -> this} (par {A} L (29, 5, k1, k2))) db
--    let db, _ = handler (share {bgv:A -> this} (par {A} L (13, 19, k1, k2))) db
--    let _, r = handler (share {bgv:A -> this} (par {A} R (17, k1, k2))) db
--    in reveal {A} r
