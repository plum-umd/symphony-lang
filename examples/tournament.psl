principal A[4]

def prinSetSize P =
  case P
  { {}         → 0
  ; { ρ } ∪ P' → 1 + prinSetSize P'
  }

-- parsing issue, inlining this below doesn't work
def emptyParSet = { }

def mapPairs f P =
  case P
  { {}                   → emptyParSet
  ; { ρ₁ } ∪ { ρ₂ } ∪ P' →
    let ρ'  = f ρ₁ ρ₂ in
    let P'' = mapPairs f P' in
    { ρ' , P'' }
  }

-- Oblivious!
def exeMatch P b f ρ₁ ρ₂ =
  par { ρ₁, ρ₂, P }
    let x   = share { yao : ρ₁ → ρ₁, ρ₂ } b@ρ₁ in
    let y   = share { yao : ρ₂ → ρ₁, ρ₂ } b@ρ₂ in
    let res = reveal { P } f x y in
    if res then ρ₁ else ρ₂

def tournament A b f P =
  trace P in
  let sz = prinSetSize P in
  -- Assume it is a power of 2
  if sz == 1 then
    case P
    { { winner } ∪ {} → winner }
  else
    tournament A b f (mapPairs (exeMatch A b f) P)

def millionaire x y = x > y

def closer n x y = (abs_val (x - n)) < (abs_val (y - n))

def main • =
  par { A }
    let b = ⟪ A.0 | 10 ; A.1 | 20 ; A.2 | 5 ; A.3 | 22 ⟫ in
    let winner1 = tournament { A } b millionaire { A } in
    let winner2 = tournament { A } b (closer 6) { A } in
    [ winner1 ; winner2 ]
