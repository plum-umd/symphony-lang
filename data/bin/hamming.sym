principal A B

def hammingList bs0 bs1 =
  let hammingListRec = fun [hammingListRec] bs0 bs1 distance →
    case (bs0, bs1)
      { []     , []      → distance
      ; h0 ∷ t0, h1 ∷ t1 →
        let inc = mux if h0 == h1 then 0n#32 else 1n#32 in
        hammingListRec t0 t1 (distance + inc)
      }
  in hammingListRec bs0 bs1 0n#32

def hammingArr bs0 bs1 =
  let len = length bs0 in
  let hammingArrRec = fun [hammingArrRec] i distance →
    if i == 0 then
      distance
    else
      let idx = len - i in
      let inc = mux if bs0.idx == bs1.idx then 0n#32 else 1n#32 in
      hammingArrRec (i - 1n) (distance + inc)
  in hammingArrRec len 0n#32

def main () = par {A,B}
  let inputA = par {A} read (list ℤ#32) from "hamming-4.txt" in
  let inputB = par {B} read (list ℤ#32) from "hamming-4.txt" in

  let shareA = share [gmw, list ℤ#32 : {A} → {A,B}] inputA in
  let shareB = share [gmw, list ℤ#32 : {B} → {A,B}] inputB in

  let hammingList = reveal [gmw, ℕ#32 : {A,B} → {A}] (hammingList shareA shareB) in
  let hammingArr  = reveal [gmw, ℕ#32 : {A,B} → {A}] (hammingArr shareA shareB) in
  par {A} (hammingList, hammingArr)