principal A[32]
principal NoParty

def P = A + { NoParty }

def read-int = 6
-- TEST: actual implementation
-- read int from "richest-in.txt"

def main () = par A
  -- reveal the richest principal to the principal A.0
  reveal [ yao, P : A -> A.0 ] fst 
    -- read each's principal's money and fold into a pair of
    -- (1) richest party; (2) their money
    (fold (solo A as p in read-int) as p.money
      on (share [ yao, P * int : A.0 -> A ] (NoParty, 0)) as richest in
      let pShr = share [ yao, P : p -> A ] p in
      let s = share [ yao, int : p -> A ] money in
      -- BUG: support for this mux isn't implemented
      mux if s > (snd richest) then (pShr, s)
      else richest)

