principal A B

def hammingDist : ( (array{{A, B}}((nat[gmw]@{A,B})@{A,B}))@{A,B}  -> {{A,B}} ((array{{A, B}}((nat[gmw]@{A,B})@{A,B}))@{A,B} -> {{A, B}} (nat[gmw]@{A,B})@{A,B})@{A, B})@{A, B}
def hammingDist bs0 bs1 = par {A,B}
  let len = size bs0 in
  let hammingDistRec = (fun [hammingDistRec] i distance →
    if i == len then
      distance
    else
      let inc = mux if bs0.i == bs1.i then 0n else 1n in
      hammingDistRec (i + 1n) (distance + inc)): (nat@{A,B} -> {{A,B}} (nat[gmw]@{A,B}@{A,B} -> {{A, B}} nat[gmw]@{A,B}@{A,B})@{A,B} )@{A,B}
  in hammingDistRec 0n 0n

def main : (unit@all -> {all} nat@{A})@all
def main () = par {A,B}
  let inputA = par {A} read (array {A} nat) from "hamming-1k.txt" in
  let inputB = par {B} read (array {B} nat) from "hamming-1k.txt" in

  let shareA = share [gmw, array {A} nat : {A} → {A,B}] inputA in
  let shareB = share [gmw, array {B} nat : {B} → {A,B}] inputB in

  reveal [gmw, nat : {A,B} → {A}] (hammingDist shareA shareB)

  