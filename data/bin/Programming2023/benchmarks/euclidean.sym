principal A B

def steps : nat@all
def steps = 10n

def maxInt : int@all
def maxInt = (2 ^ 31n) - 1

def root : (int@all -> int@all)@all
def root x =
  let rootRec = (fun [rootRec] i guess ->
    if i == 0n then
      guess
    else
      rootRec (i - 1n) ((guess + (x / guess)) / 2)):(nat@all -> (int@all -> int@all)@all)@all
  in
  rootRec steps 1

def square : (int@all -> int@all)@all
def square x = x * x

def euclideanDist: ((int@{A, B} × int@{A, B})@{A, B} ->  ((int@{A, B} × int@{A, B})@{A, B} -> int@@{A, B})@all)@all
def euclideanDist (a0, a1) (b0, b1) = root ((square (a0 - b0)) + (square (a1 - b1)))

def minEuclideanDist : ( (array{{A, B}}((int[gmw]@{A, B}@{A, B} × int[gmw]@{A, B}@{A, B} )@{A, B}))@{A, B}  -> ((int[gmw]@{A, B}@{A, B} × int[gmw]@{A, B}@{A, B} )@{A, B} -> (int[gmw]@{A,B})@{A,B})@all)@all
def minEuclideanDist vs pt = par {A, B}
  let len = size vs in
  let minRec = (fun [minRec] i min ->
    if i == len then
      min
    else
      let dist = euclideanDist vs.i pt in
      minRec (i + 1n) (mux if dist <= min then dist else min)): (nat@{A,B} -> {{A,B}} (int[gmw]@{A,B}@{A,B} -> {{A, B}} int[gmw]@{A,B}@{A,B})@{A,B} )@{A,B}
  in
  minRec 0n maxInt

def main () = par {A,B}
  let inputA = par {A} read (array {A} (ℤ × ℤ)) from "euclidean-5.txt" in
  let inputB = par {B} read (ℤ × ℤ) from "euclidean-5.txt" in

  let shareA = share [gmw, array {A} (ℤ × ℤ) : {A} → {A,B}] inputA in
  let shareB = share [gmw, ℤ × ℤ         : {B} → {A,B}] inputB in

  reveal [gmw, ℤ : {A,B} → {A}] minEuclideanDist shareA shareB
