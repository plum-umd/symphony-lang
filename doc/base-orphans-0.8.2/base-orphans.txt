-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Backwards-compatible orphan instances for base
--   
--   <tt>base-orphans</tt> defines orphan instances that mimic instances
--   available in later versions of <tt>base</tt> to a wider (older) range
--   of compilers. <tt>base-orphans</tt> does not export anything except
--   the orphan instances themselves and complements
--   <tt><a>base-compat</a></tt>. See the README for what instances are
--   covered: <a>https://github.com/haskell-compat/base-orphans#readme</a>.
--   See also the <a>what is not covered</a> section.
@package base-orphans
@version 0.8.2


-- | Exports orphan instances that mimic instances available in later
--   versions of <tt>base</tt>. To use them, simply <tt>import Data.Orphans
--   ()</tt>.
module Data.Orphans
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Arrow.Kleisli m a)
instance Data.Bits.Bits a => Data.Bits.Bits (Data.Ord.Down a)
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Ord.Down a)
instance GHC.Enum.Enum a => GHC.Enum.Enum (Data.Ord.Down a)
instance GHC.Float.Floating a => GHC.Float.Floating (Data.Ord.Down a)
instance GHC.Real.Fractional a => GHC.Real.Fractional (Data.Ord.Down a)
instance GHC.Real.Integral a => GHC.Real.Integral (Data.Ord.Down a)
instance GHC.Arr.Ix a => GHC.Arr.Ix (Data.Ord.Down a)
instance GHC.Real.Real a => GHC.Real.Real (Data.Ord.Down a)
instance GHC.Real.RealFrac a => GHC.Real.RealFrac (Data.Ord.Down a)
instance GHC.Float.RealFloat a => GHC.Float.RealFloat (Data.Ord.Down a)
instance Foreign.Storable.Storable a => Foreign.Storable.Storable (Data.Ord.Down a)
instance Data.Bits.FiniteBits a => Data.Bits.FiniteBits (Data.Ord.Down a)
instance (Data.Orphans.Prelude.Typeable2 a, Data.Typeable.Internal.Typeable b, Data.Typeable.Internal.Typeable c, Data.Data.Data (a b c)) => Data.Data.Data (Control.Applicative.WrappedArrow a b c)
instance (Data.Orphans.Prelude.Typeable1 m, Data.Typeable.Internal.Typeable a, Data.Data.Data (m a)) => Data.Data.Data (Control.Applicative.WrappedMonad m a)
instance Data.Data.Data a => Data.Data.Data (Control.Applicative.ZipList a)
instance GHC.Base.Functor ((,,) a b)
instance (GHC.Base.Monoid a, GHC.Base.Monoid b) => GHC.Base.Applicative ((,,) a b)
instance (GHC.Base.Monoid a, GHC.Base.Monoid b) => GHC.Base.Monad ((,,) a b)
instance GHC.Base.Functor ((,,,) a b c)
instance (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c) => GHC.Base.Applicative ((,,,) a b c)
instance (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c) => GHC.Base.Monad ((,,,) a b c)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Control.Arrow.Kleisli m a)
instance GHC.Base.Alternative m => GHC.Base.Alternative (Control.Arrow.Kleisli m a)
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Arrow.Kleisli m a)
instance GHC.Base.MonadPlus m => GHC.Base.MonadPlus (Control.Arrow.Kleisli m a)
instance GHC.Exts.IsList (Control.Applicative.ZipList a)
instance forall k1 k2 (f :: k2 -> *) (g :: k1 -> k2). Data.Type.Equality.TestEquality f => Data.Type.Equality.TestEquality (Data.Functor.Compose.Compose f g)
