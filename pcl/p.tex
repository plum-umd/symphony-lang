\documentclass[11pt]{article}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{semantic}
\usepackage{mathtools}
	
\title{Pantheon Circuit Language (PCL)}
\author{Pantheon Team}

% language keywords
\newcommand{\kw}[1]{\textsf{#1}}
\newcommand{\klet}{\kw{let}}
\newcommand{\kin}{\kw{in}}
\newcommand{\kfix}{\kw{fix}}
\newcommand{\kfst}{\kw{fst}}
\newcommand{\ksnd}{\kw{snd}}
\newcommand{\ktrue}{\kw{true}}
\newcommand{\kfalse}{\kw{false}}
\newcommand{\kand}{\kw{and}}
\newcommand{\kxor}{\kw{xor}}
\newcommand{\kif}{\kw{if}}
\newcommand{\kthen}{\kw{then}}
\newcommand{\kelse}{\kw{else}}
\newcommand{\kadd}{\kw{add}}
\newcommand{\kmul}{\kw{mul}}

\newcommand{\judges}{\vdash}

\begin{document}

\maketitle

\begin{figure}
\begin{align*}
  t ::=&~t~t &\text{application}\\
  	  |&~\klet~x=t~\kin~t &\text{let binding}\\
  	  |&~\klet~f_n~(x:T)=t~\kin~t &\text{first order, recursive function definition}\\
  	  |&~x &\text{variable}\\
  	  |&~(t, t)~|~\kfst(t)~|~\ksnd(t) &\text{pairs and projections}\\
  	  |&~\ktrue~|~\kfalse~|~\kand~|~\kxor &\text{boolean primitives}\\
  	  |&~\kif~t~\kthen~t~\kelse~t &\text{conditional}\\
  	  |&~0~|~1~|~\ldots~|~\kadd~|~\kmul &\text{field primitives}\\
  T ::=&~\mathbb{B}~|~\mathbb{F}~|~T\times T &\text{first order types}\\
  \dot{T} ::=&~T \rightarrow T &\text{function types}
\end{align*}
\caption{%
The space of program terms ($t$) first order types ($T$) and function types ($\dot{T}$) in PCL.
Metavariables $f$ and $x$ range over the space of variable names.
$n$ ranges over cleartext natural numbers.
}\label{fig:spaces}
\end{figure}

\begin{figure}
\begin{spreadlines}{0.8em}
\begin{gather*}
\inference{%
  \Gamma \judges t_0 :: T_0 \rightarrow T_1&
  \Gamma \judges t_1 : T_0
}{%
  \Gamma \judges t_0~t_1 : T_1 
}
\\
\inference{%
  \Gamma \judges t_0 : T_0&
  (\Gamma, x:t_0) \judges t_1 : T_1
}{%
  \Gamma \judges \klet~x=t_0~\kin~t_1 : T_1
}
\\
\inference{%
  (\Gamma, x:T_0, f::T_0\rightarrow T_1) \judges t_0 : T_1&
  (\Gamma, f::T_0\rightarrow T_1) \judges t_1 : T_2
}{%
  \Gamma \judges \klet~f_n~(x:T_0)=t_0~\kin~t_1 : T_2
}
\\
\inference{%
  x:T \in \Gamma
}{%
  \Gamma \judges x : T
}
\qquad
\inference{%
  x::\dot{T} \in \Gamma
}{%
  \Gamma \judges x :: \dot{T}
}
\\
\inference{%
  \Gamma \judges t_0 : T_0&
  \Gamma \judges t_1 : T_1
}{%
  \Gamma \judges (t_0, t_1) : T_0 \times T_1
}
\\
\inference{%
  \Gamma \judges t : T_0 \times T_1
}{%
  \Gamma \judges \kfst(t) : T_0
}
\qquad
\inference{%
  \Gamma \judges t : T_0 \times T_1
}{%
  \Gamma \judges \ksnd(t) : T_1
}
\\
\inference{%
}{%
  \Gamma \judges \ktrue : \mathbb{B}
}
\qquad
\inference{%
}{%
  \Gamma \judges \kfalse : \mathbb{B}
}
\\
\inference{%
}{%
  \Gamma \judges \kand :: (\mathbb{B} \times \mathbb{B}) \rightarrow \mathbb{B}
}
\qquad
\inference{%
}{%
  \Gamma \judges \kxor :: (\mathbb{B} \times \mathbb{B}) \rightarrow \mathbb{B}
}
\\
\inference{%
  \Gamma \judges t_0 : \mathbb{B}&
  \Gamma \judges t_1 : T&
  \Gamma \judges t_2 : T
}{%
  \Gamma \judges \kif~t_0~\kthen~t_1~\kelse~t_2 : T
}
\end{gather*}	
\end{spreadlines}
\caption{%
Typing judgements of PCL. Judgements are of the form $\Gamma \judges t : T$ ($t$ has first order type $T$ in the context $\Gamma$) and $\Gamma \judges t :: \dot{T}$ ($t$ has function type $\dot{T}$ in the context $\Gamma$).
}\label{fig:judgements}
\end{figure}

The Pantheon Circuit Language (PCL) is intended to encode the precise actions that are carried out by a cryptographic backend.
This is in contrast to the Pantheon Source Language (PSL) whose intent is to encode a mixing of cleartext and encrypted actions.
The core purpose of PCL is to act as an intermediary between PSL and the exact specification language of a target cryptographic backend.
%
Therefore, the PCL is intended to be user facing to developers of cryptographic backends.
The language should therefore be relatively minimal and, e.g., includes no advanced features like polymorphism.

The spaces of program terms and types are defined in Figure \ref{fig:spaces}.
%
In general, the language includes (1) boolean and field operations, (2) bounded control flow (conditionals and bounded recursion), and (3) variable and function bindings.
The language is first order and functions can only be applied after being bound to a variable (i.e. they cannot be stored in data structures, passed as function arguments, or returned as function values).

Figure \ref{fig:judgements} specifies the typing judgements for PCL.

\subsection{An example backend}

In this example, we include a simple backend language and demonstrate how PCL can be translated to this language.
The language is a simplistic encoding of Boolean circuits.
Programs in the language consist of a list of three possible types of assignments (let $x_0, x_1, x_2$ range over the space of variables):
\begin{align*}
  x_0 &:= \kw{AND}~x_1~x_2\\
  x_0 &:= \kw{XOR}~x_1~x_2\\
  x_0 &:= \kw{INV}~x_1
\end{align*}

Since programs in PCL are fundamentally bounded, translating to this backend is relatively straightforward.
The key idea is to symbolically execute the PCL program in its entirety, writing down Boolean gates that occur (and instantiating field operations with a fixed library of corresponding Boolean circuits).

\subsection{Questions and Discussion}

\begin{itemize}
  \item How should input/output be handled? So far, I just specify that the top level term is a function, but how are parts of the inputs associated with players?
  \item What about other representations than fields? For example, some crypto approaches work with rings. Is some more general IR possible and clear, or should we just extend PCL over time?
  \item Thoughts on why we include bounded recursion, conditionals: There are two key points here.
  	First, there is a fundamental efficiency problem with fully writing a circuit down (e.g. in the example syntax).
  	By fully realizing the circuit, the program may consume immense resources (simply to maintain a wiring for the entire circuit).
  	In contrast, by keeping the program in a compact representation we avoid the overhead of fully inlining.
  	Second, there may crypto optimizations possible at the control flow level (For an example, see Free IF).
  	It may be difficult to undo an early decision to not include control flow in PCL.
\end{itemize}


\end{document}
