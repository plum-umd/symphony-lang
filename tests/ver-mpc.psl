-- a particularly nasty twist in the challenge problems is that
-- sometimes the "Prover" isn't a single party: it's really an MPC
-- between multiple parties. This example illustrates how we can
-- implement such solutions in an extension of PSL.

-- The example is a bit contrived: it's a bit hard for me to come up
-- with a natural example where the Prover is an MPC that doesn't
-- involve PKI signing (although maybe someone who more deeply groks
-- MPC has one ready), which I would like to introduce in a distinct
-- example. So please just take it with a grain of salt.

-- Here is an example where an MPC between Alice and Bob proves that
-- it knows a "Beaver triple;" i.e., a triple of the form
--
-- (a, b, a * b)

-- It'll build this triple by having Alice provide the first input,
-- having Bob provide the second input, and then computing the product
-- in an MPC.

principal Alice Bob

-- main: computes a NIZK proof that a Yao MPC between Alice and Bob
-- knows a Beaver triple.
def main () =
  let priv_a = par { Alice } 3 in
  let priv_b = par { Bob } 5 in

  -- shr_a/shr_b: shares of Alice and Bob's private inputs (computed
  -- using existing forms).
  let shr_a = share{ yao : Alice -> Alice, Bob } priv_a in
  let shr_b = share{ yao : Bob -> Alice, Bob } priv_b in

  -- shr_prod: shares of the product of Alice and Bob's private inputs
  -- (computed using existing forms).
  let shr_prod = shr_a * shr_b in

  -- wit-a: an atomic testing circuit, defined by shares of Alice's
  -- input. wit-a is defined using the aspirational nizk-witness form
  -- introduced in ver-0.psl. The key distinction from ver-0.psl is
  -- that to express that it tests witnesses that are *shares in some
  -- protocol*, we need to generalize the nizk-test type qualifier so
  -- that nizk-test types aren't indexed directly by sets of
  -- principals: instead, they're indexed by a set of principals *and
  -- a protocol* (so mercifully, not exactly an earthshaking
  -- generalization). With that extension in hand, we can express the
  -- type of wit-a as:
  --
  -- wit-a : int{ nizk-test : (yao : { Alice, Bob }) }
  --
  -- The types from ver-0 can naturally be folded into this by viewing
  -- them as types indexed by an implied "common secret" or
  -- "plaintext" protocol.
  let wit-a = nizk-witness { yao : Alice, Bob } shr_a in

  -- wit-b: the similar witness value, built from Bob's input:
  let wit-b = nizk-witness { yao : Alice, Bob } shr_b in

  -- wit-prod: the similar witness built from the product that they
  -- computed:
  let wit-prod = nizk-witness { yao : Alice, Bob } prod in

  -- beaver_test : bool{ nizk-test : (yao : { Alice, Bob }) } : the
  -- test that wit-prod is the product of wit-a and wit-b. This is
  -- defined analogously to [test-non-neg] in ver-0.psl, by applying
  -- various operations that are defined over the base type (here,
  -- multiplication and equality test).
  let beaver_test = wit-a * wit-b == wit-prod in
    
  -- The expression below evaluates to a NIZK proof that a Yao MPC
  -- between Alice and Bob knows a witness that evaluates
  -- [beaver_test] to true. It uses the aspirational [nizk-commit]
  -- form introduced in ver-0.psl.
  nizk-commit beaver_test
