def solo-f : ∀ A:☆. (P:ℙs) → ((p:ℙ | {p}⊆P) →{p} A) →{P} A{isec:P}
def solo-f P f = case P
  { {} → ⟪⟫
  ; {p}∪P′ → ⟪ p | par {p} f p ⟫ ⧺ solo-f P′ f
  }


def fold-f : ∀ A:☆,B:☆,P:ℙs. B → ((p:ℙ | {p}⊆P) → A → B →{P} B) → A{isec:P} →{P} B
def fold-f i f xs = case xs
  { ⟪⟫ → i
  ; ⟪p|x⟫⧺xs′ → f p x (fold-f i f xs′)
  }

-- Safe version of tail: If the list is empty, the tail of the list is the
-- empty list.
def tail : list int -> list int
def tail xs = case xs
  { [] -> []
  ; _::xs' -> xs'
  }


def foldr : (a -> b -> b) -> b -> list a -> b
def foldr f acc xs = case xs
  { [] -> acc
  ; x::xs' -> f x (foldr f acc xs')
  }


-- Compute the length of a list.
def length : list int -> int
def length = foldr (fun _ n -> n+1) 0


def append : list a -> list a -> list a
def append xs ys = foldr (fun x zs -> x :: zs) ys xs


def concat : list (list a) -> list a
def concat = foldr (fun xs xss -> append xs xss) []

def zip xs ys = case (xs,ys)
  { ([],_) → []
  ; (_,[]) → []
  ; (x∷xs',y∷ys') → (x,y)∷(zip xs' ys')
  }

def fst p = case p
  { (f,_) → f
  }

def snd p = case p
  { (_,s) → s
  }

-- List map.
def map : (a -> b) -> list a -> list b
def map f xs = foldr (fun x ys -> f x :: ys) [] xs


-- Convert a known list into a list of known objects.
-- The list will contain the first `n` elements of the known list.
-- If `n` exceeds the length of the list, the list will be padded with default.
def sequenceKnownnessN :
  forall knowers:prin.
  int -> int -> (list int){ssec:knowers} -> list (int{ssec:knowers})
def sequenceKnownnessN knowers n default xs =
  let shareHead : (list int){ssec:knowers} -> int{ssec:knowers}
  let shareHead = fun xs ->
    par {knowers} case xs
                  { [] -> default
                  ; x::_ -> x
                  }

  if n == 0
  then []
  else
    shareHead xs ::
      sequenceKnownnessN knowers (n - 1) default (par {knowers} (tail xs))


-- Convert a known list into a list of known objects.
-- WARNING: This shares the length of the list in cleartext.
def sequenceKnownness :
  forall knowers:prin.
  (list int){ssec:knowers} -> list (int{ssec:knowers})
def sequenceKnownness knowers xs =
  let n = par {knowers} length xs
  let n' = send {knowers -> this} n
  in sequenceKnownnessN {knowers} n' 0 xs

def obliv-head : ∀ P:☆. ℤ → (list ℤ){isec:P} → ℤ{isec:P}
def obliv-head P i xs = solo {P} as α in case xs@α
  { [] → i
  ; x∷_ → x
  }

def obliv-tail : ∀ P:☆. (list ℤ){isec:P} → (list ℤ){isec:P}
def obliv-tail P xs = solo {P} as α in case xs@α
  { [] → []
  ; _∷xs′ → xs′
  }

def preprocess-lists : (P:ℙ) → ℕ → ℤ → (list ℤ){isec:P} → list ℤ{isec:P}
def preprocess-lists P n i xs =
  if n <= 0
  then []
  else
    let x′ : ℤ{isec:P}
    let x′ = obliv-head P i xs
    let xs′ : list ℤ{isec:P}
    let xs′ = preprocess-lists P (n - 1) i (obliv-tail P xs)
    in
    x′ ∷ xs′

-- Merge sort, copy and pasted and modified slightly, used by atq
--def list-cond :
--    𝔹{yao:C}
--  → list ℤ{yao:C}
--  → list ℤ{yao:C}
--  → list ℤ{yao:C}
def list-cond b xs ys = case xs,ys
  { [],_ → ys
  ; _,[] → xs
  ; x∷xs′,y∷ys′ → b ? x ◇ y ∷ list-cond b xs′ ys′
  }

--def split : list ℤ{isec:A,B} → list ℤ{isec:A,B} × list ℤ{isec:A,B}
def split xs = case xs
  { [] → [] , []
  ; [x] → [] , [x]
  ; x₁∷x₂∷xs →
      let xs₁,xs₂ = split xs
      in x₁∷xs₁,x₂∷xs₂
  }

--def merge :
--    list ℤ{yao:C}
--  → list ℤ{yao:C}
--  → list ℤ{yao:C}
def merge xs ys = case xs,ys
  { [],_ → ys
  ; _,[] → xs
  ; x∷xs′,y∷ys′ →
      list-cond (x ≤ y)
                (x ∷ merge xs′ ys)
                (y ∷ merge xs ys′)
  }

--input is shares instead of isec
--def msort : list ℤ{isec:A,B} → list ℤ{yao:C}
def msort xs = case xs
  { [] → []
  ; [x] → [x]
  ; x₁∷x₂∷xs′ →
      let xs₁,xs₂ = split xs
      let ys₁ = msort xs₁
      let ys₂ = msort xs₂
      in merge ys₁ ys₂
  }
-- Merge sort end
