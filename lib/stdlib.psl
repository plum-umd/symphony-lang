def solo-f : âˆ€ A:â˜†. (P:â„™s) â†’ ((p:â„™ | {p}âŠ†P) â†’{p} A) â†’{P} A{isec:P}
def solo-f P f = case P
  { {} â†’ âŸªâŸ«
  ; {p}âˆªPâ€² â†’ âŸª p | par {p} f p âŸ« â§º solo-f Pâ€² f
  }


def fold-f : âˆ€ A:â˜†,B:â˜†,P:â„™s. B â†’ ((p:â„™ | {p}âŠ†P) â†’ A â†’ B â†’{P} B) â†’ A{isec:P} â†’{P} B
def fold-f i f xs = case xs
  { âŸªâŸ« â†’ i
  ; âŸªp|xâŸ«â§ºxsâ€² â†’ f p x (fold-f i f xsâ€²)
  }


def fst : (a * b) -> a
def fst x = case x { (a, _) -> a }


def snd : (a * b) -> a
def snd x = case x { (_, b) -> b }


def at : a -> nat -> list a -> a
def at default ix xs = case xs
  { [] -> default
  ; (x::xs') -> if ix == 0
                then x
                else at default (ix - 1) xs'
  }


def head : a -> list a -> a
def head default = at default 0


-- Safe version of tail: If the list is empty, the tail of the list is the
-- empty list.
def tail : list int -> list int
def tail xs = case xs
  { [] -> []
  ; _::xs' -> xs'
  }


def foldr : (a -> b -> b) -> b -> list a -> b
def foldr f acc xs = case xs
  { [] -> acc
  ; x::xs' -> f x (foldr f acc xs')
  }


-- List map.
def map : (a -> b) -> list a -> list b
def map f xs = foldr (fun x ys -> f x :: ys) [] xs


def filter : (a -> bool) -> list a -> list a
def filter p xs =
  case xs
  { [] -> []
  ; (x::xs') -> if p x
                then x :: filter p xs'
                else filter p xs'
  }


-- Compute the length of a list.
def length : list int -> int
def length = foldr (fun _ n -> n+1) 0


-- Oblivious friendly insert to list.
def insert : (a -> a -> (a * a)) -> a -> list a -> list a
def insert minmax x xs = case xs
  { [] -> [x]
  ; (x'::xs') ->
      let lo, hi = minmax x x'
      in lo :: insert minmax hi xs'
  }


-- Oblivious friendly sort. Always O(n^2)
def sort : (a -> a -> (a * a)) -> list a -> list a
def sort minmax = foldr (insert minmax) []


def median : (a -> a -> (a * a)) -> a -> list a -> a
def median minmax default xs =
  at default (length xs / 2) (sort minmax xs)


def sum : list float -> float
def sum = foldr (fun x y -> x + y) 0.0


def mean : list float -> float
def mean xs = sum xs / to_flt (length xs)


def stddev : list float -> float
def stddev xs =
  let m = mean xs
  let square = fun x -> x * x
  let diffs = map (fun x -> square (x - m)) xs
  in sqrt (mean diffs)


def natminmax : nat -> nat -> (nat * nat)
def natminmax x y = if x < y then x, y else y, x


def floatminmax : float -> float -> (float * float)
def floatminmax x y = if x < y then x, y else y, x


def split : nat -> list a -> (list a * list a)
def split n xs =
  if n == 0
  then [], xs
  else
    case xs
    { [] -> []
    ; (x::xs') ->
        let take, drop = split (n - 1) xs'
        in x::take, drop
    }


def take : nat -> list a -> list a
def take n xs = fst (split n xs)

def drop : nat -> list a -> list a
def drop n xs = snd (split n xs)


def append : list a -> list a -> list a
def append xs ys = foldr (fun x zs -> x :: zs) ys xs


def concat : list (list a) -> list a
def concat = foldr (fun xs xss -> append xs xss) []

def zip xs ys = case (xs,ys)
  { ([],_) â†’ []
  ; (_,[]) â†’ []
  ; (xâˆ·xs',yâˆ·ys') â†’ (x,y)âˆ·(zip xs' ys')
  }

def fst p = case p
  { (f,_) â†’ f
  }

def snd p = case p
  { (_,s) â†’ s
  }


def rangen-help : nat -> nat -> list nat
def rangen-help n goal =
  if n == goal
  then []
  else n :: rangen-help (n+1) goal

def rangen : nat -> list nat
def rangen n = rangen-help 0 n


def reverse-help : list a -> list a -> list a
def reverse-help xs acc =
  case xs
  { [] -> acc
  ; (x::xs') -> reverse-help xs' (x::acc)
  }


def reverse : list a -> list a
def reverse xs = reverse-help xs []


-- Convert a known list into a list of known objects.
-- The list will contain the first `n` elements of the known list.
-- If `n` exceeds the length of the list, the list will be padded with default.
def sequenceKnownnessN :
  forall knowers:prin.
  int -> int -> (list int){ssec:knowers} -> list (int{ssec:knowers})
def sequenceKnownnessN knowers n default xs =
  let shareHead : (list int){ssec:knowers} -> int{ssec:knowers}
  let shareHead = fun xs ->
    par {knowers} case xs
                  { [] -> default
                  ; x::_ -> x
                  }

  if n == 0
  then []
  else
    shareHead xs ::
      sequenceKnownnessN knowers (n - 1) default (par {knowers} (tail xs))


-- Convert a known list into a list of known objects.
-- WARNING: This shares the length of the list in cleartext.
def sequenceKnownness :
  forall knowers:prin.
  (list int){ssec:knowers} -> list (int{ssec:knowers})
def sequenceKnownness knowers xs =
  let n = par {knowers} length xs
  let n' = send {knowers -> this} n
  in sequenceKnownnessN {knowers} n' 0 xs

def obliv-head : âˆ€ P:â˜†. â„¤ â†’ (list â„¤){isec:P} â†’ â„¤{isec:P}
def obliv-head P i xs = solo {P} as Î± in case xs@Î±
  { [] â†’ i
  ; xâˆ·_ â†’ x
  }

def obliv-tail : âˆ€ P:â˜†. (list â„¤){isec:P} â†’ (list â„¤){isec:P}
def obliv-tail P xs = solo {P} as Î± in case xs@Î±
  { [] â†’ []
  ; _âˆ·xsâ€² â†’ xsâ€²
  }

def preprocess-lists : (P:â„™) â†’ â„• â†’ â„¤ â†’ (list â„¤){isec:P} â†’ list â„¤{isec:P}
def preprocess-lists P n i xs =
  if n <= 0
  then []
  else
    let xâ€² : â„¤{isec:P}
    let xâ€² = obliv-head P i xs
    let xsâ€² : list â„¤{isec:P}
    let xsâ€² = preprocess-lists P (n - 1) i (obliv-tail P xs)
    in
    xâ€² âˆ· xsâ€²

-- Merge sort, copy and pasted and modified slightly, used by atq
--def list-cond :
--    ð”¹{yao:C}
--  â†’ list â„¤{yao:C}
--  â†’ list â„¤{yao:C}
--  â†’ list â„¤{yao:C}
def list-cond b xs ys = case xs,ys
  { [],_ â†’ ys
  ; _,[] â†’ xs
  ; xâˆ·xsâ€²,yâˆ·ysâ€² â†’ b ? x â—‡ y âˆ· list-cond b xsâ€² ysâ€²
  }

--def split : list â„¤{isec:A,B} â†’ list â„¤{isec:A,B} Ã— list â„¤{isec:A,B}
def split xs = case xs
  { [] â†’ [] , []
  ; [x] â†’ [] , [x]
  ; xâ‚âˆ·xâ‚‚âˆ·xs â†’
      let xsâ‚,xsâ‚‚ = split xs
      in xâ‚âˆ·xsâ‚,xâ‚‚âˆ·xsâ‚‚
  }

--def merge :
--    list â„¤{yao:C}
--  â†’ list â„¤{yao:C}
--  â†’ list â„¤{yao:C}
def merge xs ys = case xs,ys
  { [],_ â†’ ys
  ; _,[] â†’ xs
  ; xâˆ·xsâ€²,yâˆ·ysâ€² â†’
      list-cond (x â‰¤ y)
                (x âˆ· merge xsâ€² ys)
                (y âˆ· merge xs ysâ€²)
  }

--input is shares instead of isec
--def msort : list â„¤{isec:A,B} â†’ list â„¤{yao:C}
def msort xs = case xs
  { [] â†’ []
  ; [x] â†’ [x]
  ; xâ‚âˆ·xâ‚‚âˆ·xsâ€² â†’
      let xsâ‚,xsâ‚‚ = split xs
      let ysâ‚ = msort xsâ‚
      let ysâ‚‚ = msort xsâ‚‚
      in merge ysâ‚ ysâ‚‚
  }
-- Merge sort end













---
--- VECTOR LIBRARY
---


def int-swap b x y = b ? x >< y
def bool-swap b x y = b ? x >< y
def flt-swap b x y = b ? x >< y


-- given a swap function for type a, build swap for bool * a
-- def tag-swap : (bool{P} -> a -> a -> a) 
--             -> (bool{P} -> bool{P} * a -> bool{P} * a -> bool{P} * a)
def tag-swap swap =
  fun b x y ->
    let tx, x' = x
    let ty, y' = y
    in (b ? tx >< ty), (swap b x' y')


-- def init-content : nat -> a -> array{P} a
def content-init default n =
  if n == 0
  then []
  else
    (false, default) :: content-init default (n - 1)


-- def vector-init : a -> (bool{P} -> a -> a -> a) -> nat -> vector{P} a
def vec-init default swap n =
  let tswap = tag-swap swap
  in
    default, tswap, content-init default n


def content-write swap cond n y xs =
  case xs
  { [] -> []
  ; cell::xs' ->
    let (tag, x) = cell
    in
      swap (cond && (n == 0) && tag) (tag, y) cell
        :: content-write swap cond (n - 1) y xs'
  }


-- def vector : nat{P} -> a -> vector{P} a -> vector{P} a
def vec-cond-write cond n y vec =
  let default, swap, xs = vec
  in default, swap, (content-write swap cond n y xs)

def vec-write = vec-cond-write true

def not b = b ? false >< true

def content-push swap flag cond y xs =
  case xs
  { [] -> []
  ; cell::xs' ->
    let (tag, x) = cell
    in
      swap (cond && not tag && flag) (true, y) cell
        :: content-push swap tag cond y xs'
  }

def vec-cond-push cond x vec =
  let default, swap, xs = vec
  in default, swap, (content-push swap true cond x xs)

def vec-push = vec-cond-push true


def resize-content n xs =
  case xs
  { [] -> []
  ; cell::xs ->
    let (tag, x) = cell
    in
      (n > 0, x) :: resize-content (n - 1) xs
  }


-- def resize : nat{P} -> vector{P} a -> vector{P} a
def vec-resize n vec =
  let default, swap, xs = vec
  in default, swap, (resize-content n xs)


def content-size xs =
  case xs
  { [] -> 0
  ; cell::xs ->
    let (tag, x) = cell
    let diff = tag ? 1 >< 0
    in
      diff + content-size xs
  }


def vec-length vec =
  let default, swap, xs = vec
  in content-size xs

def vec-capacity vec =
  let _, _, xs = vec
  in length xs


def content-read default swap n xs =
  case xs
  { [] -> false, default
  ; cell::xs' ->
    let tl = content-read default swap (n - 1) xs'
    in swap (n == 0) cell tl
  }


def vec-read n vec =
  let default, swap, xs = vec
  in content-read default swap n xs


def content-swap swap b xs ys =
  case xs, ys
  { [], [] -> []
  ; x::xs, y::ys -> swap b x y :: content-swap swap b xs ys
  }


def vec-swap b vecx vecy =
  let default, swap, xs = vecx
  let _, _, ys = vecy
  in default, swap, content-swap swap b xs ys

-- def vec-content : vec{P} a -> list (bool{P} * a{P})
def vec-content vec =
  let _, _, xs = vec
  in xs

def vec-append xs ys =
  foldr (fun c acc ->
    let r, x = c
    in vec-cond-push r x acc) xs (reverse (vec-content ys))


def int-vec-init = vec-init 0 (fun b x y -> b ? x >< y)

def share-as-vec-content knowers shareFlag shareContent default n xs =
  if n == 0
  then []
  else
    let flag = par {knowers} case xs
                   { [] -> false
                   ; x::_ -> true
                   }
    let head = par {knowers} case xs
                    { [] -> default
                    ; x::_ -> x
                    }
    let sflag = shareFlag flag
    let shead = shareContent head
    in (sflag, shead) :: share-as-vec-content
      knowers shareFlag shareContent default (n - 1) (par {knowers} tail xs)



-- def share-as-vec : P
--                 -> (bool -> bool{P})
--                 -> (a -> a{P})
--                 -> a
--                 -> (bool{P} -> a{P} -> a{P} -> a{P})
--                 -> list a -> nat -> vec{P} a
def share-as-vec knowers shareFlag shareContent default swap n xs =
  default, tag-swap swap,
      share-as-vec-content knowers shareFlag shareContent default n xs



-- def vec-reveal : (a{P} -> a) -> vec{P} a -> list a
def vec-reveal revealContent vec =
  let _, _, xs = vec
  let revealed = map (fun cell ->
    let t, x = cell
    in reveal {this} t, revealContent x) xs
  let filtered = filter (fun cell ->
    let t, x = cell in t) revealed
  in map snd filtered





