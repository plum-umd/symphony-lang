def solo-f : ∀ A:☆. (P:ℙs) → ((p:ℙ | {p}⊆P) →{p} A) →{P} A{isec:P}
def solo-f P f = case P
  { {} → ⟪⟫
  ; {p}∪P′ → ⟪ p | par {p} f p ⟫ ⧺ solo-f P′ f
  }


def fold-f : ∀ A:☆,B:☆,P:ℙs. B → ((p:ℙ | {p}⊆P) → A → B →{P} B) → A{isec:P} →{P} B
def fold-f i f xs = case xs
  { ⟪⟫ → i
  ; ⟪p|x⟫⧺xs′ → f p x (fold-f i f xs′)
  }


def fst : (a * b) -> a
def fst x = case x { (a, _) -> a }

def snd : (a * b) -> a
def snd x = case x { (_, b) -> b }


def at : a -> nat -> list a -> a
def at default ix xs = case xs
  { [] -> default
  ; (x::xs') -> if ix == 0
                then x
                else at default (ix - 1) xs'
  }


def head : a -> list a -> a
def head default = at default 0


-- Safe version of tail: If the list is empty, the tail of the list is the
-- empty list.
def tail : list int -> list int
def tail xs = case xs
  { [] -> []
  ; _::xs' -> xs'
  }


def foldr : (a -> b -> b) -> b -> list a -> b
def foldr f acc xs = case xs
  { [] -> acc
  ; x::xs' -> f x (foldr f acc xs')
  }


-- List map.
def map : (a -> b) -> list a -> list b
def map f xs = foldr (fun x ys -> f x :: ys) [] xs


-- Compute the length of a list.
def length : list int -> int
def length = foldr (fun _ n -> n+1) 0


-- Oblivious friendly insert to list.
def insert : (a -> a -> (a * a)) -> a -> list a -> list a
def insert minmax x xs = case xs
  { [] -> [x]
  ; (x'::xs') ->
      let lo, hi = minmax x x'
      in lo :: insert minmax hi xs'
  }

-- Oblivious friendly sort. Always O(n^2)
def sort : (a -> a -> (a * a)) -> list a -> list a
def sort minmax = foldr (insert minmax) []


def median : (a -> a -> (a * a)) -> a -> list a -> a
def median minmax default xs =
  at default (length xs / 2) (sort minmax xs)


def sum : list float -> float
def sum = foldr (fun x y -> x + y) 0.0


def mean : list float -> float
def mean xs = sum xs / to_flt (length xs)


def stddev : list float -> float
def stddev xs =
  let m = mean xs
  let square = fun x -> x * x
  let diffs = map (fun x -> square (x - m)) xs
  in sqrt (mean diffs)


def natminmax : nat -> nat -> (nat * nat)
def natminmax x y = if x < y then x, y else y, x


def floatminmax : float -> float -> (float * float)
def floatminmax x y = if x < y then x, y else y, x


def split : nat -> list a -> (list a * list a)
def split n xs =
  if n == 0
  then [], xs
  else
    case xs
    { [] -> []
    ; (x::xs') ->
        let take, drop = split (n - 1) xs'
        in x::take, drop
    }


def take : nat -> list a -> list a
def take n xs = fst (split n xs)

def drop : nat -> list a -> list a
def drop n xs = snd (split n xs)


def append : list a -> list a -> list a
def append xs ys = foldr (fun x zs -> x :: zs) ys xs


def concat : list (list a) -> list a
def concat = foldr (fun xs xss -> append xs xss) []


-- Convert a known list into a list of known objects.
-- The list will contain the first `n` elements of the known list.
-- If `n` exceeds the length of the list, the list will be padded with default.
def sequenceKnownnessN :
  forall knowers:prin.
  int -> int -> (list int){ssec:knowers} -> list (int{ssec:knowers})
def sequenceKnownnessN knowers n default xs =
  let shareHead : (list int){ssec:knowers} -> int{ssec:knowers}
  let shareHead = fun xs ->
    par {knowers} case xs
                  { [] -> default
                  ; x::_ -> x
                  }

  if n == 0
  then []
  else
    shareHead xs ::
      sequenceKnownnessN knowers (n - 1) default (par {knowers} (tail xs))


-- Convert a known list into a list of known objects.
-- WARNING: This shares the length of the list in cleartext.
def sequenceKnownness :
  forall knowers:prin.
  (list int){ssec:knowers} -> list (int{ssec:knowers})
def sequenceKnownness knowers xs =
  let n = par {knowers} length xs
  let n' = send {knowers -> this} n
  in sequenceKnownnessN {knowers} n' 0 xs

