def solo-f : âˆ€ A:â˜†. (P:â„™s) â†’ ((p:â„™ | {p}âŠ†P) â†’{p} A) â†’{P} A{isec:P}
def solo-f P f = case P
  { {} â†’ âŸªâŸ«
  ; {p}âˆªPâ€² â†’ âŸª p | par {p} f p âŸ« â§º solo-f Pâ€² f
  }


def fold-f : âˆ€ A:â˜†,B:â˜†,P:â„™s. B â†’ ((p:â„™ | {p}âŠ†P) â†’ A â†’ B â†’{P} B) â†’ A{isec:P} â†’{P} B
def fold-f i f xs = case xs
  { âŸªâŸ« â†’ i
  ; âŸªp|xâŸ«â§ºxsâ€² â†’ f p x (fold-f i f xsâ€²)
  }

-- Safe version of tail: If the list is empty, the tail of the list is the
-- empty list.
def tail : list int -> list int
def tail xs = case xs
  { [] -> []
  ; _::xs' -> xs'
  }


def foldr : (a -> b -> b) -> b -> list a -> b
def foldr f acc xs = case xs
  { [] -> acc
  ; x::xs' -> f x (foldr f acc xs')
  }


-- Compute the length of a list.
def length : list int -> int
def length = foldr (fun _ n -> n+1) 0


def append : list a -> list a -> list a
def append xs ys = foldr (fun x zs -> x :: zs) ys xs


def concat : list (list a) -> list a
def concat = foldr (fun xs xss -> append xs xss) []

def zip xs ys = case (xs,ys)
  { ([],_) â†’ []
  ; (_,[]) â†’ []
  ; (xâˆ·xs',yâˆ·ys') â†’ (x,y)âˆ·(zip xs' ys')
  }

def fst p = case p
  { (f,_) â†’ f
  }

def snd p = case p
  { (_,s) â†’ s
  }

-- List map.
def map : (a -> b) -> list a -> list b
def map f xs = foldr (fun x ys -> f x :: ys) [] xs


-- Convert a known list into a list of known objects.
-- The list will contain the first `n` elements of the known list.
-- If `n` exceeds the length of the list, the list will be padded with default.
def sequenceKnownnessN :
  forall knowers:prin.
  int -> int -> (list int){ssec:knowers} -> list (int{ssec:knowers})
def sequenceKnownnessN knowers n default xs =
  let shareHead : (list int){ssec:knowers} -> int{ssec:knowers}
  let shareHead = fun xs ->
    par {knowers} case xs
                  { [] -> default
                  ; x::_ -> x
                  }

  if n == 0
  then []
  else
    shareHead xs ::
      sequenceKnownnessN knowers (n - 1) default (par {knowers} (tail xs))


-- Convert a known list into a list of known objects.
-- WARNING: This shares the length of the list in cleartext.
def sequenceKnownness :
  forall knowers:prin.
  (list int){ssec:knowers} -> list (int{ssec:knowers})
def sequenceKnownness knowers xs =
  let n = par {knowers} length xs
  let n' = send {knowers -> this} n
  in sequenceKnownnessN {knowers} n' 0 xs

def obliv-head : âˆ€ P:â˜†. â„¤ â†’ (list â„¤){isec:P} â†’ â„¤{isec:P}
def obliv-head P i xs = solo {P} as Î± in case xs@Î±
  { [] â†’ i
  ; xâˆ·_ â†’ x
  }

def obliv-tail : âˆ€ P:â˜†. (list â„¤){isec:P} â†’ (list â„¤){isec:P}
def obliv-tail P xs = solo {P} as Î± in case xs@Î±
  { [] â†’ []
  ; _âˆ·xsâ€² â†’ xsâ€²
  }

def preprocess-lists : (P:â„™) â†’ â„• â†’ â„¤ â†’ (list â„¤){isec:P} â†’ list â„¤{isec:P}
def preprocess-lists P n i xs =
  if n <= 0
  then []
  else
    let xâ€² : â„¤{isec:P}
    let xâ€² = obliv-head P i xs
    let xsâ€² : list â„¤{isec:P}
    let xsâ€² = preprocess-lists P (n - 1) i (obliv-tail P xs)
    in
    xâ€² âˆ· xsâ€²

-- Merge sort, copy and pasted and modified slightly, used by atq
--def list-cond :
--    ð”¹{yao:C}
--  â†’ list â„¤{yao:C}
--  â†’ list â„¤{yao:C}
--  â†’ list â„¤{yao:C}
def list-cond b xs ys = case xs,ys
  { [],_ â†’ ys
  ; _,[] â†’ xs
  ; xâˆ·xsâ€²,yâˆ·ysâ€² â†’ b ? x â—‡ y âˆ· list-cond b xsâ€² ysâ€²
  }

--def split : list â„¤{isec:A,B} â†’ list â„¤{isec:A,B} Ã— list â„¤{isec:A,B}
def split xs = case xs
  { [] â†’ [] , []
  ; [x] â†’ [] , [x]
  ; xâ‚âˆ·xâ‚‚âˆ·xs â†’
      let xsâ‚,xsâ‚‚ = split xs
      in xâ‚âˆ·xsâ‚,xâ‚‚âˆ·xsâ‚‚
  }

--def merge :
--    list â„¤{yao:C}
--  â†’ list â„¤{yao:C}
--  â†’ list â„¤{yao:C}
def merge xs ys = case xs,ys
  { [],_ â†’ ys
  ; _,[] â†’ xs
  ; xâˆ·xsâ€²,yâˆ·ysâ€² â†’
      list-cond (x â‰¤ y)
                (x âˆ· merge xsâ€² ys)
                (y âˆ· merge xs ysâ€²)
  }

--input is shares instead of isec
--def msort : list â„¤{isec:A,B} â†’ list â„¤{yao:C}
def msort xs = case xs
  { [] â†’ []
  ; [x] â†’ [x]
  ; xâ‚âˆ·xâ‚‚âˆ·xsâ€² â†’
      let xsâ‚,xsâ‚‚ = split xs
      let ysâ‚ = msort xsâ‚
      let ysâ‚‚ = msort xsâ‚‚
      in merge ysâ‚ ysâ‚‚
  }
-- Merge sort end
